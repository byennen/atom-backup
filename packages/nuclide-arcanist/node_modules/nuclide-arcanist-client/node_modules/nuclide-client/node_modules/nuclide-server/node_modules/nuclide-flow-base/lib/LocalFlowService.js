var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

'use babel';

var _require = require('nuclide-commons');

var asyncExecute = _require.asyncExecute;
var safeSpawn = _require.safeSpawn;
var findNearestFile = _require.findNearestFile;
var getConfigValueAsync = _require.getConfigValueAsync;

var assign = require('nuclide-commons').object.assign;

var logger = require('nuclide-logging').getLogger();
var FlowService = require('./FlowService');

var _require2 = require('./FlowHelpers.js');

var getPathToFlow = _require2.getPathToFlow;
var getFlowExecOptions = _require2.getFlowExecOptions;
var insertAutocompleteToken = _require2.insertAutocompleteToken;

var LocalFlowService = (function (_FlowService) {
  _inherits(LocalFlowService, _FlowService);

  function LocalFlowService() {
    _classCallCheck(this, LocalFlowService);

    _get(Object.getPrototypeOf(LocalFlowService.prototype), 'constructor', this).call(this);
    this._startedServers = new Set();
    this._failedRoots = new Set();
  }

  _createClass(LocalFlowService, [{
    key: 'dispose',
    value: _asyncToGenerator(function* () {
      for (var server of this._startedServers) {
        // The default, SIGTERM, does not reliably kill the flow servers.
        server.kill('SIGKILL');
      }
    })

    /**
     * Returns null if it is unsafe to run Flow (i.e. if it is not installed or if
     * no .flowconfig file can be found).
     */
  }, {
    key: '_execFlow',
    value: _asyncToGenerator(function* (args, options, file) {
      var _this = this;

      var maxTries = 5;
      var flowOptions = yield getFlowExecOptions(file);
      if (!flowOptions) {
        return null;
      }
      var root = flowOptions.cwd;
      var localOptions = assign({}, options, flowOptions);
      if (this._failedRoots.has(root)) {
        return null;
      }
      args.push("--no-auto-start");
      var pathToFlow = yield getPathToFlow();
      for (var i = 0;; i++) {
        try {
          var result = yield asyncExecute(pathToFlow, args, localOptions);
          return result;
        } catch (e) {
          if (i >= maxTries) {
            throw e;
          }
          if (e.stderr.match("There is no flow server running")) {
            // `flow server` will start a server in the foreground. asyncExecute
            // will not resolve the promise until the process exits, which in this
            // case is never. We need to use spawn directly to get access to the
            // ChildProcess object.
            var serverProcess = safeSpawn(pathToFlow, ['server', root]);
            var logIt = function logIt(data) {
              logger.debug('flow server: ' + data);
            };
            serverProcess.stdout.on('data', logIt);
            serverProcess.stderr.on('data', logIt);
            serverProcess.on('exit', function (code, signal) {
              // We only want to blacklist this root if the Flow processes
              // actually failed, rather than being killed manually. It seems that
              // if they are killed, the code is null and the signal is 'SIGTERM'.
              // In the Flow crashes I have observed, the code is 2 and the signal
              // is null. So, let's blacklist conservatively for now and we can
              // add cases later if we observe Flow crashes that do not fit this
              // pattern.
              if (code === 2 && signal === null) {
                logger.error('Flow server unexpectedly exited', root);
                _this._failedRoots.add(root);
              }
            });
            this._startedServers.add(serverProcess);
          } else {
            // not sure what happened, but we'll let the caller deal with it
            throw e;
          }
          // try again
        }
      }
      // otherwise flow complains
      return {};
    })
  }, {
    key: 'findDefinition',
    value: _asyncToGenerator(function* (file, currentContents, line, column) {
      var options = {};
      // We pass the current contents of the buffer to Flow via stdin.
      // This makes it possible for get-def to operate on the unsaved content in
      // the user's editor rather than what is saved on disk. It would be annoying
      // if the user had to save before using the jump-to-definition feature to
      // ensure he or she got accurate results.
      options.stdin = currentContents;

      var args = ['get-def', '--json', '--path', file, line, column];
      try {
        var result = yield this._execFlow(args, options, file);
        if (!result) {
          return null;
        }
        if (result.exitCode === 0) {
          var json = JSON.parse(result.stdout);
          if (json['path']) {
            return {
              file: json['path'],
              line: json['line'] - 1,
              column: json['start'] - 1
            };
          } else {
            return null;
          }
        } else {
          logger.error(result.stderr);
          return null;
        }
      } catch (e) {
        logger.error(e.stderr);
        return null;
      }
    })

    /**
     * If currentContents is null, it means that the file has not changed since
     * it has been saved, so we can avoid piping the whole contents to the Flow
     * process.
     */
  }, {
    key: 'findDiagnostics',
    value: _asyncToGenerator(function* (file, currentContents) {
      var options = {};

      var args;
      if (currentContents) {
        options.stdin = currentContents;

        // Currently, `flow check-contents` returns all of the errors in the
        // project. It would be nice if it would use the path for filtering, as
        // currently the client has to do the filtering.
        args = ['check-contents', '--json', file];
      } else {
        // we can just use `flow status` if the contents are unchanged.
        args = ['status', '--json', file];
      }

      var result;
      try {
        result = yield this._execFlow(args, options, file);
        if (!result) {
          return [];
        }
      } catch (e) {
        // This codepath will be exercised when Flow finds type errors as the
        // exit code will be non-zero. Note this codepath could also be exercised
        // due to a logical error in Nuclide, so we try to differentiate.
        if (e.exitCode !== undefined) {
          result = e;
        } else {
          logger.error(e);
          return [];
        }
      }

      var json;
      try {
        json = JSON.parse(result.stdout);
      } catch (e) {
        logger.error(e);
        return [];
      }

      return json['errors'];
    })
  }, {
    key: 'getAutocompleteSuggestions',
    value: _asyncToGenerator(function* (file, currentContents, line, column, prefix) {
      var options = {};

      var args = ['autocomplete', '--json', file];

      options.stdin = insertAutocompleteToken(currentContents, line, column);
      try {
        var result = yield this._execFlow(args, options, file);
        if (!result) {
          return [];
        }
        if (result.exitCode === 0) {
          var json = JSON.parse(result.stdout);
          var replacementPrefix = /^\s*$/.test(prefix) ? '' : prefix;
          return json.map(function (item) {
            return {
              text: item['name'],
              rightLabel: item['type'],
              replacementPrefix: replacementPrefix
            };
          });
        } else {
          return [];
        }
      } catch (_) {
        return [];
      }
    })
  }, {
    key: 'getType',
    value: _asyncToGenerator(function* (file, currentContents, line, column) {
      var options = {};

      options.stdin = currentContents;

      line = line + 1;
      column = column + 1;
      var args = ['type-at-pos', line, column];

      var output;
      try {
        var result = yield this._execFlow(args, options, file);
        if (!result) {
          return null;
        }
        output = result.stdout;
      } catch (e) {
        logger.error('flow type-at-pos failed: ' + file + ':' + line + ':' + column, e);
        return null;
      }
      // instead of returning a nonzero exit code, or saying that the type is
      // "(unknown)", Flow sometimes just prints a message that includes the
      // string "Failure" at the beginning of the second line.
      if (output.match(/\nFailure/)) {
        return null;
      }
      // the type appears by itself on the first line.
      var type = output.split('\n')[0];
      if (type === '(unknown)' || type === '') {
        return null;
      }
      return type;
    })
  }]);

  return LocalFlowService;
})(FlowService);

module.exports = LocalFlowService;

// The set of Flow server processes we have started, so we can kill them on
// teardown

// The set of roots for which we have observed a Flow crash. If Flow crashes,
// we don't want to keep restarting Flow servers. We also don't want to
// disable Flow globally if only a specific Flow root in the project causes a
// crash.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWZsb3ctYmFzZS9saWIvTG9jYWxGbG93U2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLENBQUM7O2VBb0IwRCxPQUFPLENBQUMsaUJBQWlCLENBQUM7O0lBQTNGLFlBQVksWUFBWixZQUFZO0lBQUUsU0FBUyxZQUFULFNBQVM7SUFBRSxlQUFlLFlBQWYsZUFBZTtJQUFFLG1CQUFtQixZQUFuQixtQkFBbUI7O0lBQzdELE1BQU0sR0FBSSxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxNQUFNLENBQTNDLE1BQU07O0FBQ1gsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDcEQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOztnQkFDd0IsT0FBTyxDQUFDLGtCQUFrQixDQUFDOztJQUF6RixhQUFhLGFBQWIsYUFBYTtJQUFFLGtCQUFrQixhQUFsQixrQkFBa0I7SUFBRSx1QkFBdUIsYUFBdkIsdUJBQXVCOztJQUV6RCxnQkFBZ0I7WUFBaEIsZ0JBQWdCOztBQVVULFdBVlAsZ0JBQWdCLEdBVU47MEJBVlYsZ0JBQWdCOztBQVdsQiwrQkFYRSxnQkFBZ0IsNkNBV1Y7QUFDUixRQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7QUFDakMsUUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQy9COztlQWRHLGdCQUFnQjs7NkJBZ0JQLGFBQWtCO0FBQzdCLFdBQUssSUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTs7QUFFdkMsY0FBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztPQUN4QjtL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Q1YsY0FBTSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hGLGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7QUFJRCxVQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDN0IsZUFBTyxJQUFJLENBQUM7T0FDYjs7QUFFRCxVQUFJLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLFVBQUksSUFBSSxLQUFLLFdBQVcsSUFBSSxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQ3ZDLGVBQU8sSUFBSSxDQUFDO09BQ2I7QUFDRCxhQUFPLElBQUksQ0FBQztLQUNiOzs7U0F2UEcsZ0JBQWdCO0dBQVMsV0FBVzs7QUEwUDFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsZ0JBQWdCLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtZmxvdy1iYXNlL2xpYi9Mb2NhbEZsb3dTZXJ2aWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUge0RpYWdub3N0aWN9IGZyb20gJy4vRmxvd1NlcnZpY2UnO1xuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ251Y2xpZGUtcmVtb3RlLXVyaSc7XG5cbnR5cGUgTG9jID0ge1xuICBmaWxlOiBOdWNsaWRlVXJpO1xuICBsaW5lOiBudW1iZXI7XG4gIGNvbHVtbjogbnVtYmVyO1xufVxuXG52YXIge2FzeW5jRXhlY3V0ZSwgc2FmZVNwYXduLCBmaW5kTmVhcmVzdEZpbGUsIGdldENvbmZpZ1ZhbHVlQXN5bmN9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG52YXIge2Fzc2lnbn0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5vYmplY3Q7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnbnVjbGlkZS1sb2dnaW5nJykuZ2V0TG9nZ2VyKCk7XG52YXIgRmxvd1NlcnZpY2UgPSByZXF1aXJlKCcuL0Zsb3dTZXJ2aWNlJyk7XG52YXIge2dldFBhdGhUb0Zsb3csIGdldEZsb3dFeGVjT3B0aW9ucywgaW5zZXJ0QXV0b2NvbXBsZXRlVG9rZW59ID0gcmVxdWlyZSgnLi9GbG93SGVscGVycy5qcycpO1xuXG5jbGFzcyBMb2NhbEZsb3dTZXJ2aWNlIGV4dGVuZHMgRmxvd1NlcnZpY2Uge1xuICAvLyBUaGUgc2V0IG9mIEZsb3cgc2VydmVyIHByb2Nlc3NlcyB3ZSBoYXZlIHN0YXJ0ZWQsIHNvIHdlIGNhbiBraWxsIHRoZW0gb25cbiAgLy8gdGVhcmRvd25cbiAgX3N0YXJ0ZWRTZXJ2ZXJzOiBTZXQ8Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M+O1xuICAvLyBUaGUgc2V0IG9mIHJvb3RzIGZvciB3aGljaCB3ZSBoYXZlIG9ic2VydmVkIGEgRmxvdyBjcmFzaC4gSWYgRmxvdyBjcmFzaGVzLFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIGtlZXAgcmVzdGFydGluZyBGbG93IHNlcnZlcnMuIFdlIGFsc28gZG9uJ3Qgd2FudCB0b1xuICAvLyBkaXNhYmxlIEZsb3cgZ2xvYmFsbHkgaWYgb25seSBhIHNwZWNpZmljIEZsb3cgcm9vdCBpbiB0aGUgcHJvamVjdCBjYXVzZXMgYVxuICAvLyBjcmFzaC5cbiAgX2ZhaWxlZFJvb3RzOiBTZXQ8c3RyaW5nPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3N0YXJ0ZWRTZXJ2ZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2ZhaWxlZFJvb3RzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBmb3IgKHZhciBzZXJ2ZXIgb2YgdGhpcy5fc3RhcnRlZFNlcnZlcnMpIHtcbiAgICAgIC8vIFRoZSBkZWZhdWx0LCBTSUdURVJNLCBkb2VzIG5vdCByZWxpYWJseSBraWxsIHRoZSBmbG93IHNlcnZlcnMuXG4gICAgICBzZXJ2ZXIua2lsbCgnU0lHS0lMTCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bGwgaWYgaXQgaXMgdW5zYWZlIHRvIHJ1biBGbG93IChpLmUuIGlmIGl0IGlzIG5vdCBpbnN0YWxsZWQgb3IgaWZcbiAgICogbm8gLmZsb3djb25maWcgZmlsZSBjYW4gYmUgZm91bmQpLlxuICAgKi9cbiAgYXN5bmMgX2V4ZWNGbG93KGFyZ3M6IEFycmF5PGFueT4sIG9wdGlvbnM6IE9iamVjdCwgZmlsZTogc3RyaW5nKTogUHJvbWlzZTw/T2JqZWN0PiB7XG4gICAgdmFyIG1heFRyaWVzID0gNTtcbiAgICB2YXIgZmxvd09wdGlvbnMgPSBhd2FpdCBnZXRGbG93RXhlY09wdGlvbnMoZmlsZSk7XG4gICAgaWYgKCFmbG93T3B0aW9ucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByb290ID0gZmxvd09wdGlvbnMuY3dkO1xuICAgIHZhciBsb2NhbE9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMsIGZsb3dPcHRpb25zKTtcbiAgICBpZiAodGhpcy5fZmFpbGVkUm9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJncy5wdXNoKFwiLS1uby1hdXRvLXN0YXJ0XCIpO1xuICAgIHZhciBwYXRoVG9GbG93ID0gYXdhaXQgZ2V0UGF0aFRvRmxvdygpO1xuICAgIGZvciAodmFyIGkgPSAwOyA7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IGFzeW5jRXhlY3V0ZShwYXRoVG9GbG93LCBhcmdzLCBsb2NhbE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaSA+PSBtYXhUcmllcykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RkZXJyLm1hdGNoKFwiVGhlcmUgaXMgbm8gZmxvdyBzZXJ2ZXIgcnVubmluZ1wiKSkge1xuICAgICAgICAgIC8vIGBmbG93IHNlcnZlcmAgd2lsbCBzdGFydCBhIHNlcnZlciBpbiB0aGUgZm9yZWdyb3VuZC4gYXN5bmNFeGVjdXRlXG4gICAgICAgICAgLy8gd2lsbCBub3QgcmVzb2x2ZSB0aGUgcHJvbWlzZSB1bnRpbCB0aGUgcHJvY2VzcyBleGl0cywgd2hpY2ggaW4gdGhpc1xuICAgICAgICAgIC8vIGNhc2UgaXMgbmV2ZXIuIFdlIG5lZWQgdG8gdXNlIHNwYXduIGRpcmVjdGx5IHRvIGdldCBhY2Nlc3MgdG8gdGhlXG4gICAgICAgICAgLy8gQ2hpbGRQcm9jZXNzIG9iamVjdC5cbiAgICAgICAgICB2YXIgc2VydmVyUHJvY2VzcyA9IHNhZmVTcGF3bihwYXRoVG9GbG93LCBbJ3NlcnZlcicsIHJvb3RdKTtcbiAgICAgICAgICB2YXIgbG9nSXQgPSBkYXRhID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnZmxvdyBzZXJ2ZXI6ICcgKyBkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNlcnZlclByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgbG9nSXQpO1xuICAgICAgICAgIHNlcnZlclByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgbG9nSXQpO1xuICAgICAgICAgIHNlcnZlclByb2Nlc3Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gYmxhY2tsaXN0IHRoaXMgcm9vdCBpZiB0aGUgRmxvdyBwcm9jZXNzZXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGZhaWxlZCwgcmF0aGVyIHRoYW4gYmVpbmcga2lsbGVkIG1hbnVhbGx5LiBJdCBzZWVtcyB0aGF0XG4gICAgICAgICAgICAvLyBpZiB0aGV5IGFyZSBraWxsZWQsIHRoZSBjb2RlIGlzIG51bGwgYW5kIHRoZSBzaWduYWwgaXMgJ1NJR1RFUk0nLlxuICAgICAgICAgICAgLy8gSW4gdGhlIEZsb3cgY3Jhc2hlcyBJIGhhdmUgb2JzZXJ2ZWQsIHRoZSBjb2RlIGlzIDIgYW5kIHRoZSBzaWduYWxcbiAgICAgICAgICAgIC8vIGlzIG51bGwuIFNvLCBsZXQncyBibGFja2xpc3QgY29uc2VydmF0aXZlbHkgZm9yIG5vdyBhbmQgd2UgY2FuXG4gICAgICAgICAgICAvLyBhZGQgY2FzZXMgbGF0ZXIgaWYgd2Ugb2JzZXJ2ZSBGbG93IGNyYXNoZXMgdGhhdCBkbyBub3QgZml0IHRoaXNcbiAgICAgICAgICAgIC8vIHBhdHRlcm4uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMiAmJiBzaWduYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdGbG93IHNlcnZlciB1bmV4cGVjdGVkbHkgZXhpdGVkJywgcm9vdCk7XG4gICAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9zdGFydGVkU2VydmVycy5hZGQoc2VydmVyUHJvY2Vzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IHN1cmUgd2hhdCBoYXBwZW5lZCwgYnV0IHdlJ2xsIGxldCB0aGUgY2FsbGVyIGRlYWwgd2l0aCBpdFxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IGFnYWluXG4gICAgICB9XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBmbG93IGNvbXBsYWluc1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGFzeW5jIGZpbmREZWZpbml0aW9uKFxuICAgIGZpbGU6IE51Y2xpZGVVcmksXG4gICAgY3VycmVudENvbnRlbnRzOiBzdHJpbmcsXG4gICAgbGluZTogbnVtYmVyLFxuICAgIGNvbHVtbjogbnVtYmVyXG4gICk6IFByb21pc2U8P0xvYz4ge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgLy8gV2UgcGFzcyB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgYnVmZmVyIHRvIEZsb3cgdmlhIHN0ZGluLlxuICAgIC8vIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIGdldC1kZWYgdG8gb3BlcmF0ZSBvbiB0aGUgdW5zYXZlZCBjb250ZW50IGluXG4gICAgLy8gdGhlIHVzZXIncyBlZGl0b3IgcmF0aGVyIHRoYW4gd2hhdCBpcyBzYXZlZCBvbiBkaXNrLiBJdCB3b3VsZCBiZSBhbm5veWluZ1xuICAgIC8vIGlmIHRoZSB1c2VyIGhhZCB0byBzYXZlIGJlZm9yZSB1c2luZyB0aGUganVtcC10by1kZWZpbml0aW9uIGZlYXR1cmUgdG9cbiAgICAvLyBlbnN1cmUgaGUgb3Igc2hlIGdvdCBhY2N1cmF0ZSByZXN1bHRzLlxuICAgIG9wdGlvbnMuc3RkaW4gPSBjdXJyZW50Q29udGVudHM7XG5cbiAgICB2YXIgYXJncyA9IFsnZ2V0LWRlZicsICctLWpzb24nLCAnLS1wYXRoJywgZmlsZSwgbGluZSwgY29sdW1uXTtcbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V4ZWNGbG93KGFyZ3MsIG9wdGlvbnMsIGZpbGUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmV4aXRDb2RlID09PSAwKSB7XG4gICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZShyZXN1bHQuc3Rkb3V0KTtcbiAgICAgICAgaWYgKGpzb25bJ3BhdGgnXSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlOiBqc29uWydwYXRoJ10sXG4gICAgICAgICAgICBsaW5lOiBqc29uWydsaW5lJ10gLSAxLFxuICAgICAgICAgICAgY29sdW1uOiBqc29uWydzdGFydCddIC0gMSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IocmVzdWx0LnN0ZGVycik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGUuc3RkZXJyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBjdXJyZW50Q29udGVudHMgaXMgbnVsbCwgaXQgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgbm90IGNoYW5nZWQgc2luY2VcbiAgICogaXQgaGFzIGJlZW4gc2F2ZWQsIHNvIHdlIGNhbiBhdm9pZCBwaXBpbmcgdGhlIHdob2xlIGNvbnRlbnRzIHRvIHRoZSBGbG93XG4gICAqIHByb2Nlc3MuXG4gICAqL1xuICBhc3luYyBmaW5kRGlhZ25vc3RpY3MoZmlsZTogTnVjbGlkZVVyaSwgY3VycmVudENvbnRlbnRzOiA/c3RyaW5nKTogUHJvbWlzZTxBcnJheTxEaWFnbm9zdGljPj4ge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICB2YXIgYXJncztcbiAgICBpZiAoY3VycmVudENvbnRlbnRzKSB7XG4gICAgICBvcHRpb25zLnN0ZGluID0gY3VycmVudENvbnRlbnRzO1xuXG4gICAgICAvLyBDdXJyZW50bHksIGBmbG93IGNoZWNrLWNvbnRlbnRzYCByZXR1cm5zIGFsbCBvZiB0aGUgZXJyb3JzIGluIHRoZVxuICAgICAgLy8gcHJvamVjdC4gSXQgd291bGQgYmUgbmljZSBpZiBpdCB3b3VsZCB1c2UgdGhlIHBhdGggZm9yIGZpbHRlcmluZywgYXNcbiAgICAgIC8vIGN1cnJlbnRseSB0aGUgY2xpZW50IGhhcyB0byBkbyB0aGUgZmlsdGVyaW5nLlxuICAgICAgYXJncyA9IFsnY2hlY2stY29udGVudHMnLCAnLS1qc29uJywgZmlsZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGNhbiBqdXN0IHVzZSBgZmxvdyBzdGF0dXNgIGlmIHRoZSBjb250ZW50cyBhcmUgdW5jaGFuZ2VkLlxuICAgICAgYXJncyA9IFsnc3RhdHVzJywgJy0tanNvbicsIGZpbGVdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V4ZWNGbG93KGFyZ3MsIG9wdGlvbnMsIGZpbGUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoaXMgY29kZXBhdGggd2lsbCBiZSBleGVyY2lzZWQgd2hlbiBGbG93IGZpbmRzIHR5cGUgZXJyb3JzIGFzIHRoZVxuICAgICAgLy8gZXhpdCBjb2RlIHdpbGwgYmUgbm9uLXplcm8uIE5vdGUgdGhpcyBjb2RlcGF0aCBjb3VsZCBhbHNvIGJlIGV4ZXJjaXNlZFxuICAgICAgLy8gZHVlIHRvIGEgbG9naWNhbCBlcnJvciBpbiBOdWNsaWRlLCBzbyB3ZSB0cnkgdG8gZGlmZmVyZW50aWF0ZS5cbiAgICAgIGlmIChlLmV4aXRDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShyZXN1bHQuc3Rkb3V0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb25bJ2Vycm9ycyddO1xuICB9XG5cbiAgYXN5bmMgZ2V0QXV0b2NvbXBsZXRlU3VnZ2VzdGlvbnMoXG4gICAgZmlsZTogTnVjbGlkZVVyaSxcbiAgICBjdXJyZW50Q29udGVudHM6IHN0cmluZyxcbiAgICBsaW5lOiBudW1iZXIsXG4gICAgY29sdW1uOiBudW1iZXIsXG4gICAgcHJlZml4OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGFyZ3MgPSBbJ2F1dG9jb21wbGV0ZScsICctLWpzb24nLCBmaWxlXTtcblxuICAgIG9wdGlvbnMuc3RkaW4gPSBpbnNlcnRBdXRvY29tcGxldGVUb2tlbihjdXJyZW50Q29udGVudHMsIGxpbmUsIGNvbHVtbik7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSBhd2FpdCB0aGlzLl9leGVjRmxvdyhhcmdzLCBvcHRpb25zLCBmaWxlKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuZXhpdENvZGUgPT09IDApIHtcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHJlc3VsdC5zdGRvdXQpO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnRQcmVmaXggPSAvXlxccyokLy50ZXN0KHByZWZpeCkgPyAnJyA6IHByZWZpeDtcbiAgICAgICAgcmV0dXJuIGpzb24ubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBpdGVtWyduYW1lJ10sXG4gICAgICAgICAgICByaWdodExhYmVsOiBpdGVtWyd0eXBlJ10sXG4gICAgICAgICAgICByZXBsYWNlbWVudFByZWZpeCxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VHlwZShcbiAgICBmaWxlOiBOdWNsaWRlVXJpLFxuICAgIGN1cnJlbnRDb250ZW50czogc3RyaW5nLFxuICAgIGxpbmU6IG51bWJlcixcbiAgICBjb2x1bW46IG51bWJlclxuICApOiBQcm9taXNlPD9zdHJpbmc+IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgb3B0aW9ucy5zdGRpbiA9IGN1cnJlbnRDb250ZW50cztcblxuICAgIGxpbmUgPSBsaW5lICsgMTtcbiAgICBjb2x1bW4gPSBjb2x1bW4gKyAxO1xuICAgIHZhciBhcmdzID0gWyd0eXBlLWF0LXBvcycsIGxpbmUsIGNvbHVtbl07XG5cbiAgICB2YXIgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZXhlY0Zsb3coYXJncywgb3B0aW9ucywgZmlsZSk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG91dHB1dCA9IHJlc3VsdC5zdGRvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdmbG93IHR5cGUtYXQtcG9zIGZhaWxlZDogJyArIGZpbGUgKyAnOicgKyBsaW5lICsgJzonICsgY29sdW1uLCBlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5vbnplcm8gZXhpdCBjb2RlLCBvciBzYXlpbmcgdGhhdCB0aGUgdHlwZSBpc1xuICAgIC8vIFwiKHVua25vd24pXCIsIEZsb3cgc29tZXRpbWVzIGp1c3QgcHJpbnRzIGEgbWVzc2FnZSB0aGF0IGluY2x1ZGVzIHRoZVxuICAgIC8vIHN0cmluZyBcIkZhaWx1cmVcIiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgbGluZS5cbiAgICBpZiAob3V0cHV0Lm1hdGNoKC9cXG5GYWlsdXJlLykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB0aGUgdHlwZSBhcHBlYXJzIGJ5IGl0c2VsZiBvbiB0aGUgZmlyc3QgbGluZS5cbiAgICB2YXIgdHlwZSA9IG91dHB1dC5zcGxpdCgnXFxuJylbMF07XG4gICAgaWYgKHR5cGUgPT09ICcodW5rbm93biknIHx8IHR5cGUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbEZsb3dTZXJ2aWNlO1xuIl19
