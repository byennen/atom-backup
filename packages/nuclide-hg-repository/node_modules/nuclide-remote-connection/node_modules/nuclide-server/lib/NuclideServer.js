
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var blocked = require('./blocked');
var connect = require('connect');
var fs = require('fs');

var _require = require('./service-manager');

var getService = _require.getService;
var getRemoteEventName = _require.getRemoteEventName;

var http = require('http');
var https = require('https');

var _require2 = require('./config');

var SERVICE_FRAMEWORK_EVENT_CHANNEL = _require2.SERVICE_FRAMEWORK_EVENT_CHANNEL;
var SERVICE_FRAMEWORK_RPC_CHANNEL = _require2.SERVICE_FRAMEWORK_RPC_CHANNEL;

var _require3 = require('nuclide-service-transformer');

var parseServiceApiSync = _require3.parseServiceApiSync;

var path = require('path');

var _require4 = require('events');

var EventEmitter = _require4.EventEmitter;

var WebSocketServer = require('ws').Server;

var _require5 = require('./utils');

var deserializeArgs = _require5.deserializeArgs;
var sendJsonResponse = _require5.sendJsonResponse;
var sendTextResponse = _require5.sendTextResponse;

var _require6 = require('nuclide-version');

var getVersion = _require6.getVersion;

var logger = require('nuclide-logging').getLogger();

var SERVER_SHUTDOWN_TIMEOUT_MS = 1000;
var STAT_BIN_SIZE_MS = 20;

var EVENT_HANDLE_REGISTERED = '_nuclideServerEventHandleRegstered';
var idIncrement = 0;

var NuclideServer = (function () {
  function NuclideServer(options) {
    _classCallCheck(this, NuclideServer);

    var serverKey = options.serverKey;
    var serverCertificate = options.serverCertificate;
    var port = options.port;
    var certificateAuthorityCertificate = options.certificateAuthorityCertificate;
    var trackEventLoop = options.trackEventLoop;

    this._app = connect();
    this._attachUtilHandlers(this._app);
    if (serverKey && serverCertificate && certificateAuthorityCertificate) {
      var webServerOptions = {
        key: serverKey,
        cert: serverCertificate,
        ca: certificateAuthorityCertificate,
        requestCert: true,
        rejectUnauthorized: true
      };

      this._webServer = https.createServer(webServerOptions, this._app);
    } else {
      this._webServer = http.createServer(this._app);
    }
    this._port = port;

    this._webSocketServer = this._createWebSocketServer();
    this._clients = {};
    this._eventSubscriptions = new Map();

    var eventbus = this.eventbus = new EventEmitter();
    // Any service can use the eventbus API like: `this.publish(eventName, {})`.
    this.publish = this.broadcast = eventbus.emit.bind(eventbus);
    this.subscribe = eventbus.on.bind(eventbus);
    this.subscribeOnce = eventbus.once.bind(eventbus);
    this.unsubscribe = eventbus.removeListener.bind(eventbus);
    this._eventEmitters = {};

    this._setupServices();

    if (trackEventLoop) {
      blocked(function (ms) {
        logger.info('NuclideServer event loop blocked for ' + ms + 'ms');
      });
    }
  }

  _createClass(NuclideServer, [{
    key: '_attachUtilHandlers',
    value: function _attachUtilHandlers(app) {
      var _this = this;

      // Add specific method handlers.
      ['get', 'post', 'delete', 'put'].forEach(function (methodName) {
        _this._app[methodName] = function (uri, handler) {
          _this._app.use(uri, function (request, response, next) {
            if (request.method.toUpperCase() !== methodName.toUpperCase()) {
              // skip if method doesn't match.
              return next();
            } else {
              handler(request, response, next);
            }
          });
        };
      });
    }
  }, {
    key: '_createWebSocketServer',
    value: function _createWebSocketServer() {
      var _this2 = this;

      var webSocketServer = new WebSocketServer({ server: this._webServer });
      webSocketServer.on('connection', function (socket) {
        return _this2._onConnection(socket);
      });
      webSocketServer.on('error', function (error) {
        return logger.error('WebSocketServer Error:', error);
      });
      return webSocketServer;
    }
  }, {
    key: '_getServiceFrameworkServiceAndRegisterEventHandle',
    value: function _getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions) {
      var _this3 = this;

      var localServiceInstance = getService(serviceConfig.name, serviceOptions, serviceConfig.implementation);
      if (localServiceInstance[EVENT_HANDLE_REGISTERED]) {
        return localServiceInstance;
      }

      var serviceApi = parseServiceApiSync(serviceConfig.definition, serviceConfig.name);

      serviceApi.eventMethodNames.forEach(function (methodName) {
        localServiceInstance[methodName].call(localServiceInstance, function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var eventName = getRemoteEventName(serviceConfig.name, methodName, serviceOptions);
          (_this3._eventSubscriptions.get(eventName) || []).forEach(function (clientId) {
            var client = _this3._clients[clientId];

            if (!client) {
              logger.warn('Client with clientId: %s not found!', clientId);
              return;
            }

            _this3._sendSocketMessage(client, {
              channel: SERVICE_FRAMEWORK_EVENT_CHANNEL,
              event: {
                name: eventName,
                args: args
              }
            });
          });
        });
      });
      Object.defineProperty(localServiceInstance, EVENT_HANDLE_REGISTERED, { value: true });

      return localServiceInstance;
    }
  }, {
    key: '_registerServiceWithServiceFramework',
    value: function _registerServiceWithServiceFramework(serviceConfig) {
      var _this4 = this;

      var serviceApi = parseServiceApiSync(serviceConfig.definition, serviceConfig.name);

      serviceApi.rpcMethodNames.forEach(function (methodName) {
        _this4._registerService('/' + serviceApi.className + '/' + methodName,

        // Take serviceOptions as first argument for serviceFramework service.
        // TODO(chenshen) seperate the logic of service initialization.
        function (serviceOptions) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          var localServiceInstance = _this4._getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions);
          return localServiceInstance[methodName].apply(localServiceInstance, args);
        }, 'post');
      });
    }
  }, {
    key: '_registerServiceWithoutServiceFramework',
    value: function _registerServiceWithoutServiceFramework(serviceFilePath) {
      var _require7 = require(serviceFilePath);

      var urlHandlers = _require7.urlHandlers;
      var services = _require7.services;
      var initialize = _require7.initialize;

      for (var serviceName in services) {
        var serviceConfig = services[serviceName];
        this._registerService(serviceName, serviceConfig.handler, serviceConfig.method, serviceConfig.text);
      }

      if (urlHandlers) {
        for (var url in urlHandlers) {
          var handlerConfig = urlHandlers[url];
          this._attachUrlHandler(url, handlerConfig.handler, handlerConfig.method);
        }
      }

      if (initialize) {
        initialize(this);
      }
    }
  }, {
    key: '_setupServices',
    value: function _setupServices() {
      var _this5 = this;

      // Lazy require these functions so that we could spyOn them while testing in
      // ServiceIntegrationTestHelper.

      var _require8 = require('./config');

      var loadConfigsOfServiceWithServiceFramework = _require8.loadConfigsOfServiceWithServiceFramework;
      var loadConfigsOfServiceWithoutServiceFramework = _require8.loadConfigsOfServiceWithoutServiceFramework;

      this._serviceRegistry = {};
      this._setupStatsHandler();
      this._setupVersionHandler();
      this._setupShutdownHandler();
      this._setupSubscriptionHandler();
      this._setupServiceFrameworkSubscriptionHandler();
      this._serviceWithoutServiceFrameworkConfigs = loadConfigsOfServiceWithoutServiceFramework();
      this._serviceWithServiceFrameworkConfigs = loadConfigsOfServiceWithServiceFramework();

      this._serviceWithoutServiceFrameworkConfigs.forEach(function (config) {
        _this5._registerServiceWithoutServiceFramework(config);
        logger.info('Registered service ' + config + ' without ServiceFramework.');
      });

      this._serviceWithServiceFrameworkConfigs.forEach(function (config) {
        _this5._registerServiceWithServiceFramework(config);
        logger.info('Registered service ' + config.name + ' with ServiceFramework.');
      });

      // Setup error handler.
      this._app.use(function (error, request, response, next) {
        if (error) {
          sendJsonResponse(response, { code: error.code, message: error.message }, 500);
        } else {
          next();
        }
      });
    }
  }, {
    key: '_setupStatsHandler',
    value: function _setupStatsHandler() {
      var _this6 = this;

      this._clearStats();
      this._registerService('/server/getStats', function () {
        return {
          errors: _this6._errors,
          responses: _this6._responses
        };
      }, 'get', false);
      this._registerService('/server/clearStats', this._clearStats.bind(this), 'post', false);
    }
  }, {
    key: '_setupVersionHandler',
    value: function _setupVersionHandler() {
      var _this7 = this;

      this._version = getVersion().toString();
      this._registerService('/server/version', function () {
        return _this7._version;
      }, 'post', true);
    }
  }, {
    key: '_setupShutdownHandler',
    value: function _setupShutdownHandler() {
      var _this8 = this;

      var shutdownServer = function shutdownServer() {
        logger.info('Shutting down the server');
        try {
          _this8.close();
        } catch (e) {
          logger.error('Error while shutting down, but proceeding anyway:', e);
        } finally {
          process.exit(0);
        }
      };
      this._registerService('/server/shutdown', function () {
        logger.info('Server received a shutdown request - terminating!');
        // Shutdown after timeout to give a chance to reply success to the shutdown request.
        setTimeout(shutdownServer, SERVER_SHUTDOWN_TIMEOUT_MS);
      }, 'post');
    }
  }, {
    key: '_setupSubscriptionHandler',
    value: function _setupSubscriptionHandler() {
      var _this9 = this;

      this._registerService('/eventbus/subscribe', function (clientId, channel, options) {
        var client = _this9._clients[clientId];
        if (!client) {
          return logger.error('Client with clientId: %s not found!', clientId);
        } else if (client.subscriptions[channel]) {
          return logger.warn('Client %s already subscribed to channel: %s', clientId, channel);
        } else {
          var subscibeHandler = client.subscriptions[channel] = function (event) {
            return _this9._sendSocketMessage(client, { channel: channel, event: event });
          };
          _this9.subscribe(channel, subscibeHandler);
        }
        if (options.eventEmitterId) {
          _this9._consumeEventEmitter(options.eventEmitterId, channel, options.eventNames);
        }
      }, 'post');
    }
  }, {
    key: '_setupServiceFrameworkSubscriptionHandler',
    value: function _setupServiceFrameworkSubscriptionHandler() {
      var _this10 = this;

      this._registerService('/serviceFramework/subscribeEvent', function (serviceOptions, clientId, serviceName, methodName) {

        // Create the service instance and register the event handle.

        var _serviceWithServiceFrameworkConfigs$filter = _this10._serviceWithServiceFrameworkConfigs.filter(function (config) {
          return config.name === serviceName;
        });

        var _serviceWithServiceFrameworkConfigs$filter2 = _slicedToArray(_serviceWithServiceFrameworkConfigs$filter, 1);

        var serviceConfig = _serviceWithServiceFrameworkConfigs$filter2[0];

        _this10._getServiceFrameworkServiceAndRegisterEventHandle(serviceConfig, serviceOptions);

        var eventName = getRemoteEventName(serviceName, methodName, serviceOptions);

        _this10._eventSubscriptions.set(eventName, (_this10._eventSubscriptions.get(eventName) || new Set()).add(clientId));

        logger.debug(clientId + ' subscribed to ' + eventName);
      }, 'post');

      this._registerService('/serviceFramework/unsubscribeEvent', function (serviceOptions, clientId, serviceName, methodName) {
        var eventName = getRemoteEventName(serviceName, methodName, serviceOptions);
        if (_this10._eventSubscriptions.has(eventName)) {
          _this10._eventSubscriptions.get(eventName)['delete'](clientId);
        }
        logger.debug(clientId + ' unsubscribed to ' + eventName);
      }, 'post');
    }
  }, {
    key: 'connect',
    value: function connect() {
      var _this11 = this;

      return new Promise(function (resolve, reject) {
        _this11._webServer.on('listening', function () {
          resolve();
        });
        _this11._webServer.on('error', function (e) {
          _this11._webServer.removeAllListeners();
          reject(e);
        });
        _this11._webServer.listen(_this11._port);
      });
    }

    /**
     * Calls a registered service with a name and arguments.
     */
  }, {
    key: 'callService',
    value: function callService(serviceName, args) {
      var serviceFunction = this._serviceRegistry[serviceName];
      if (!serviceFunction) {
        throw Error('No service registered with name: ' + serviceName);
      }
      return this._recordRequestStats(serviceName, args, serviceFunction);
    }

    /**
     * Given a service request, records response time and errors
     */
  }, {
    key: '_recordRequestStats',
    value: _asyncToGenerator(function* (serviceName, args, serviceFunction) {
      var requestStart = Date.now();
      var result = null;

      try {
        result = yield serviceFunction.apply(this, args);

        var responseTime = Date.now() - requestStart;
        var bin = Math.floor(responseTime / STAT_BIN_SIZE_MS) * STAT_BIN_SIZE_MS;
        if (!this._responses[bin]) {
          this._responses[bin] = [];
        }
        this._responses[bin].push({ serviceName: serviceName });
      } catch (error) {
        var responseTime = Date.now() - requestStart;
        this._errors.push({
          error: error,
          responseTime: responseTime,
          serviceName: serviceName
        });
        throw error;
      }

      return result;
    })
  }, {
    key: '_clearStats',
    value: function _clearStats() {
      this._errors = [];
      return this._responses = {};
    }

    /**
     * Registers a service function to a service name.
     * This allows simple future calls of the service by name and arguments or http-triggered endpoint calls
     * with arguments serialized over http.
     */
  }, {
    key: '_registerService',
    value: function _registerService(serviceName, serviceFunction, method, isTextResponse) {
      if (method === undefined) method = 'get';

      if (this._serviceRegistry[serviceName]) {
        throw new Error('A service with this name is already registered:', serviceName);
      }
      this._serviceRegistry[serviceName] = serviceFunction;
      this._registerHttpService(serviceName, method, isTextResponse);
    }
  }, {
    key: '_registerHttpService',
    value: function _registerHttpService(serviceName, method, isTextResponse) {
      var _this12 = this;

      var loweredCaseMethod = method.toLowerCase();
      this._app[loweredCaseMethod](serviceName, _asyncToGenerator(function* (request, response, next) {
        try {
          var result = yield _this12.callService(serviceName, deserializeArgs(request.url));
          if (isTextResponse) {
            sendTextResponse(response, result || '');
          } else {
            sendJsonResponse(response, result);
          }
        } catch (e) {
          // Delegate to the registered connect error handler.
          next(e);
        }
      }));
    }

    /**
     * Attach an explicit http connect handler for some services that need request/response related optimizations.
     * e.g. readFile and writeFile uses it to stream reading and writing files (perf improvement for big files).
     */
  }, {
    key: '_attachUrlHandler',
    value: function _attachUrlHandler(url, handler) {
      var method = arguments.length <= 2 || arguments[2] === undefined ? 'get' : arguments[2];

      this._app[method](url, handler);
    }
  }, {
    key: '_onConnection',
    value: function _onConnection(socket) {
      var _this13 = this;

      logger.info('WebSocket connecting');

      var subscriptions = {};
      var client = null;

      socket.on('error', function (e) {
        return logger.error('Client #%s error: %s', client ? client.id : 'unkown', e.message);
      });

      socket.once('message', function (clientId) {
        client = _this13._clients[clientId] = _this13._clients[clientId] || { subscriptions: {}, id: clientId, messageQueue: [] };
        // If an existing client, we close its socket before listening to the new socket.
        if (client.socket) {
          client.socket.close();
          client.socket = null;
        }
        logger.info('Client #%s connecting with a new socket!', clientId);
        client.socket = socket;
        client.messageQueue.splice(0).forEach(function (message) {
          return _this13._sendSocketMessage(client, message.data);
        });
        socket.on('message', function (message) {
          return _this13._onSocketMessage(client, message);
        });
      });

      socket.on('close', function () {
        if (!client) {
          return;
        }
        if (client.socket === socket) {
          client.socket = null;
        }
        logger.info('Client #%s closing a socket!', client.id);
        // TODO: enable subscription cleanup when we have a robust reconnect scenario.
        /*
        for (var channel in client.subscriptions) {
          this.unsubscribe(channel, subscriptions[channel]);
        }
        this._eventSubscriptions.forEach(value => value.delete(client.id));
        delete this._clients[client.id];
        */
      });
    }
  }, {
    key: '_onSocketMessage',
    value: _asyncToGenerator(function* (client, message) {
      message = JSON.parse(message);
      var _message = message;
      var serviceName = _message.serviceName;
      var methodName = _message.methodName;
      var methodArgs = _message.methodArgs;
      var serviceOptions = _message.serviceOptions;
      var requestId = _message.requestId;

      var result = null;
      var error = null;

      try {
        var result = yield this.callService('/' + serviceName + '/' + methodName, [serviceOptions].concat(methodArgs));
      } catch (e) {
        logger.error('Failed to call %s/%s with error %o', serviceName, methodName, e);
        error = e;
      }

      this._sendSocketMessage(client, {
        channel: SERVICE_FRAMEWORK_RPC_CHANNEL,
        requestId: requestId,
        result: result,
        error: error
      });
    })

    /**
     * This could be used by services to wrap a stream or an event emitter to an id that
     * a client can subscribe to on the eventbus.
     */
  }, {
    key: 'registerEventEmitter',
    value: function registerEventEmitter(eventEmitter) {
      var id = ++idIncrement;
      this._eventEmitters[id] = eventEmitter;
      return id;
    }

    /**
     * Starts consuming an event emitter by listening on the requested event names
     * and publish them on the eventbus for subscribed clients to consume as part of thier services.
     */
  }, {
    key: '_consumeEventEmitter',
    value: function _consumeEventEmitter(id, channel, eventNames) {
      var _this14 = this;

      var eventEmitter = this._eventEmitters[id];
      if (eventEmitter.consumed) {
        return;
      }

      eventNames.forEach(function (eventName) {
        // listen to every event and publish it on the event bus.
        eventEmitter.on(eventName, function () {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this14.publish(channel, {
            eventEmitterId: id,
            type: eventName,
            args: args.map(function (arg) {
              // The arguments needs to be json serializable.
              if (Buffer.isBuffer(arg)) {
                // e.g. node streams emit 'data' buffers.
                return arg.toString();
              } else {
                // string, number, object, null, boolean, ..etc.
                return arg;
              }
            })
          });
        });
      });

      eventEmitter.consumed = true;
    }
  }, {
    key: '_sendSocketMessage',
    value: function _sendSocketMessage(client, data) {
      // Wrap the data in an object, because if `data` is a primitive data type,
      // finding it in an array would return the first matching item, not necessarily the same inserted item.
      var message = { data: data };
      var id = client.id;
      var socket = client.socket;
      var messageQueue = client.messageQueue;

      messageQueue.push(message);
      if (!socket) {
        return;
      }
      socket.send(JSON.stringify(data), function (err) {
        if (err) {
          logger.warn('Failed sending socket message to client:', id, data);
        } else {
          var messageIndex = messageQueue.indexOf(message);
          if (messageIndex !== -1) {
            messageQueue.splice(messageIndex, 1);
          }
        }
      });
    }
  }, {
    key: 'close',
    value: function close() {
      var _this15 = this;

      this._webSocketServer.close();
      this._webServer.close();
      this._serviceWithoutServiceFrameworkConfigs.forEach(function (service_path) {
        var _require9 = require(service_path);

        var shutdown = _require9.shutdown;

        if (shutdown) {
          shutdown(_this15);
        }
      });
    }
  }]);

  return NuclideServer;
})();

module.exports = NuclideServer;
/* eventName */ /* clientId */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvTnVjbGlkZVNlcnZlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdaLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNuQyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDakMsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDOztlQUNnQixPQUFPLENBQUMsbUJBQW1CLENBQUM7O0lBQTlELFVBQVUsWUFBVixVQUFVO0lBQUUsa0JBQWtCLFlBQWxCLGtCQUFrQjs7QUFDbkMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzNCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzs7Z0JBRU0sT0FBTyxDQUFDLFVBQVUsQ0FBQzs7SUFEakQsK0JBQStCLGFBQS9CLCtCQUErQjtJQUNsQyw2QkFBNkIsYUFBN0IsNkJBQTZCOztnQkFDSCxPQUFPLENBQUMsNkJBQTZCLENBQUM7O0lBQTdELG1CQUFtQixhQUFuQixtQkFBbUI7O0FBQ3hCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Z0JBQ04sT0FBTyxDQUFDLFFBQVEsQ0FBQzs7SUFBakMsWUFBWSxhQUFaLFlBQVk7O0FBQ2pCLElBQUksZUFBZSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7O2dCQUNpQixPQUFPLENBQUMsU0FBUyxDQUFDOztJQUF6RSxlQUFlLGFBQWYsZUFBZTtJQUFFLGdCQUFnQixhQUFoQixnQkFBZ0I7SUFBRSxnQkFBZ0IsYUFBaEIsZ0JBQWdCOztnQkFDckMs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WUFBSSxHQUFHLEVBQUU7QUFDUCxnQkFBTSxDQUFDLElBQUksQ0FBQywwQ0FBMEMsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkUsTUFBTTtBQUNMLGNBQUksWUFBWSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDakQsY0FBSSxZQUFZLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDdkIsd0JBQVksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO1dBQ3RDO1NBQ0Y7T0FDRixDQUFDLENBQUM7S0FDSjs7O1dBRUksaUJBQUc7OztBQUNOLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUM5QixVQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3hCLFVBQUksQ0FBQyxzQ0FBc0MsQ0FBQyxPQUFPLENBQUMsVUFBQSxZQUFZLEVBQUk7d0JBQ2pELE9BQU8sQ0FBQyxZQUFZLENBQUM7O1lBQWpDLFFBQVEsYUFBUixRQUFROztBQUNiLFlBQUksUUFBUSxFQUFFO0FBQ1osa0JBQVEsU0FBTSxDQUFDO1NBQ2hCO09BQ0YsQ0FBQyxDQUFDO0tBQ0o7OztTQW5nQkcsYUFBYTs7O0FBc2dCbkIsTUFBTSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmVyL2xpYi9OdWNsaWRlU2VydmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGJsb2NrZWQgPSByZXF1aXJlKCcuL2Jsb2NrZWQnKTtcbnZhciBjb25uZWN0ID0gcmVxdWlyZSgnY29ubmVjdCcpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciB7Z2V0U2VydmljZSwgZ2V0UmVtb3RlRXZlbnROYW1lfSA9IHJlcXVpcmUoJy4vc2VydmljZS1tYW5hZ2VyJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIge1NFUlZJQ0VfRlJBTUVXT1JLX0VWRU5UX0NIQU5ORUwsXG4gIFNFUlZJQ0VfRlJBTUVXT1JLX1JQQ19DSEFOTkVMfSA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIge3BhcnNlU2VydmljZUFwaVN5bmN9ID0gcmVxdWlyZSgnbnVjbGlkZS1zZXJ2aWNlLXRyYW5zZm9ybWVyJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciB7RXZlbnRFbWl0dGVyfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIFdlYlNvY2tldFNlcnZlciA9IHJlcXVpcmUoJ3dzJykuU2VydmVyO1xudmFyIHtkZXNlcmlhbGl6ZUFyZ3MsIHNlbmRKc29uUmVzcG9uc2UsIHNlbmRUZXh0UmVzcG9uc2V9ID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHtnZXRWZXJzaW9ufSA9IHJlcXVpcmUoJ251Y2xpZGUtdmVyc2lvbicpO1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnbnVjbGlkZS1sb2dnaW5nJykuZ2V0TG9nZ2VyKCk7XG5cbmNvbnN0IFNFUlZFUl9TSFVURE9XTl9USU1FT1VUX01TID0gMTAwMDtcbmNvbnN0IFNUQVRfQklOX1NJWkVfTVMgPSAyMDtcblxudmFyIEVWRU5UX0hBTkRMRV9SRUdJU1RFUkVEID0gJ19udWNsaWRlU2VydmVyRXZlbnRIYW5kbGVSZWdzdGVyZWQnO1xudmFyIGlkSW5jcmVtZW50ID0gMDtcblxudHlwZSBOdWNsaWRlU2VydmVyT3B0aW9ucyA9IHtcbiAgcG9ydDogbnVtYmVyO1xuICBzZXJ2ZXJLZXk6ID9CdWZmZXI7XG4gIHNlcnZlckNlcnRpZmljYXRlOiA/QnVmZmVyO1xuICBjZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlOiA/QnVmZmVyO1xuICB0cmFja0V2ZW50TG9vcDogP2Jvb2xlYW47XG59XG5cbnR5cGUgU29ja2V0Q2xpZW50ID0ge1xuICBpZDogc3RyaW5nO1xuICBzdWJzY3JpcHRpb25zOiB7W2NoYW5uZWw6IHN0cmluZ106IChldmVudDogYW55KSA9PiB2b2lkfTtcbiAgc29ja2V0OiA/V2ViU29ja2V0O1xufTtcblxudHlwZSBTZXJ2aWNlQ29uZmlnID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlZmluaXRpb246IHN0cmluZztcbiAgaW1wbGVtZW50YXRpb246IHN0cmluZztcbn1cblxuY2xhc3MgTnVjbGlkZVNlcnZlciB7XG4gIF93ZWJTZXJ2ZXI6IGh0dHAuU2VydmVyIHwgaHR0cHMuU2VydmVyO1xuICBfd2ViU29ja2V0U2VydmVyOiBXZWJTb2NrZXRTZXJ2ZXI7XG4gIF9jbGllbnRzOiB7W2NsaWVudElkOiBzdHJpbmddOiBTb2NrZXRDbGllbnR9O1xuICBfZXZlbnRTdWJzY3JpcHRpb25zOiBNYXA8LyogZXZlbnROYW1lICovIHN0cmluZywgU2V0PC8qIGNsaWVudElkICovIHN0cmluZz4+O1xuICBfcG9ydDogbnVtYmVyO1xuICBfdmVyc2lvbjogc3RyaW5nO1xuICBfc2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrQ29uZmlnczogQXJyYXk8c3RyaW5nPjtcbiAgX3NlcnZpY2VXaXRoU2VydmljZUZyYW1ld29ya0NvbmZpZ3M6IEFycmF5PGFueT47XG4gIF9yZXNwb25zZXM6IHtbdGltZUJpbjogc3RyaW5nXTogYW55fTtcbiAgX2Vycm9yczogQXJyYXk8YW55PjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBOdWNsaWRlU2VydmVyT3B0aW9ucykge1xuICAgIHZhciB7c2VydmVyS2V5LCBzZXJ2ZXJDZXJ0aWZpY2F0ZSwgcG9ydCwgY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZSwgdHJhY2tFdmVudExvb3B9ID0gb3B0aW9ucztcblxuICAgIHRoaXMuX2FwcCA9IGNvbm5lY3QoKTtcbiAgICB0aGlzLl9hdHRhY2hVdGlsSGFuZGxlcnModGhpcy5fYXBwKTtcbiAgICBpZiAoc2VydmVyS2V5ICYmIHNlcnZlckNlcnRpZmljYXRlICYmIGNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGUpIHtcbiAgICAgIHZhciB3ZWJTZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICBrZXk6IHNlcnZlcktleSxcbiAgICAgICAgY2VydDogc2VydmVyQ2VydGlmaWNhdGUsXG4gICAgICAgIGNhOiBjZXJ0aWZpY2F0ZUF1dGhvcml0eUNlcnRpZmljYXRlLFxuICAgICAgICByZXF1ZXN0Q2VydDogdHJ1ZSxcbiAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHdlYlNlcnZlck9wdGlvbnMsIHRoaXMuX2FwcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKHRoaXMuX2FwcCk7XG4gICAgfVxuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuXG4gICAgdGhpcy5fd2ViU29ja2V0U2VydmVyID0gdGhpcy5fY3JlYXRlV2ViU29ja2V0U2VydmVyKCk7XG4gICAgdGhpcy5fY2xpZW50cyA9IHt9O1xuICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBldmVudGJ1cyA9IHRoaXMuZXZlbnRidXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLy8gQW55IHNlcnZpY2UgY2FuIHVzZSB0aGUgZXZlbnRidXMgQVBJIGxpa2U6IGB0aGlzLnB1Ymxpc2goZXZlbnROYW1lLCB7fSlgLlxuICAgIHRoaXMucHVibGlzaCA9IHRoaXMuYnJvYWRjYXN0ID0gZXZlbnRidXMuZW1pdC5iaW5kKGV2ZW50YnVzKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IGV2ZW50YnVzLm9uLmJpbmQoZXZlbnRidXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlT25jZSA9IGV2ZW50YnVzLm9uY2UuYmluZChldmVudGJ1cyk7XG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGV2ZW50YnVzLnJlbW92ZUxpc3RlbmVyLmJpbmQoZXZlbnRidXMpO1xuICAgIHRoaXMuX2V2ZW50RW1pdHRlcnMgPSB7fTtcblxuICAgIHRoaXMuX3NldHVwU2VydmljZXMoKTtcblxuICAgIGlmICh0cmFja0V2ZW50TG9vcCkge1xuICAgICAgYmxvY2tlZCgobXM6IG51bWJlcikgPT4ge1xuICAgICAgICBsb2dnZXIuaW5mbygnTnVjbGlkZVNlcnZlciBldmVudCBsb29wIGJsb2NrZWQgZm9yICcgKyBtcyArICdtcycpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2F0dGFjaFV0aWxIYW5kbGVycyhhcHApIHtcbiAgICAvLyBBZGQgc3BlY2lmaWMgbWV0aG9kIGhhbmRsZXJzLlxuICAgIFsnZ2V0JywgJ3Bvc3QnLCAnZGVsZXRlJywgJ3B1dCddLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIHRoaXMuX2FwcFttZXRob2ROYW1lXSA9ICh1cmksIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5fYXBwLnVzZSh1cmksIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpICE9PSBtZXRob2ROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXNuJ3QgbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVXZWJTb2NrZXRTZXJ2ZXIoKTogV2ViU29ja2V0U2VydmVyIHtcbiAgICB2YXIgd2ViU29ja2V0U2VydmVyID0gbmV3IFdlYlNvY2tldFNlcnZlcih7c2VydmVyOiB0aGlzLl93ZWJTZXJ2ZXJ9KTtcbiAgICB3ZWJTb2NrZXRTZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCAoc29ja2V0KSA9PiB0aGlzLl9vbkNvbm5lY3Rpb24oc29ja2V0KSk7XG4gICAgd2ViU29ja2V0U2VydmVyLm9uKCdlcnJvcicsIChlcnJvcikgPT4gbG9nZ2VyLmVycm9yKCdXZWJTb2NrZXRTZXJ2ZXIgRXJyb3I6JywgZXJyb3IpKTtcbiAgICByZXR1cm4gd2ViU29ja2V0U2VydmVyO1xuICB9XG5cbiAgX2dldFNlcnZpY2VGcmFtZXdvcmtTZXJ2aWNlQW5kUmVnaXN0ZXJFdmVudEhhbmRsZShcbiAgICAgIHNlcnZpY2VDb25maWc6IFNlcnZpY2VDb25maWcsIHNlcnZpY2VPcHRpb25zOiBhbnkpOiBhbnkge1xuICAgIHZhciBsb2NhbFNlcnZpY2VJbnN0YW5jZSA9IGdldFNlcnZpY2Uoc2VydmljZUNvbmZpZy5uYW1lLCBzZXJ2aWNlT3B0aW9ucywgc2VydmljZUNvbmZpZy5pbXBsZW1lbnRhdGlvbik7XG4gICAgaWYgKGxvY2FsU2VydmljZUluc3RhbmNlW0VWRU5UX0hBTkRMRV9SRUdJU1RFUkVEXSkge1xuICAgICAgcmV0dXJuIGxvY2FsU2VydmljZUluc3RhbmNlO1xuICAgIH1cblxuICAgIHZhciBzZXJ2aWNlQXBpID0gcGFyc2VTZXJ2aWNlQXBpU3luYyhzZXJ2aWNlQ29uZmlnLmRlZmluaXRpb24sIHNlcnZpY2VDb25maWcubmFtZSk7XG5cbiAgICBzZXJ2aWNlQXBpLmV2ZW50TWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIGxvY2FsU2VydmljZUluc3RhbmNlW21ldGhvZE5hbWVdLmNhbGwobG9jYWxTZXJ2aWNlSW5zdGFuY2UsICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBnZXRSZW1vdGVFdmVudE5hbWUoc2VydmljZUNvbmZpZy5uYW1lLCBtZXRob2ROYW1lLCBzZXJ2aWNlT3B0aW9ucyk7XG4gICAgICAgICh0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuZ2V0KGV2ZW50TmFtZSkgfHwgW10pLmZvckVhY2goY2xpZW50SWQgPT4ge1xuICAgICAgICAgIHZhciBjbGllbnQgPSB0aGlzLl9jbGllbnRzW2NsaWVudElkXTtcblxuICAgICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignQ2xpZW50IHdpdGggY2xpZW50SWQ6ICVzIG5vdCBmb3VuZCEnLCBjbGllbnRJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2VuZFNvY2tldE1lc3NhZ2UoY2xpZW50LCB7XG4gICAgICAgICAgICBjaGFubmVsOiBTRVJWSUNFX0ZSQU1FV09SS19FVkVOVF9DSEFOTkVMLFxuICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobG9jYWxTZXJ2aWNlSW5zdGFuY2UsIEVWRU5UX0hBTkRMRV9SRUdJU1RFUkVELCB7dmFsdWU6IHRydWV9KTtcblxuICAgIHJldHVybiBsb2NhbFNlcnZpY2VJbnN0YW5jZTtcbiAgfVxuXG4gIF9yZWdpc3RlclNlcnZpY2VXaXRoU2VydmljZUZyYW1ld29yayhzZXJ2aWNlQ29uZmlnOiBTZXJ2aWNlQ29uZmlnKTogdm9pZCB7XG4gICAgdmFyIHNlcnZpY2VBcGkgPSBwYXJzZVNlcnZpY2VBcGlTeW5jKHNlcnZpY2VDb25maWcuZGVmaW5pdGlvbiwgc2VydmljZUNvbmZpZy5uYW1lKTtcblxuICAgIHNlcnZpY2VBcGkucnBjTWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyU2VydmljZShcbiAgICAgICAgJy8nICsgc2VydmljZUFwaS5jbGFzc05hbWUgKyAnLycgKyBtZXRob2ROYW1lLFxuXG4gICAgICAgIC8vIFRha2Ugc2VydmljZU9wdGlvbnMgYXMgZmlyc3QgYXJndW1lbnQgZm9yIHNlcnZpY2VGcmFtZXdvcmsgc2VydmljZS5cbiAgICAgICAgLy8gVE9ETyhjaGVuc2hlbikgc2VwZXJhdGUgdGhlIGxvZ2ljIG9mIHNlcnZpY2UgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgIChzZXJ2aWNlT3B0aW9ucywgLi4uYXJncykgPT4ge1xuICAgICAgICAgIHZhciBsb2NhbFNlcnZpY2VJbnN0YW5jZSA9IHRoaXMuX2dldFNlcnZpY2VGcmFtZXdvcmtTZXJ2aWNlQW5kUmVnaXN0ZXJFdmVudEhhbmRsZShcbiAgICAgICAgICAgICAgc2VydmljZUNvbmZpZywgc2VydmljZU9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBsb2NhbFNlcnZpY2VJbnN0YW5jZVttZXRob2ROYW1lXS5hcHBseShsb2NhbFNlcnZpY2VJbnN0YW5jZSwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgICdwb3N0JyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIF9yZWdpc3RlclNlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29yayhzZXJ2aWNlRmlsZVBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHZhciB7dXJsSGFuZGxlcnMsIHNlcnZpY2VzLCBpbml0aWFsaXplfSA9IHJlcXVpcmUoc2VydmljZUZpbGVQYXRoKTtcbiAgICBmb3IgKHZhciBzZXJ2aWNlTmFtZSBpbiBzZXJ2aWNlcykge1xuICAgICAgdmFyIHNlcnZpY2VDb25maWcgPSBzZXJ2aWNlc1tzZXJ2aWNlTmFtZV07XG4gICAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2Uoc2VydmljZU5hbWUsIHNlcnZpY2VDb25maWcuaGFuZGxlciwgc2VydmljZUNvbmZpZy5tZXRob2QsIHNlcnZpY2VDb25maWcudGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHVybEhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciB1cmwgaW4gdXJsSGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJDb25maWcgPSB1cmxIYW5kbGVyc1t1cmxdO1xuICAgICAgICB0aGlzLl9hdHRhY2hVcmxIYW5kbGVyKHVybCwgaGFuZGxlckNvbmZpZy5oYW5kbGVyLCBoYW5kbGVyQ29uZmlnLm1ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgIGluaXRpYWxpemUodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwU2VydmljZXMoKSB7XG4gICAgLy8gTGF6eSByZXF1aXJlIHRoZXNlIGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNvdWxkIHNweU9uIHRoZW0gd2hpbGUgdGVzdGluZyBpblxuICAgIC8vIFNlcnZpY2VJbnRlZ3JhdGlvblRlc3RIZWxwZXIuXG4gICAgdmFyIHtsb2FkQ29uZmlnc09mU2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrLFxuICAgICAgbG9hZENvbmZpZ3NPZlNlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29ya30gPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHRoaXMuX3NlcnZpY2VSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuX3NldHVwU3RhdHNIYW5kbGVyKCk7XG4gICAgdGhpcy5fc2V0dXBWZXJzaW9uSGFuZGxlcigpO1xuICAgIHRoaXMuX3NldHVwU2h1dGRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5fc2V0dXBTdWJzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgdGhpcy5fc2V0dXBTZXJ2aWNlRnJhbWV3b3JrU3Vic2NyaXB0aW9uSGFuZGxlcigpO1xuICAgIHRoaXMuX3NlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29ya0NvbmZpZ3MgPSBsb2FkQ29uZmlnc09mU2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrKCk7XG4gICAgdGhpcy5fc2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrQ29uZmlncyA9IGxvYWRDb25maWdzT2ZTZXJ2aWNlV2l0aFNlcnZpY2VGcmFtZXdvcmsoKTtcblxuICAgIHRoaXMuX3NlcnZpY2VXaXRob3V0U2VydmljZUZyYW1ld29ya0NvbmZpZ3MuZm9yRWFjaCgoY29uZmlnOiBzdHJpbmcpID0+IHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyU2VydmljZVdpdGhvdXRTZXJ2aWNlRnJhbWV3b3JrKGNvbmZpZyk7XG4gICAgICBsb2dnZXIuaW5mbyhgUmVnaXN0ZXJlZCBzZXJ2aWNlICR7Y29uZmlnfSB3aXRob3V0IFNlcnZpY2VGcmFtZXdvcmsuYCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXJ2aWNlV2l0aFNlcnZpY2VGcmFtZXdvcmtDb25maWdzLmZvckVhY2goY29uZmlnID0+IHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyU2VydmljZVdpdGhTZXJ2aWNlRnJhbWV3b3JrKGNvbmZpZyk7XG4gICAgICBsb2dnZXIuaW5mbyhgUmVnaXN0ZXJlZCBzZXJ2aWNlICR7Y29uZmlnLm5hbWV9IHdpdGggU2VydmljZUZyYW1ld29yay5gKTtcbiAgICB9KTtcblxuICAgIC8vIFNldHVwIGVycm9yIGhhbmRsZXIuXG4gICAgdGhpcy5fYXBwLnVzZSgoZXJyb3IsIHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEpzb25SZXNwb25zZShyZXNwb25zZSwge2NvZGU6IGVycm9yLmNvZGUsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2V9LCA1MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3NldHVwU3RhdHNIYW5kbGVyKCkge1xuICAgIHRoaXMuX2NsZWFyU3RhdHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2UoXG4gICAgICAnL3NlcnZlci9nZXRTdGF0cycsXG4gICAgICAoKSA9PiAoe1xuICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgcmVzcG9uc2VzOiB0aGlzLl9yZXNwb25zZXMsXG4gICAgICB9KSxcbiAgICAgICdnZXQnLFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2UoJy9zZXJ2ZXIvY2xlYXJTdGF0cycsIHRoaXMuX2NsZWFyU3RhdHMuYmluZCh0aGlzKSwgJ3Bvc3QnLCBmYWxzZSk7XG4gIH1cblxuICBfc2V0dXBWZXJzaW9uSGFuZGxlcigpIHtcbiAgICB0aGlzLl92ZXJzaW9uID0gZ2V0VmVyc2lvbigpLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlKCcvc2VydmVyL3ZlcnNpb24nLCAoKSA9PiB0aGlzLl92ZXJzaW9uLCAncG9zdCcsIHRydWUpO1xuICB9XG5cbiAgX3NldHVwU2h1dGRvd25IYW5kbGVyKCkge1xuICAgIHZhciBzaHV0ZG93blNlcnZlciA9ICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdTaHV0dGluZyBkb3duIHRoZSBzZXJ2ZXInKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBzaHV0dGluZyBkb3duLCBidXQgcHJvY2VlZGluZyBhbnl3YXk6JywgZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2UoJy9zZXJ2ZXIvc2h1dGRvd24nLCAoKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbygnU2VydmVyIHJlY2VpdmVkIGEgc2h1dGRvd24gcmVxdWVzdCAtIHRlcm1pbmF0aW5nIScpO1xuICAgICAgLy8gU2h1dGRvd24gYWZ0ZXIgdGltZW91dCB0byBnaXZlIGEgY2hhbmNlIHRvIHJlcGx5IHN1Y2Nlc3MgdG8gdGhlIHNodXRkb3duIHJlcXVlc3QuXG4gICAgICBzZXRUaW1lb3V0KHNodXRkb3duU2VydmVyLCBTRVJWRVJfU0hVVERPV05fVElNRU9VVF9NUyk7XG4gICAgfSwgJ3Bvc3QnKTtcbiAgfVxuXG4gIF9zZXR1cFN1YnNjcmlwdGlvbkhhbmRsZXIoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlKCcvZXZlbnRidXMvc3Vic2NyaWJlJywgKGNsaWVudElkOiBzdHJpbmcsIGNoYW5uZWw6IHN0cmluZywgb3B0aW9uczogYW55KSA9PiB7XG4gICAgICB2YXIgY2xpZW50ID0gdGhpcy5fY2xpZW50c1tjbGllbnRJZF07XG4gICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdDbGllbnQgd2l0aCBjbGllbnRJZDogJXMgbm90IGZvdW5kIScsIGNsaWVudElkKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50LnN1YnNjcmlwdGlvbnNbY2hhbm5lbF0pIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci53YXJuKCdDbGllbnQgJXMgYWxyZWFkeSBzdWJzY3JpYmVkIHRvIGNoYW5uZWw6ICVzJywgY2xpZW50SWQsIGNoYW5uZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN1YnNjaWJlSGFuZGxlciA9IGNsaWVudC5zdWJzY3JpcHRpb25zW2NoYW5uZWxdID0gKGV2ZW50KSA9PlxuICAgICAgICAgICAgdGhpcy5fc2VuZFNvY2tldE1lc3NhZ2UoY2xpZW50LCB7Y2hhbm5lbCwgZXZlbnR9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoY2hhbm5lbCwgc3Vic2NpYmVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmV2ZW50RW1pdHRlcklkKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVFdmVudEVtaXR0ZXIob3B0aW9ucy5ldmVudEVtaXR0ZXJJZCwgY2hhbm5lbCwgb3B0aW9ucy5ldmVudE5hbWVzKTtcbiAgICAgIH1cbiAgICB9LCAncG9zdCcpO1xuICB9XG5cbiAgX3NldHVwU2VydmljZUZyYW1ld29ya1N1YnNjcmlwdGlvbkhhbmRsZXIoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJTZXJ2aWNlKCcvc2VydmljZUZyYW1ld29yay9zdWJzY3JpYmVFdmVudCcsIChzZXJ2aWNlT3B0aW9uczogYW55LCBjbGllbnRJZDogc3RyaW5nLCBzZXJ2aWNlTmFtZTogc3RyaW5nLCBtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXJ2aWNlIGluc3RhbmNlIGFuZCByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlLlxuICAgICAgdmFyIFtzZXJ2aWNlQ29uZmlnXSA9IHRoaXMuX3NlcnZpY2VXaXRoU2VydmljZUZyYW1ld29ya0NvbmZpZ3MuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcubmFtZSA9PT0gc2VydmljZU5hbWUpO1xuICAgICAgdGhpcy5fZ2V0U2VydmljZUZyYW1ld29ya1NlcnZpY2VBbmRSZWdpc3RlckV2ZW50SGFuZGxlKHNlcnZpY2VDb25maWcsIHNlcnZpY2VPcHRpb25zKTtcblxuICAgICAgdmFyIGV2ZW50TmFtZSA9IGdldFJlbW90ZUV2ZW50TmFtZShzZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSwgc2VydmljZU9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuc2V0KFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICh0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuZ2V0KGV2ZW50TmFtZSkgfHwgbmV3IFNldCgpKS5hZGQoY2xpZW50SWQpLFxuICAgICAgKTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKGAke2NsaWVudElkfSBzdWJzY3JpYmVkIHRvICR7ZXZlbnROYW1lfWApO1xuICAgIH0sICdwb3N0Jyk7XG5cbiAgICB0aGlzLl9yZWdpc3RlclNlcnZpY2UoJy9zZXJ2aWNlRnJhbWV3b3JrL3Vuc3Vic2NyaWJlRXZlbnQnLCAoc2VydmljZU9wdGlvbnM6IGFueSwgY2xpZW50SWQ6IHN0cmluZywgc2VydmljZU5hbWU6IHN0cmluZywgbWV0aG9kTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gZ2V0UmVtb3RlRXZlbnROYW1lKHNlcnZpY2VOYW1lLCBtZXRob2ROYW1lLCBzZXJ2aWNlT3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5nZXQoZXZlbnROYW1lKS5kZWxldGUoY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmRlYnVnKGAke2NsaWVudElkfSB1bnN1YnNjcmliZWQgdG8gJHtldmVudE5hbWV9YCk7XG4gICAgfSwgJ3Bvc3QnKTtcbiAgfVxuXG4gIGNvbm5lY3QoKTogUHJvbWlzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3dlYlNlcnZlci5vbignbGlzdGVuaW5nJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLl93ZWJTZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fd2ViU2VydmVyLmxpc3Rlbih0aGlzLl9wb3J0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgc2VydmljZSB3aXRoIGEgbmFtZSBhbmQgYXJndW1lbnRzLlxuICAgKi9cbiAgY2FsbFNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IFByb21pc2U8YW55PiB7XG4gICAgdmFyIHNlcnZpY2VGdW5jdGlvbiA9IHRoaXMuX3NlcnZpY2VSZWdpc3RyeVtzZXJ2aWNlTmFtZV07XG4gICAgaWYgKCFzZXJ2aWNlRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IEVycm9yKCdObyBzZXJ2aWNlIHJlZ2lzdGVyZWQgd2l0aCBuYW1lOiAnICsgc2VydmljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVjb3JkUmVxdWVzdFN0YXRzKHNlcnZpY2VOYW1lLCBhcmdzLCBzZXJ2aWNlRnVuY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc2VydmljZSByZXF1ZXN0LCByZWNvcmRzIHJlc3BvbnNlIHRpbWUgYW5kIGVycm9yc1xuICAgKi9cbiAgYXN5bmMgX3JlY29yZFJlcXVlc3RTdGF0cyhcbiAgICBzZXJ2aWNlTmFtZTogc3RyaW5nLFxuICAgIGFyZ3M6IEFycmF5PGFueT4sXG4gICAgc2VydmljZUZ1bmN0aW9uOiAoKSA9PiBQcm9taXNlPGFueT4sXG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgdmFyIHJlcXVlc3RTdGFydCA9IERhdGUubm93KCk7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgc2VydmljZUZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICB2YXIgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHJlcXVlc3RTdGFydDtcbiAgICAgIHZhciBiaW4gPSBNYXRoLmZsb29yKHJlc3BvbnNlVGltZSAvIFNUQVRfQklOX1NJWkVfTVMpICogU1RBVF9CSU5fU0laRV9NUztcbiAgICAgIGlmICghdGhpcy5fcmVzcG9uc2VzW2Jpbl0pIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VzW2Jpbl0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3BvbnNlc1tiaW5dLnB1c2goe3NlcnZpY2VOYW1lfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZhciByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gcmVxdWVzdFN0YXJ0O1xuICAgICAgdGhpcy5fZXJyb3JzLnB1c2goe1xuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBzZXJ2aWNlTmFtZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9jbGVhclN0YXRzKCk6IE9iamVjdCB7XG4gICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlcyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHNlcnZpY2UgZnVuY3Rpb24gdG8gYSBzZXJ2aWNlIG5hbWUuXG4gICAqIFRoaXMgYWxsb3dzIHNpbXBsZSBmdXR1cmUgY2FsbHMgb2YgdGhlIHNlcnZpY2UgYnkgbmFtZSBhbmQgYXJndW1lbnRzIG9yIGh0dHAtdHJpZ2dlcmVkIGVuZHBvaW50IGNhbGxzXG4gICAqIHdpdGggYXJndW1lbnRzIHNlcmlhbGl6ZWQgb3ZlciBodHRwLlxuICAgKi9cbiAgX3JlZ2lzdGVyU2VydmljZShcbiAgICAgIHNlcnZpY2VOYW1lOiBzdHJpbmcsXG4gICAgICBzZXJ2aWNlRnVuY3Rpb246ICgpID0+IFByb21pc2U8YW55PixcbiAgICAgIG1ldGhvZDogP3N0cmluZyA9ICdnZXQnLFxuICAgICAgaXNUZXh0UmVzcG9uc2U6ID9ib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX3NlcnZpY2VSZWdpc3RyeVtzZXJ2aWNlTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBzZXJ2aWNlIHdpdGggdGhpcyBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZDonLCBzZXJ2aWNlTmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX3NlcnZpY2VSZWdpc3RyeVtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlRnVuY3Rpb247XG4gICAgdGhpcy5fcmVnaXN0ZXJIdHRwU2VydmljZShzZXJ2aWNlTmFtZSwgbWV0aG9kLCBpc1RleHRSZXNwb25zZSk7XG4gIH1cblxuICBfcmVnaXN0ZXJIdHRwU2VydmljZShzZXJ2aWNlTmFtZTogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgaXNUZXh0UmVzcG9uc2U6ID9ib29sZWFuKSB7XG4gICAgdmFyIGxvd2VyZWRDYXNlTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5fYXBwW2xvd2VyZWRDYXNlTWV0aG9kXShzZXJ2aWNlTmFtZSwgYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsU2VydmljZShzZXJ2aWNlTmFtZSwgZGVzZXJpYWxpemVBcmdzKHJlcXVlc3QudXJsKSk7XG4gICAgICAgIGlmIChpc1RleHRSZXNwb25zZSkge1xuICAgICAgICAgIHNlbmRUZXh0UmVzcG9uc2UocmVzcG9uc2UsIHJlc3VsdCB8fCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VuZEpzb25SZXNwb25zZShyZXNwb25zZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIERlbGVnYXRlIHRvIHRoZSByZWdpc3RlcmVkIGNvbm5lY3QgZXJyb3IgaGFuZGxlci5cbiAgICAgICAgbmV4dChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gZXhwbGljaXQgaHR0cCBjb25uZWN0IGhhbmRsZXIgZm9yIHNvbWUgc2VydmljZXMgdGhhdCBuZWVkIHJlcXVlc3QvcmVzcG9uc2UgcmVsYXRlZCBvcHRpbWl6YXRpb25zLlxuICAgKiBlLmcuIHJlYWRGaWxlIGFuZCB3cml0ZUZpbGUgdXNlcyBpdCB0byBzdHJlYW0gcmVhZGluZyBhbmQgd3JpdGluZyBmaWxlcyAocGVyZiBpbXByb3ZlbWVudCBmb3IgYmlnIGZpbGVzKS5cbiAgICovXG4gIF9hdHRhY2hVcmxIYW5kbGVyKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhhbmRsZXI6IChyZXF1ZXN0OiBodHRwLkluY29taW5nTWVzc2FnZSwgcmVzcG9uc2U6IGh0dHAuT3V0Z29pbmdNZXNzYWdlLCBuZXh0OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkgPT4gdm9pZCxcbiAgICBtZXRob2Q6ID9zdHJpbmcgPSAnZ2V0J1xuICApOiB2b2lkIHtcbiAgICB0aGlzLl9hcHBbbWV0aG9kXSh1cmwsIGhhbmRsZXIpO1xuICB9XG5cbiAgX29uQ29ubmVjdGlvbihzb2NrZXQ6IFdlYlNvY2tldCk6IHZvaWQge1xuICAgIGxvZ2dlci5pbmZvKCdXZWJTb2NrZXQgY29ubmVjdGluZycpO1xuXG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB2YXIgY2xpZW50ID0gbnVsbDtcblxuICAgIHNvY2tldC5vbignZXJyb3InLCAoZSkgPT5cbiAgICAgIGxvZ2dlci5lcnJvcignQ2xpZW50ICMlcyBlcnJvcjogJXMnLCBjbGllbnQgPyBjbGllbnQuaWQgOiAndW5rb3duJywgZS5tZXNzYWdlKSk7XG5cbiAgICBzb2NrZXQub25jZSgnbWVzc2FnZScsIChjbGllbnRJZCkgPT4ge1xuICAgICAgY2xpZW50ID0gdGhpcy5fY2xpZW50c1tjbGllbnRJZF0gPSB0aGlzLl9jbGllbnRzW2NsaWVudElkXSB8fFxuICAgICAgICAgIHtzdWJzY3JpcHRpb25zOiB7fSwgaWQ6IGNsaWVudElkLCBtZXNzYWdlUXVldWU6IFtdfTtcbiAgICAgIC8vIElmIGFuIGV4aXN0aW5nIGNsaWVudCwgd2UgY2xvc2UgaXRzIHNvY2tldCBiZWZvcmUgbGlzdGVuaW5nIHRvIHRoZSBuZXcgc29ja2V0LlxuICAgICAgaWYgKGNsaWVudC5zb2NrZXQpIHtcbiAgICAgICAgY2xpZW50LnNvY2tldC5jbG9zZSgpO1xuICAgICAgICBjbGllbnQuc29ja2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKCdDbGllbnQgIyVzIGNvbm5lY3Rpbmcgd2l0aCBhIG5ldyBzb2NrZXQhJywgY2xpZW50SWQpO1xuICAgICAgY2xpZW50LnNvY2tldCA9IHNvY2tldDtcbiAgICAgIGNsaWVudC5tZXNzYWdlUXVldWUuc3BsaWNlKDApLmZvckVhY2gobWVzc2FnZSA9PiB0aGlzLl9zZW5kU29ja2V0TWVzc2FnZShjbGllbnQsIG1lc3NhZ2UuZGF0YSkpO1xuICAgICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgKG1lc3NhZ2UpID0+IHRoaXMuX29uU29ja2V0TWVzc2FnZShjbGllbnQsIG1lc3NhZ2UpKTtcbiAgICB9KTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50LnNvY2tldCA9PT0gc29ja2V0KSB7XG4gICAgICAgIGNsaWVudC5zb2NrZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oJ0NsaWVudCAjJXMgY2xvc2luZyBhIHNvY2tldCEnLCBjbGllbnQuaWQpO1xuICAgICAgLy8gVE9ETzogZW5hYmxlIHN1YnNjcmlwdGlvbiBjbGVhbnVwIHdoZW4gd2UgaGF2ZSBhIHJvYnVzdCByZWNvbm5lY3Qgc2NlbmFyaW8uXG4gICAgICAvKlxuICAgICAgZm9yICh2YXIgY2hhbm5lbCBpbiBjbGllbnQuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKGNoYW5uZWwsIHN1YnNjcmlwdGlvbnNbY2hhbm5lbF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zLmZvckVhY2godmFsdWUgPT4gdmFsdWUuZGVsZXRlKGNsaWVudC5pZCkpO1xuICAgICAgZGVsZXRlIHRoaXMuX2NsaWVudHNbY2xpZW50LmlkXTtcbiAgICAgICovXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBfb25Tb2NrZXRNZXNzYWdlKGNsaWVudDogU29ja2V0Q2xpZW50LCBtZXNzYWdlOiBhbnkpOiB2b2lkIHtcbiAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICB2YXIge3NlcnZpY2VOYW1lLCBtZXRob2ROYW1lLCBtZXRob2RBcmdzLCBzZXJ2aWNlT3B0aW9ucywgcmVxdWVzdElkfSA9IG1lc3NhZ2U7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsU2VydmljZShcbiAgICAgICAgJy8nICsgc2VydmljZU5hbWUgKyAnLycgKyBtZXRob2ROYW1lLFxuICAgICAgICBbc2VydmljZU9wdGlvbnNdLmNvbmNhdChtZXRob2RBcmdzKSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2FsbCAlcy8lcyB3aXRoIGVycm9yICVvJywgc2VydmljZU5hbWUsIG1ldGhvZE5hbWUsIGUpO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRTb2NrZXRNZXNzYWdlKGNsaWVudCwge1xuICAgICAgY2hhbm5lbDogU0VSVklDRV9GUkFNRVdPUktfUlBDX0NIQU5ORUwsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICByZXN1bHQsXG4gICAgICBlcnJvcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGNvdWxkIGJlIHVzZWQgYnkgc2VydmljZXMgdG8gd3JhcCBhIHN0cmVhbSBvciBhbiBldmVudCBlbWl0dGVyIHRvIGFuIGlkIHRoYXRcbiAgICogYSBjbGllbnQgY2FuIHN1YnNjcmliZSB0byBvbiB0aGUgZXZlbnRidXMuXG4gICAqL1xuICByZWdpc3RlckV2ZW50RW1pdHRlcihldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcik6IG51bWJlciB7XG4gICAgdmFyIGlkID0gKytpZEluY3JlbWVudDtcbiAgICB0aGlzLl9ldmVudEVtaXR0ZXJzW2lkXSA9IGV2ZW50RW1pdHRlcjtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGNvbnN1bWluZyBhbiBldmVudCBlbWl0dGVyIGJ5IGxpc3RlbmluZyBvbiB0aGUgcmVxdWVzdGVkIGV2ZW50IG5hbWVzXG4gICAqIGFuZCBwdWJsaXNoIHRoZW0gb24gdGhlIGV2ZW50YnVzIGZvciBzdWJzY3JpYmVkIGNsaWVudHMgdG8gY29uc3VtZSBhcyBwYXJ0IG9mIHRoaWVyIHNlcnZpY2VzLlxuICAgKi9cbiAgX2NvbnN1bWVFdmVudEVtaXR0ZXIoXG4gICAgICBpZDogbnVtYmVyLFxuICAgICAgY2hhbm5lbDogc3RyaW5nLFxuICAgICAgZXZlbnROYW1lczogQXJyYXk8c3RyaW5nPikge1xuICAgIHZhciBldmVudEVtaXR0ZXIgPSB0aGlzLl9ldmVudEVtaXR0ZXJzW2lkXTtcbiAgICBpZiAoZXZlbnRFbWl0dGVyLmNvbnN1bWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgIC8vIGxpc3RlbiB0byBldmVyeSBldmVudCBhbmQgcHVibGlzaCBpdCBvbiB0aGUgZXZlbnQgYnVzLlxuICAgICAgZXZlbnRFbWl0dGVyLm9uKGV2ZW50TmFtZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdGhpcy5wdWJsaXNoKGNoYW5uZWwsIHtcbiAgICAgICAgICBldmVudEVtaXR0ZXJJZDogaWQsXG4gICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxuICAgICAgICAgIGFyZ3M6IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgbmVlZHMgdG8gYmUganNvbiBzZXJpYWxpemFibGUuXG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGFyZykpIHtcbiAgICAgICAgICAgICAgLy8gZS5nLiBub2RlIHN0cmVhbXMgZW1pdCAnZGF0YScgYnVmZmVycy5cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3RyaW5nLCBudW1iZXIsIG9iamVjdCwgbnVsbCwgYm9vbGVhbiwgLi5ldGMuXG4gICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBldmVudEVtaXR0ZXIuY29uc3VtZWQgPSB0cnVlO1xuICB9XG5cbiAgX3NlbmRTb2NrZXRNZXNzYWdlKGNsaWVudDogU29ja2V0Q2xpZW50LCBkYXRhOiBhbnkpIHtcbiAgICAvLyBXcmFwIHRoZSBkYXRhIGluIGFuIG9iamVjdCwgYmVjYXVzZSBpZiBgZGF0YWAgaXMgYSBwcmltaXRpdmUgZGF0YSB0eXBlLFxuICAgIC8vIGZpbmRpbmcgaXQgaW4gYW4gYXJyYXkgd291bGQgcmV0dXJuIHRoZSBmaXJzdCBtYXRjaGluZyBpdGVtLCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgaW5zZXJ0ZWQgaXRlbS5cbiAgICB2YXIgbWVzc2FnZSA9IHtkYXRhfTtcbiAgICB2YXIge2lkLCBzb2NrZXQsIG1lc3NhZ2VRdWV1ZX0gPSBjbGllbnQ7XG4gICAgbWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSksIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0ZhaWxlZCBzZW5kaW5nIHNvY2tldCBtZXNzYWdlIHRvIGNsaWVudDonLCBpZCwgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWVzc2FnZUluZGV4ID0gbWVzc2FnZVF1ZXVlLmluZGV4T2YobWVzc2FnZSk7XG4gICAgICAgIGlmIChtZXNzYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbWVzc2FnZVF1ZXVlLnNwbGljZShtZXNzYWdlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLl93ZWJTb2NrZXRTZXJ2ZXIuY2xvc2UoKTtcbiAgICB0aGlzLl93ZWJTZXJ2ZXIuY2xvc2UoKTtcbiAgICB0aGlzLl9zZXJ2aWNlV2l0aG91dFNlcnZpY2VGcmFtZXdvcmtDb25maWdzLmZvckVhY2goc2VydmljZV9wYXRoID0+IHtcbiAgICAgIHZhciB7c2h1dGRvd259ID0gcmVxdWlyZShzZXJ2aWNlX3BhdGgpO1xuICAgICAgaWYgKHNodXRkb3duKSB7XG4gICAgICAgIHNodXRkb3duKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTnVjbGlkZVNlcnZlcjtcbiJdfQ==
