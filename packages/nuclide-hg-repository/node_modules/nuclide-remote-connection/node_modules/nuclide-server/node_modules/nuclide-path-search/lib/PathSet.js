
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var INITIAL_CHUNK_SIZE = 200;

/**
 * Value of the `.errorCode` property on the `Error` for a rejected Promise
 * returned by `PathSet.submit()`.
 */
var ERROR_CODE_CANCELED = 21;

// TODO(mikeo): Replace this with nuclide-logging once #6378527 is fixed.
var logger = {
  debug: function debug() {
    // Uncomment for debugging.
    // console.log.apply(console, args);
  }
};

/**
 * A set of paths to iterate over. This set may be extremely large (more than
 * 500,000 items), so processing is performed in chunks as to not lock up the
 * event loop.
 *
 * Because processing is performed in chunks, it is possible that mutations to
 * the set could be interleaved with chunk processing, so special care is
 * taken to ensure that each Processor sees a consistent view of the contents
 * of the set.
 */

var PathSet = (function () {
  function PathSet() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, PathSet);

    // An ordinary JavaScript object is used instead of an ES6 Map or Set
    // because this code may also be run on Node 0.10.x, which would require the
    // use of an ES6 polyfill, which may not be performant enough for an
    // extremely large collection.
    // Each key in this object is a file path; each value is the boolean `true`.
    this._paths = options.paths || {};

    this._initialChunkSize = options.initialChunkSize || INITIAL_CHUNK_SIZE;

    // If non-null, this is an object with `this._paths` in its prototype chain.
    // For this object, and every object in its prototype chain up to, but not
    // including, `this._paths`, each key in this object is a file path while
    // each value is either `true` or `false`.
    //
    // Each link in the prototype chain represents a set of modifications to the
    // members of this PathSet where `true`/`false` corresponds to
    // presence/absence in the PathSet. Because of the way prototypes work in
    // JavaScript, checking for the presence of a path in this PathSet in the
    // context of the aggregate changes can be achieved via:
    //
    //     (this._latestPaths || this._paths)[path] === true
    //
    // Each Processor will operate on a link in the prototype chain. Once a link
    // is created (except for the root, this._paths), it is never modified, so
    // the Processor is guaranteed to see a consistent view of the set from the
    // time it starts processing.
    this._latestPaths = null;

    // This array has the invariant that every element corresponds to a job
    // that is running.
    this._jobs = [];
  }

  // TODO(mbolin): If the list of paths passed to addPaths() and removePaths()
  // is very large, then those methods could block the event loop. Consider
  // dividing things up to do the processing in batches, though that would
  // require changing those methods to be async. If that happens, care must be
  // taken to ensure that all class invariants are maintained. In practice,
  // providing the option to specify this._paths via the constructor might be
  // sufficient because the initial call to addPaths() is likely to require a
  // lot of processing, but subsequent updates are expected to be considerably
  // smaller.

  _createClass(PathSet, [{
    key: 'addPaths',
    value: function addPaths(paths) {
      var _this = this;

      if (this._jobs.length === 0) {
        // No jobs in process: update this._paths directly.
        paths.forEach(function (path) {
          _this._paths[path] = true;
        });
      } else {
        // Otherwise, add a new head to the this._latestPaths chain.
        var proto = this._latestPaths || this._paths;
        var props = {};
        paths.forEach(function (path) {
          props[path] = { value: true, enumerable: true };
        });
        this._latestPaths = Object.freeze(Object.create(proto, props));
      }
    }
  }, {
    key: 'removePaths',
    value: function removePaths(paths) {
      var _this2 = this;

      if (this._jobs.length === 0) {
        // No jobs in process: update this._paths directly.
        paths.forEach(function (path) {
          delete _this2._paths[path];
        });
      } else {
        // Otherwise, add a new head to the this._latestPaths chain.
        var proto = this._latestPaths || this._paths;
        var props = {};
        paths.forEach(function (path) {
          props[path] = { value: false, enumerable: true };
        });
        this._latestPaths = Object.freeze(Object.create(proto, props));
      }
    }

    /**
     * Helper function to iterate over all the elements in this set.
     * Compatible with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach.
     */
  }, {
    key: 'forEach',
    value: function forEach(callback) {
      for (var path in this._paths) {
        callback(path, path, this);
      }
    }

    /**
     * Helper function to obtain a list of all of the paths in this set.
     */
  }, {
    key: 'values',
    value: function values() {
      var values = [];
      for (var path in this._paths) {
        values.push(path);
      }
      return values;
    }

    /**
     * Submits a processor and returns a special `Promise` that has a
     * `cancelJob()` method that can be used to cancel this job, which will reject
     * the `Promise`.
     *
     * If the returned `Promise` is canceled because `cancelJob()` was invoked (as
     * opposed to some sort of internal error), the `errorCode` property of the
     * `Error` will be `PathSet.ERROR_CODE_CANCELED`.
     */
  }, {
    key: 'submit',
    value: function submit(processor) {
      // Because the paths for the job is iterated via for/in, it is imperative
      // that the paths object is not modified while it is being iterated.
      var job = {
        processor: processor,
        paths: this._latestPaths || this._paths,
        canceled: false,
        startTime: Date.now(),
        chunkCount: 0
      };
      this._jobs.push(job);
      var promise = this._runJob(job);
      promise.cancelJob = function () {
        job.canceled = true;
      };
      return promise;
    }
  }, {
    key: '_runJob',
    value: function _runJob(job) {
      var _this3 = this;

      var paths = job.paths;
      var processor = job.processor;

      var count = 0;
      var chunkSize = this._initialChunkSize;

      var doCleanup = function doCleanup(err) {
        logger.debug((err ? 'Canceled ' : '') + 'ProcessorJob for ' + processor + ' ' + ('processed ' + job.chunkCount + ' items in ' + (Date.now() - job.startTime) + 'ms.'));

        // Now that the Promise has been determined, remove the job from the list.
        var index = _this3._jobs.indexOf(job);
        _this3._jobs.splice(index, 1);

        // Clean up the modification history to this PathSet, if appropriate.
        _this3._squashHistory();

        if (err) {
          throw err;
        }
      };

      return new Promise(function (resolve, reject) {
        var generator;
        function* run() {
          for (var path in paths) {
            // Make sure the entry for `path` corresponds to `true`, as the
            // original entry could be shadowed by a nearer property in the
            // prototype chain whose value corresponds to `false`.
            if (paths[path] === true) {
              processor(path);
            }

            ++count;
            if (count === chunkSize) {
              job.chunkCount += chunkSize;
              process.nextTick(function () {
                generator.next();
              });
              yield;

              // Upon resuming, check whether this job has been canceled.
              if (job.canceled) {
                logger.debug('canceling ' + processor);
                var error = Error('canceled ' + processor);
                error.errorCode = ERROR_CODE_CANCELED;
                reject(error);
                return;
              }

              logger.debug('resuming ' + processor);

              // Otherwise, reset the count and process the next chunk.
              count = 0;
              // For each iteration, we double the chunk size under the assumption
              // that the more iterations we have gone through processing this
              // job, the more likely it is that the user is waiting on this job
              // and is not going to preempt it with another job. (Earlier in the
              // iteration cycle, the user is likely still typing,
              // creating/canceling jobs repeatedly.)
              chunkSize *= 2;
            }
          }
          job.chunkCount += count;
          resolve();
        }
        generator = run();
        generator.next();
      }).then(doCleanup, doCleanup);
    }
  }, {
    key: '_squashHistory',
    value: function _squashHistory() {
      var _this4 = this;

      // If the job list is now empty, collapse this._latestPaths, if non-null.
      if (this._latestPaths === null || this._jobs.length !== 0) {
        return;
      }

      var chain = findPrototypeChain(this._paths, this._latestPaths);
      chain.forEach(function (link) {
        for (var path in link) {
          if (link[path] === true) {
            _this4._paths[path] = true;
          } else {
            delete _this4._paths[path];
          }
        }
      });
      this._latestPaths = null;
    }
  }]);

  return PathSet;
})();

PathSet.ERROR_CODE_CANCELED = ERROR_CODE_CANCELED;

/**
 * Given two objects where one is a descendant of the other in the prototype
 * chain, return an array that corresponds to the chain of prototype objects.
 *
 * @return an Array ordered by "distance in the prototype chain from ancestor"
 *     in ascending order. The ancestor argument will not be in the Array.
 */
function findPrototypeChain(ancestor, descendant) {
  var chain = [];
  while (ancestor !== descendant) {
    chain.push(descendant);
    descendant = Object.getPrototypeOf(descendant);
  }
  return chain.reverse();
}

module.exports = PathSet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9QYXRoU2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUF3QlosSUFBSSxrQkFBa0IsR0FBRyxHQUFHLENBQUM7Ozs7OztBQU03QixJQUFJLG1CQUFtQixHQUFHLEVBQUUsQ0FBQzs7O0FBRzdCLElBQUksTUFBTSxHQUFHO0FBQ1gsT0FBSyxFQUFBLGlCQUFVOzs7R0FHZDtDQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7SUFZSSxPQUFPO0FBTUEsV0FOUCxPQUFPLEdBTWU7UUFBZCxPQUFPLHlEQUFHLEVBQUU7OzBCQU5wQixPQUFPOzs7Ozs7O0FBWVQsUUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQzs7QUFFbEMsUUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CeEUsUUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7Ozs7QUFJekIsUUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7R0FDakI7Ozs7Ozs7Ozs7OztlQXRDRyxPQUFPOztXQWtESCxrQkFBQyxLQUFvQixFQUFFOzs7QUFDN0IsVUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTNCLGFBQUssQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFBRSxnQkFBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQUUsQ0FBQyxDQUFDO09BQ3RELE1BQU07O0FBRUwsWUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO0FB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TUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsU0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO0FBQzlCLFNBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDdkIsY0FBVSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7R0FDaEQ7QUFDRCxTQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztDQUN4Qjs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wZW1tMkh1cHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1wYXRoLXNlYXJjaC9saWIvUGF0aFNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnR5cGUgUHJvY2Vzc29yID0gKHBhdGg6IHN0cmluZykgPT4gdm9pZDtcblxudHlwZSBQcm9jZXNzb3JKb2IgPSB7XG4gIHByb2Nlc3NvcjogUHJvY2Vzc29yO1xuICBwYXRoczoge1trZXk6IHN0cmluZ106IGJvb2xlYW59O1xuICBjYW5jZWxlZDogYm9vbGVhbjtcbiAgc3RhcnRUaW1lOiBudW1iZXI7XG4gIGNodW5rU2l6ZTogbnVtYmVyO1xuICBjaHVua0NvdW50OiBudW1iZXI7XG59O1xuXG50eXBlIEZvckVhY2hDYWxsYmFjayA9IChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgc2V0OiBQYXRoU2V0KSA9PiB2b2lkO1xuXG52YXIgSU5JVElBTF9DSFVOS19TSVpFID0gMjAwO1xuXG4vKipcbiAqIFZhbHVlIG9mIHRoZSBgLmVycm9yQ29kZWAgcHJvcGVydHkgb24gdGhlIGBFcnJvcmAgZm9yIGEgcmVqZWN0ZWQgUHJvbWlzZVxuICogcmV0dXJuZWQgYnkgYFBhdGhTZXQuc3VibWl0KClgLlxuICovXG52YXIgRVJST1JfQ09ERV9DQU5DRUxFRCA9IDIxO1xuXG4vLyBUT0RPKG1pa2VvKTogUmVwbGFjZSB0aGlzIHdpdGggbnVjbGlkZS1sb2dnaW5nIG9uY2UgIzYzNzg1MjcgaXMgZml4ZWQuXG52YXIgbG9nZ2VyID0ge1xuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgLy8gVW5jb21tZW50IGZvciBkZWJ1Z2dpbmcuXG4gICAgLy8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEEgc2V0IG9mIHBhdGhzIHRvIGl0ZXJhdGUgb3Zlci4gVGhpcyBzZXQgbWF5IGJlIGV4dHJlbWVseSBsYXJnZSAobW9yZSB0aGFuXG4gKiA1MDAsMDAwIGl0ZW1zKSwgc28gcHJvY2Vzc2luZyBpcyBwZXJmb3JtZWQgaW4gY2h1bmtzIGFzIHRvIG5vdCBsb2NrIHVwIHRoZVxuICogZXZlbnQgbG9vcC5cbiAqXG4gKiBCZWNhdXNlIHByb2Nlc3NpbmcgaXMgcGVyZm9ybWVkIGluIGNodW5rcywgaXQgaXMgcG9zc2libGUgdGhhdCBtdXRhdGlvbnMgdG9cbiAqIHRoZSBzZXQgY291bGQgYmUgaW50ZXJsZWF2ZWQgd2l0aCBjaHVuayBwcm9jZXNzaW5nLCBzbyBzcGVjaWFsIGNhcmUgaXNcbiAqIHRha2VuIHRvIGVuc3VyZSB0aGF0IGVhY2ggUHJvY2Vzc29yIHNlZXMgYSBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGNvbnRlbnRzXG4gKiBvZiB0aGUgc2V0LlxuICovXG5jbGFzcyBQYXRoU2V0IHtcbiAgX2luaXRpYWxDaHVua1NpemU6IG51bWJlcjtcbiAgX3BhdGhzOiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn07XG4gIF9sYXRlc3RQYXRoczogP3tba2V5OiBzdHJpbmddOiBib29sZWFufTtcbiAgX2pvYnM6IEFycmF5PFByb2Nlc3NvckpvYj47XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gQW4gb3JkaW5hcnkgSmF2YVNjcmlwdCBvYmplY3QgaXMgdXNlZCBpbnN0ZWFkIG9mIGFuIEVTNiBNYXAgb3IgU2V0XG4gICAgLy8gYmVjYXVzZSB0aGlzIGNvZGUgbWF5IGFsc28gYmUgcnVuIG9uIE5vZGUgMC4xMC54LCB3aGljaCB3b3VsZCByZXF1aXJlIHRoZVxuICAgIC8vIHVzZSBvZiBhbiBFUzYgcG9seWZpbGwsIHdoaWNoIG1heSBub3QgYmUgcGVyZm9ybWFudCBlbm91Z2ggZm9yIGFuXG4gICAgLy8gZXh0cmVtZWx5IGxhcmdlIGNvbGxlY3Rpb24uXG4gICAgLy8gRWFjaCBrZXkgaW4gdGhpcyBvYmplY3QgaXMgYSBmaWxlIHBhdGg7IGVhY2ggdmFsdWUgaXMgdGhlIGJvb2xlYW4gYHRydWVgLlxuICAgIHRoaXMuX3BhdGhzID0gb3B0aW9ucy5wYXRocyB8fCB7fTtcblxuICAgIHRoaXMuX2luaXRpYWxDaHVua1NpemUgPSBvcHRpb25zLmluaXRpYWxDaHVua1NpemUgfHwgSU5JVElBTF9DSFVOS19TSVpFO1xuXG4gICAgLy8gSWYgbm9uLW51bGwsIHRoaXMgaXMgYW4gb2JqZWN0IHdpdGggYHRoaXMuX3BhdGhzYCBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIEZvciB0aGlzIG9iamVjdCwgYW5kIGV2ZXJ5IG9iamVjdCBpbiBpdHMgcHJvdG90eXBlIGNoYWluIHVwIHRvLCBidXQgbm90XG4gICAgLy8gaW5jbHVkaW5nLCBgdGhpcy5fcGF0aHNgLCBlYWNoIGtleSBpbiB0aGlzIG9iamVjdCBpcyBhIGZpbGUgcGF0aCB3aGlsZVxuICAgIC8vIGVhY2ggdmFsdWUgaXMgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgLlxuICAgIC8vXG4gICAgLy8gRWFjaCBsaW5rIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gcmVwcmVzZW50cyBhIHNldCBvZiBtb2RpZmljYXRpb25zIHRvIHRoZVxuICAgIC8vIG1lbWJlcnMgb2YgdGhpcyBQYXRoU2V0IHdoZXJlIGB0cnVlYC9gZmFsc2VgIGNvcnJlc3BvbmRzIHRvXG4gICAgLy8gcHJlc2VuY2UvYWJzZW5jZSBpbiB0aGUgUGF0aFNldC4gQmVjYXVzZSBvZiB0aGUgd2F5IHByb3RvdHlwZXMgd29yayBpblxuICAgIC8vIEphdmFTY3JpcHQsIGNoZWNraW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRoIGluIHRoaXMgUGF0aFNldCBpbiB0aGVcbiAgICAvLyBjb250ZXh0IG9mIHRoZSBhZ2dyZWdhdGUgY2hhbmdlcyBjYW4gYmUgYWNoaWV2ZWQgdmlhOlxuICAgIC8vXG4gICAgLy8gICAgICh0aGlzLl9sYXRlc3RQYXRocyB8fCB0aGlzLl9wYXRocylbcGF0aF0gPT09IHRydWVcbiAgICAvL1xuICAgIC8vIEVhY2ggUHJvY2Vzc29yIHdpbGwgb3BlcmF0ZSBvbiBhIGxpbmsgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi4gT25jZSBhIGxpbmtcbiAgICAvLyBpcyBjcmVhdGVkIChleGNlcHQgZm9yIHRoZSByb290LCB0aGlzLl9wYXRocyksIGl0IGlzIG5ldmVyIG1vZGlmaWVkLCBzb1xuICAgIC8vIHRoZSBQcm9jZXNzb3IgaXMgZ3VhcmFudGVlZCB0byBzZWUgYSBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIHNldCBmcm9tIHRoZVxuICAgIC8vIHRpbWUgaXQgc3RhcnRzIHByb2Nlc3NpbmcuXG4gICAgdGhpcy5fbGF0ZXN0UGF0aHMgPSBudWxsO1xuXG4gICAgLy8gVGhpcyBhcnJheSBoYXMgdGhlIGludmFyaWFudCB0aGF0IGV2ZXJ5IGVsZW1lbnQgY29ycmVzcG9uZHMgdG8gYSBqb2JcbiAgICAvLyB0aGF0IGlzIHJ1bm5pbmcuXG4gICAgdGhpcy5fam9icyA9IFtdO1xuICB9XG5cbiAgLy8gVE9ETyhtYm9saW4pOiBJZiB0aGUgbGlzdCBvZiBwYXRocyBwYXNzZWQgdG8gYWRkUGF0aHMoKSBhbmQgcmVtb3ZlUGF0aHMoKVxuICAvLyBpcyB2ZXJ5IGxhcmdlLCB0aGVuIHRob3NlIG1ldGhvZHMgY291bGQgYmxvY2sgdGhlIGV2ZW50IGxvb3AuIENvbnNpZGVyXG4gIC8vIGRpdmlkaW5nIHRoaW5ncyB1cCB0byBkbyB0aGUgcHJvY2Vzc2luZyBpbiBiYXRjaGVzLCB0aG91Z2ggdGhhdCB3b3VsZFxuICAvLyByZXF1aXJlIGNoYW5naW5nIHRob3NlIG1ldGhvZHMgdG8gYmUgYXN5bmMuIElmIHRoYXQgaGFwcGVucywgY2FyZSBtdXN0IGJlXG4gIC8vIHRha2VuIHRvIGVuc3VyZSB0aGF0IGFsbCBjbGFzcyBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkLiBJbiBwcmFjdGljZSxcbiAgLy8gcHJvdmlkaW5nIHRoZSBvcHRpb24gdG8gc3BlY2lmeSB0aGlzLl9wYXRocyB2aWEgdGhlIGNvbnN0cnVjdG9yIG1pZ2h0IGJlXG4gIC8vIHN1ZmZpY2llbnQgYmVjYXVzZSB0aGUgaW5pdGlhbCBjYWxsIHRvIGFkZFBhdGhzKCkgaXMgbGlrZWx5IHRvIHJlcXVpcmUgYVxuICAvLyBsb3Qgb2YgcHJvY2Vzc2luZywgYnV0IHN1YnNlcXVlbnQgdXBkYXRlcyBhcmUgZXhwZWN0ZWQgdG8gYmUgY29uc2lkZXJhYmx5XG4gIC8vIHNtYWxsZXIuXG5cbiAgYWRkUGF0aHMocGF0aHM6IEFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAodGhpcy5fam9icy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIGpvYnMgaW4gcHJvY2VzczogdXBkYXRlIHRoaXMuX3BhdGhzIGRpcmVjdGx5LlxuICAgICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHsgdGhpcy5fcGF0aHNbcGF0aF0gPSB0cnVlOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgYSBuZXcgaGVhZCB0byB0aGUgdGhpcy5fbGF0ZXN0UGF0aHMgY2hhaW4uXG4gICAgICB2YXIgcHJvdG8gPSB0aGlzLl9sYXRlc3RQYXRocyB8fCB0aGlzLl9wYXRocztcbiAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHsgcHJvcHNbcGF0aF0gPSB7dmFsdWU6IHRydWUsIGVudW1lcmFibGU6IHRydWV9OyB9KTtcbiAgICAgIHRoaXMuX2xhdGVzdFBhdGhzID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKHByb3RvLCBwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVBhdGhzKHBhdGhzOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKHRoaXMuX2pvYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBObyBqb2JzIGluIHByb2Nlc3M6IHVwZGF0ZSB0aGlzLl9wYXRocyBkaXJlY3RseS5cbiAgICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7IGRlbGV0ZSB0aGlzLl9wYXRoc1twYXRoXTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgYWRkIGEgbmV3IGhlYWQgdG8gdGhlIHRoaXMuX2xhdGVzdFBhdGhzIGNoYWluLlxuICAgICAgdmFyIHByb3RvID0gdGhpcy5fbGF0ZXN0UGF0aHMgfHwgdGhpcy5fcGF0aHM7XG4gICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7IHByb3BzW3BhdGhdID0ge3ZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZX07IH0pO1xuICAgICAgdGhpcy5fbGF0ZXN0UGF0aHMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUocHJvdG8sIHByb3BzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGlzIHNldC5cbiAgICogQ29tcGF0aWJsZSB3aXRoIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NldC9mb3JFYWNoLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjazogRm9yRWFjaENhbGxiYWNrKTogdm9pZCB7XG4gICAgZm9yKHZhciBwYXRoIGluIHRoaXMuX3BhdGhzKSB7XG4gICAgICBjYWxsYmFjayhwYXRoLCBwYXRoLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG9idGFpbiBhIGxpc3Qgb2YgYWxsIG9mIHRoZSBwYXRocyBpbiB0aGlzIHNldC5cbiAgICovXG4gIHZhbHVlcygpOiBBcnJheTxzdHJpbmc+IHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yKHZhciBwYXRoIGluIHRoaXMuX3BhdGhzKSB7XG4gICAgICB2YWx1ZXMucHVzaChwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGEgcHJvY2Vzc29yIGFuZCByZXR1cm5zIGEgc3BlY2lhbCBgUHJvbWlzZWAgdGhhdCBoYXMgYVxuICAgKiBgY2FuY2VsSm9iKClgIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGlzIGpvYiwgd2hpY2ggd2lsbCByZWplY3RcbiAgICogdGhlIGBQcm9taXNlYC5cbiAgICpcbiAgICogSWYgdGhlIHJldHVybmVkIGBQcm9taXNlYCBpcyBjYW5jZWxlZCBiZWNhdXNlIGBjYW5jZWxKb2IoKWAgd2FzIGludm9rZWQgKGFzXG4gICAqIG9wcG9zZWQgdG8gc29tZSBzb3J0IG9mIGludGVybmFsIGVycm9yKSwgdGhlIGBlcnJvckNvZGVgIHByb3BlcnR5IG9mIHRoZVxuICAgKiBgRXJyb3JgIHdpbGwgYmUgYFBhdGhTZXQuRVJST1JfQ09ERV9DQU5DRUxFRGAuXG4gICAqL1xuICBzdWJtaXQocHJvY2Vzc29yOiBQcm9jZXNzb3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBCZWNhdXNlIHRoZSBwYXRocyBmb3IgdGhlIGpvYiBpcyBpdGVyYXRlZCB2aWEgZm9yL2luLCBpdCBpcyBpbXBlcmF0aXZlXG4gICAgLy8gdGhhdCB0aGUgcGF0aHMgb2JqZWN0IGlzIG5vdCBtb2RpZmllZCB3aGlsZSBpdCBpcyBiZWluZyBpdGVyYXRlZC5cbiAgICB2YXIgam9iID0ge1xuICAgICAgcHJvY2Vzc29yLFxuICAgICAgcGF0aHM6IHRoaXMuX2xhdGVzdFBhdGhzIHx8IHRoaXMuX3BhdGhzLFxuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgY2h1bmtDb3VudDogMCxcbiAgICB9O1xuICAgIHRoaXMuX2pvYnMucHVzaChqb2IpO1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcnVuSm9iKGpvYik7XG4gICAgcHJvbWlzZS5jYW5jZWxKb2IgPSAoKSA9PiB7XG4gICAgICBqb2IuY2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBfcnVuSm9iKGpvYjogUHJvY2Vzc29ySm9iKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdmFyIHtwYXRocywgcHJvY2Vzc29yfSA9IGpvYjtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBjaHVua1NpemUgPSB0aGlzLl9pbml0aWFsQ2h1bmtTaXplO1xuXG4gICAgdmFyIGRvQ2xlYW51cCA9IChlcnI6ID9FcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIGAke2VyciA/ICdDYW5jZWxlZCAnIDogJyd9UHJvY2Vzc29ySm9iIGZvciAke3Byb2Nlc3Nvcn0gYCArXG4gICAgICAgICAgYHByb2Nlc3NlZCAke2pvYi5jaHVua0NvdW50fSBpdGVtcyBpbiAke0RhdGUubm93KCkgLSBqb2Iuc3RhcnRUaW1lfW1zLmApO1xuXG4gICAgICAvLyBOb3cgdGhhdCB0aGUgUHJvbWlzZSBoYXMgYmVlbiBkZXRlcm1pbmVkLCByZW1vdmUgdGhlIGpvYiBmcm9tIHRoZSBsaXN0LlxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fam9icy5pbmRleE9mKGpvYik7XG4gICAgICB0aGlzLl9qb2JzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBtb2RpZmljYXRpb24gaGlzdG9yeSB0byB0aGlzIFBhdGhTZXQsIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgdGhpcy5fc3F1YXNoSGlzdG9yeSgpO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIGdlbmVyYXRvcjtcbiAgICAgIGZ1bmN0aW9uKiBydW4oKSB7XG4gICAgICAgIGZvciAodmFyIHBhdGggaW4gcGF0aHMpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVudHJ5IGZvciBgcGF0aGAgY29ycmVzcG9uZHMgdG8gYHRydWVgLCBhcyB0aGVcbiAgICAgICAgICAvLyBvcmlnaW5hbCBlbnRyeSBjb3VsZCBiZSBzaGFkb3dlZCBieSBhIG5lYXJlciBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICAvLyBwcm90b3R5cGUgY2hhaW4gd2hvc2UgdmFsdWUgY29ycmVzcG9uZHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICBpZiAocGF0aHNbcGF0aF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcihwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBqb2IuY2h1bmtDb3VudCArPSBjaHVua1NpemU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZDtcblxuICAgICAgICAgICAgLy8gVXBvbiByZXN1bWluZywgY2hlY2sgd2hldGhlciB0aGlzIGpvYiBoYXMgYmVlbiBjYW5jZWxlZC5cbiAgICAgICAgICAgIGlmIChqb2IuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBjYW5jZWxpbmcgJHtwcm9jZXNzb3J9YCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IEVycm9yKGBjYW5jZWxlZCAke3Byb2Nlc3Nvcn1gKTtcbiAgICAgICAgICAgICAgZXJyb3IuZXJyb3JDb2RlID0gRVJST1JfQ09ERV9DQU5DRUxFRDtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYHJlc3VtaW5nICR7cHJvY2Vzc29yfWApO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlc2V0IHRoZSBjb3VudCBhbmQgcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGl0ZXJhdGlvbiwgd2UgZG91YmxlIHRoZSBjaHVuayBzaXplIHVuZGVyIHRoZSBhc3N1bXB0aW9uXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBtb3JlIGl0ZXJhdGlvbnMgd2UgaGF2ZSBnb25lIHRocm91Z2ggcHJvY2Vzc2luZyB0aGlzXG4gICAgICAgICAgICAvLyBqb2IsIHRoZSBtb3JlIGxpa2VseSBpdCBpcyB0aGF0IHRoZSB1c2VyIGlzIHdhaXRpbmcgb24gdGhpcyBqb2JcbiAgICAgICAgICAgIC8vIGFuZCBpcyBub3QgZ29pbmcgdG8gcHJlZW1wdCBpdCB3aXRoIGFub3RoZXIgam9iLiAoRWFybGllciBpbiB0aGVcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBjeWNsZSwgdGhlIHVzZXIgaXMgbGlrZWx5IHN0aWxsIHR5cGluZyxcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nL2NhbmNlbGluZyBqb2JzIHJlcGVhdGVkbHkuKVxuICAgICAgICAgICAgY2h1bmtTaXplICo9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGpvYi5jaHVua0NvdW50ICs9IGNvdW50O1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBnZW5lcmF0b3IgPSBydW4oKTtcbiAgICAgIGdlbmVyYXRvci5uZXh0KCk7XG4gICAgfSkudGhlbihkb0NsZWFudXAsIGRvQ2xlYW51cCk7XG4gIH1cblxuICBfc3F1YXNoSGlzdG9yeSgpIHtcbiAgICAvLyBJZiB0aGUgam9iIGxpc3QgaXMgbm93IGVtcHR5LCBjb2xsYXBzZSB0aGlzLl9sYXRlc3RQYXRocywgaWYgbm9uLW51bGwuXG4gICAgaWYgKHRoaXMuX2xhdGVzdFBhdGhzID09PSBudWxsIHx8IHRoaXMuX2pvYnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gZmluZFByb3RvdHlwZUNoYWluKHRoaXMuX3BhdGhzLCB0aGlzLl9sYXRlc3RQYXRocyk7XG4gICAgY2hhaW4uZm9yRWFjaChsaW5rID0+IHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbGluaykge1xuICAgICAgICBpZiAobGlua1twYXRoXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX3BhdGhzW3BhdGhdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcGF0aHNbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9sYXRlc3RQYXRocyA9IG51bGw7XG4gIH1cbn1cblxuUGF0aFNldC5FUlJPUl9DT0RFX0NBTkNFTEVEID0gRVJST1JfQ09ERV9DQU5DRUxFRDtcblxuLyoqXG4gKiBHaXZlbiB0d28gb2JqZWN0cyB3aGVyZSBvbmUgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBvdGhlciBpbiB0aGUgcHJvdG90eXBlXG4gKiBjaGFpbiwgcmV0dXJuIGFuIGFycmF5IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGNoYWluIG9mIHByb3RvdHlwZSBvYmplY3RzLlxuICpcbiAqIEByZXR1cm4gYW4gQXJyYXkgb3JkZXJlZCBieSBcImRpc3RhbmNlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gZnJvbSBhbmNlc3RvclwiXG4gKiAgICAgaW4gYXNjZW5kaW5nIG9yZGVyLiBUaGUgYW5jZXN0b3IgYXJndW1lbnQgd2lsbCBub3QgYmUgaW4gdGhlIEFycmF5LlxuICovXG5mdW5jdGlvbiBmaW5kUHJvdG90eXBlQ2hhaW4oYW5jZXN0b3IsIGRlc2NlbmRhbnQpOiBBcnJheSB7XG4gIHZhciBjaGFpbiA9IFtdO1xuICB3aGlsZSAoYW5jZXN0b3IgIT09IGRlc2NlbmRhbnQpIHtcbiAgICBjaGFpbi5wdXNoKGRlc2NlbmRhbnQpO1xuICAgIGRlc2NlbmRhbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZGVzY2VuZGFudCk7XG4gIH1cbiAgcmV0dXJuIGNoYWluLnJldmVyc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoU2V0O1xuIl19
