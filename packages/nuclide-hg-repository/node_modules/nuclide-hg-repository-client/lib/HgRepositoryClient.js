
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = require('atom');

var CompositeDisposable = _require.CompositeDisposable;
var Emitter = _require.Emitter;
var TextEditor = _require.TextEditor;

var _require$hgConstants = require('nuclide-hg-repository-base').hgConstants;

var StatusCodeId = _require$hgConstants.StatusCodeId;
var StatusCodeIdToNumber = _require$hgConstants.StatusCodeIdToNumber;
var StatusCodeNumber = _require$hgConstants.StatusCodeNumber;
var HgStatusOption = _require$hgConstants.HgStatusOption;

var ensureTrailingSeparator = require('nuclide-commons').paths.ensureTrailingSeparator;

var _require2 = require('nuclide-remote-uri');

var isRemote = _require2.isRemote;

var path = require('path');

var _require3 = require('./utils');

var addAllParentDirectoriesToCache = _require3.addAllParentDirectoriesToCache;
var removeAllParentDirectoriesFromCache = _require3.removeAllParentDirectoriesFromCache;

/**
 *
 * Section: Constants, Type Definitions
 *
 */

var EDITOR_SUBSCRIPTION_NAME = 'hg-repository-editor-subscription';

// TODO (jessicalin) Export these types from hg-constants.js when types can be
// exported.

function filterForOnlyNotIgnored(code) {
  return code !== StatusCodeId.IGNORED;
}

function filterForOnlyIgnored(code) {
  return code === StatusCodeId.IGNORED;
}

function filterForAllStatues() {
  return true;
}

/**
 *
 * Section: HgRepositoryClient
 *
 */

/**
 * HgRepositoryClient runs on the machine that Nuclide/Atom is running on.
 * It is the interface that other Atom packages will use to access Mercurial.
 * It caches data fetched from an HgService.
 * It implements the same interface as GitRepository, (https://atom.io/docs/api/latest/GitRepository)
 * in addition to providing asynchronous methods for some getters.
 */

var HgRepositoryClient = (function () {
  function HgRepositoryClient(repoPath, hgService, options) {
    var _this = this;

    _classCallCheck(this, HgRepositoryClient);

    this._path = repoPath;
    this._workingDirectory = options.workingDirectory;
    this._projectDirectory = options.projectRootDirectory;
    this._originURL = options.originURL;
    this._service = hgService;

    this._emitter = new Emitter();
    // A map from a key (in most cases, a file path), to a related Disposable.
    this._disposables = {};

    this._hgStatusCache = {};
    this._modifiedDirectoryCache = new Map();

    this._hgDiffCache = {};
    this._hgDiffCacheFilesUpdating = new Set();
    this._hgDiffCacheFilesToClear = new Set();
    this._disposables[EDITOR_SUBSCRIPTION_NAME] = atom.workspace.observeTextEditors(function (editor) {
      if (!editor.getPath()) {
        // TODO: observe for when this editor's path changes.
        return;
      }

      if (!_this._isPathRelevant(editor.getPath())) {
        return;
      }

      var filePath = editor.getPath();
      // If this editor has been previously active, we will have already
      // initialized diff info and registered listeners on it.
      if (_this._disposables[filePath]) {
        return;
      }

      // Get initial diff stats for this editor, and refresh this information
      // whenever the content of the editor changes.
      _this._updateDiffInfo(filePath);

      _this._disposables[filePath] = new CompositeDisposable();
      _this._disposables[filePath].add(editor.onDidSave(function (event) {
        _this._updateDiffInfo(event.path);
      }));
      // Remove the file from the diff stats cache when the editor is closed.
      // This isn't strictly necessary, but keeps the cache as small as possible.
      // There are cases where this removal may result in removing information
      // that is still relevant: e.g.
      //   * if the user very quickly closes and reopens a file; or
      //   * if the file is open in multiple editors, and one of those is closed.
      // These are probably edge cases, though, and the information will be
      // refetched the next time the file is edited.
      _this._disposables[filePath].add(editor.onDidDestroy(function () {
        _this._hgDiffCacheFilesToClear.add(filePath);
        _this._disposables[filePath].dispose();
        delete _this._disposables[filePath];
      }));
    });

    // Get updates that tell the HgRepositoryClient when to clear its caches.
    this._compositeDisposable = new CompositeDisposable();
    this._compositeDisposable.add(this._service.onFilesDidChange(this._filesDidChange.bind(this)));
    this._compositeDisposable.add(this._service.onHgIgnoreFileDidChange(this._refreshStatusesOfAllFilesInCache.bind(this)));
    this._compositeDisposable.add(this._service.onHgRepoStateDidChange(this._refreshStatusesOfAllFilesInCache.bind(this)));
    this._compositeDisposable.add(this._service.onHgBookmarkDidChange(this.fetchCurrentBookmark.bind(this)));
  }

  _createClass(HgRepositoryClient, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this._emitter.emit('did-destroy');
      this._emitter.dispose();
      this._emitter = null;
      Object.keys(this._disposables).forEach(function (key) {
        _this2._disposables[key].dispose();
      });
      this._compositeDisposable.dispose();
    }

    /**
     *
     * Section: Event Subscription
     *
     */

  }, {
    key: 'onDidDestroy',
    value: function onDidDestroy(callback) {
      this._emitter.on('did-destroy', callback);
    }
  }, {
    key: 'onDidChangeStatus',
    value: function onDidChangeStatus(callback) {
      return this._emitter.on('did-change-status', callback);
    }
  }, {
    key: 'onDidChangeStatuses',
    value: function onDidChangeStatuses(callback) {
      return this._emitter.on('did-change-statuses', callback);
    }

    /**
     *
     * Section: Repository Details
     *
     */

  }, {
    key: 'getType',
    value: function getType() {
      return 'hg';
    }
  }, {
    key: 'getPath',
    value: function getPath() {
      return this._path;
    }
  }, {
    key: 'getWorkingDirectory',
    value: function getWorkingDirectory() {
      return this._workingDirectory.getPath();
    }

    // @return The path of the root project folder in Atom that this
    // HgRepositoryClient provides information about.
  }, {
    key: 'getProjectDirectory',
    value: function getProjectDirectory() {
      return this._projectDirectory.getPath();
    }

    // TODO This is a stub.
  }, {
    key: 'isProjectAtRoot',
    value: function isProjectAtRoot() {
      return true;
    }
  }, {
    key: 'relativize',
    value: function relativize(filePath) {
      return this._workingDirectory.relativize(filePath);
    }

    // TODO This is a stub.
  }, {
    key: 'hasBranch',
    value: function hasBranch(branch) {
      return false;
    }

    /**
     * @return The current Hg bookmark.
     */
  }, {
    key: 'getShortHead',
    value: function getShortHead(filePath) {
      if (!this._currentBookmark) {
        // Kick off a fetch to get the current bookmark. This is async.
        this.fetchCurrentBookmark();
        return '';
      }
      return this._currentBookmark;
    }

    // TODO This is a stub.
  }, {
    key: 'isSubmodule',
    value: function isSubmodule(path) {
      return false;
    }

    // TODO This is a stub.
  }, {
    key: 'getAheadBehindCount',
    value: function getAheadBehindCount(reference, path) {
      return 0;
    }

    // TODO This is a stub.
  }, {
    key: 'getCachedUpstreamAheadBehindCount',
    value: function getCachedUpstreamAheadBehindCount(path) {
      return {
        ahead: 0,
        behind: 0
      };
    }

    // TODO This is a stub.
  }, {
    key: 'getConfigValue',
    value: function getConfigValue(key, path) {
      return null;
    }
  }, {
    key: 'getOriginURL',
    value: function getOriginURL(path) {
      return this._originURL;
    }

    // TODO This is a stub.
  }, {
    key: 'getUpstreamBranch',
    value: function getUpstreamBranch(path) {
      return null;
    }

    // TODO This is a stub.
  }, {
    key: 'getReferences',
    value: function getReferences(path) {
      return {
        heads: [],
        remotes: [],
        tags: []
      };
    }

    // TODO This is a stub.
  }, {
    key: 'getReferenceTarget',
    value: function getReferenceTarget(reference, path) {
      return null;
    }

    /**
     *
     * Section: Reading Status (parity with GitRepository)
     *
     */

    // TODO (jessicalin) Can we change the API to make this method return a Promise?
    // If not, might need to do a synchronous `hg status` query.
  }, {
    key: 'isPathModified',
    value: function isPathModified(filePath) {
      if (!filePath) {
        return false;
      }
      var cachedPathStatus = this._hgStatusCache[filePath];
      if (!cachedPathStatus) {
        return false;
      } else {
        return this.isStatusModified(StatusCodeIdToNumber[cachedPathStatus]);
      }
    }

    // TODO (jessicalin) Can we change the API to make this method return a Promise?
    // If not, might need to do a synchronous `hg status` query.
  }, {
    key: 'isPathNew',
    value: function isPathNew(filePath) {
      if (!filePath) {
        return false;
      }
      var cachedPathStatus = this._hgStatusCache[filePath];
      if (!cachedPathStatus) {
        return false;
      } else {
        return this.isStatusNew(StatusCodeIdToNumber[cachedPathStatus]);
      }
    }

    // TODO (jessicalin) Can we change the API to make this method return a Promise?
    // If not, this method lies a bit by using cached information.
    // TODO (jessicalin) Make this work for ignored directories.
  }, {
    key: 'isPathIgnored',
    value: function isPathIgnored(filePath) {
      if (!filePath) {
        return false;
      }
      // `hg status -i` does not list the repo (the .hg directory), presumably
      // because the repo does not track itself.
      // We want to represent the fact that it's not part of the tracked contents,
      // so we manually add an exception for it via the _isPathWithinHgRepo check.
      return this._hgStatusCache[filePath] === StatusCodeId.IGNORED || this._isPathWithinHgRepo(filePath);
    }

    /**
     * Checks if the given path is within the repo directory (i.e. `.hg/`).
     */
  }, {
    key: '_isPathWithinHgRepo',
    value: function _isPathWithinHgRepo(filePath) {
      if (!filePath) {
        return false;
      }
      return filePath === this.getPath() || filePath.indexOf(this.getPath() + '/') === 0;
    }

    /**
     * Checks whether a path is relevant to this HgRepositoryClient. A path is
     * defined as 'relevant' if it is within the project directory opened within the repo.
     */
  }, {
    key: '_isPathRelevant',
    value: function _isPathRelevant(filePath) {
      return this._projectDirectory.contains(filePath);
    }

    // For now, this method only reflects the status of "modified" directories.
    // Tracking directory status isn't straightforward, as Hg only tracks files.
    // http://mercurial.selenic.com/wiki/FAQ#FAQ.2FCommonProblems.I_tried_to_check_in_an_empty_directory_and_it_failed.21
    // TODO: Make this method reflect New and Ignored statuses.
  }, {
    key: 'getDirectoryStatus',
    value: function getDirectoryStatus(directoryPath) {
      if (!directoryPath) {
        return StatusCodeNumber.CLEAN;
      }
      var directoryPathWithSeparator = ensureTrailingSeparator(directoryPath);
      if (this._modifiedDirectoryCache.has(directoryPathWithSeparator)) {
        return StatusCodeNumber.MODIFIED;
      }
      return StatusCodeNumber.CLEAN;
    }

    // We don't want to do any synchronous 'hg status' calls. Just use cached values.
  }, {
    key: 'getPathStatus',
    value: function getPathStatus(filePath) {
      return this.getCachedPathStatus(filePath);
    }
  }, {
    key: 'getCachedPathStatus',
    value: function getCachedPathStatus(filePath) {
      if (!filePath) {
        return StatusCodeNumber.CLEAN;
      }
      var cachedStatus = this._hgStatusCache[filePath];
      if (cachedStatus) {
        return StatusCodeIdToNumber[cachedStatus];
      }
      return StatusCodeNumber.CLEAN;
    }
  }, {
    key: 'isStatusModified',
    value: function isStatusModified(status) {
      return status === StatusCodeNumber.MODIFIED || status === StatusCodeNumber.MISSING || status === StatusCodeNumber.REMOVED;
    }
  }, {
    key: 'isStatusNew',
    value: function isStatusNew(status) {
      return status === StatusCodeNumber.ADDED || status === StatusCodeNumber.UNTRACKED;
    }

    /**
     *
     * Section: Reading Hg Status (async methods)
     *
     */

    /**
     * Recommended method to use to get the status of files in this repo.
     * @param paths An array of file paths to get the status for. If a path is not in the
     *   project, it will be ignored.
     * See HgService::getStatuses for more information.
     */
  }, {
    key: 'getStatuses',
    value: _asyncToGenerator(function* (paths, options) {
      var _this3 = this;

      var statusMap = {};
      var isRelavantStatus = this._getPredicateForRelevantStatuses(options);

      // Check the cache.
      // Note: If paths is empty, a full `hg status` will be run, which follows the spec.
      var pathsWithCacheMiss = [];
      paths.forEach(function (filePath) {
        var statusId = _this3._hgStatusCache[filePath];
        if (statusId) {
          if (!isRelavantStatus(statusId)) {
            return;
          }
          statusMap[filePath] = StatusCodeIdToNumber[statusId];
        } else {
          pathsWithCacheMiss.push(filePath);
        }
      });

      // Fetch any uncached statuses.
      if (pathsWithCacheMiss.length) {
        var newStatusInfo = yield this._updateStatuses(pathsWithCacheMiss, options);
        Object.keys(newStatusInfo).forEach(function (filePath) {
          statusMap[filePath] = StatusCodeIdToNumber[newStatusInfo[filePath]];
        });
      }
      return statusMap;
    })

    /**
     * Fetches the statuses for the given file paths, and updates the cache and
     * sends out change events as appropriate.
     * @param filePaths An array of file paths to update the status for. If a path
     *   is not in the project, it will be ignored.
     */
  }, {
    key: '_updateStatuses',
    value: _asyncToGenerator(function* (filePaths, options) {
      var _this4 = this;

      var pathsInRepo = filePaths.filter(function (filePath) {
        return _this4._isPathRelevant(filePath);
      });
      var statusMapPathToStatusId = yield this._service.fetchStatuses(pathsInRepo, options);
      // Until the service framework can do this transformation, we do this manual
      // adjustment for remote paths.
      if (isRemote(this._workingDirectory.getPath())) {
        var remote = this._workingDirectory._remote;
        Object.keys(statusMapPathToStatusId).forEach(function (filePath) {
          var localPath = remote.getPathOfUri(filePath);
          var adjustedFilePath = remote.getUriOfRemotePath(localPath);
          statusMapPathToStatusId[adjustedFilePath] = statusMapPathToStatusId[filePath];
          delete statusMapPathToStatusId[filePath];
        });
      }

      var queriedFiles = new Set(pathsInRepo);
      var statusChangeEvents = [];
      Object.keys(statusMapPathToStatusId).forEach(function (filePath) {
        var newStatusId = statusMapPathToStatusId[filePath];

        var oldStatus = _this4._hgStatusCache[filePath];
        if (oldStatus && oldStatus !== newStatusId || !oldStatus && newStatusId !== StatusCodeId.CLEAN) {
          statusChangeEvents.push({
            path: filePath,
            pathStatus: StatusCodeIdToNumber[newStatusId]
          });
          if (newStatusId === StatusCodeId.CLEAN) {
            // Don't bother keeping 'clean' files in the cache.
            delete _this4._hgStatusCache[filePath];
            _this4._removeAllParentDirectoriesFromCache(filePath);
          } else {
            _this4._hgStatusCache[filePath] = newStatusId;
            if (newStatusId === StatusCodeId.MODIFIED) {
              _this4._addAllParentDirectoriesToCache(filePath);
            }
          }
        }
        queriedFiles['delete'](filePath);
      });

      // If the statuses were fetched for only changed (`hg status`) or
      // ignored ('hg status --ignored`) files, a queried file may not be
      // returned in the response. If it wasn't returned, this means its status
      // may have changed, in which case it should be removed from the hgStatusCache.
      // Note: we don't know the real updated status of the file, so don't send a change event.
      // TODO (jessicalin) Can we make the 'pathStatus' field in the change event optional?
      // Then we can send these events.
      var hasOptions = options && 'hgStatusOption' in options;
      if (hasOptions && options.hgStatusOption === HgStatusOption.ONLY_IGNORED) {
        queriedFiles.forEach(function (filePath) {
          if (_this4._hgStatusCache[filePath] === StatusCodeId.IGNORED) {
            delete _this4._hgStatusCache[filePath];
          }
        });
      } else if (hasOptions && options.hgStatusOption === HgStatusOption.ALL_STATUSES) {
        // No action needs to be taken for the HgStatusOption.ALL_STATUSES case.
      } else {
          queriedFiles.forEach(function (filePath) {
            var cachedStatusId = _this4._hgStatusCache[filePath];
            if (cachedStatusId !== StatusCodeId.IGNORED) {
              delete _this4._hgStatusCache[filePath];
              if (cachedStatusId === StatusCodeId.MODIFIED) {
                _this4._removeAllParentDirectoriesFromCache(filePath);
              }
            }
          });
        }

      // Emit change events only after the cache has been fully updated.
      statusChangeEvents.forEach(function (event) {
        _this4._emitter.emit('did-change-status', event);
      });
      this._emitter.emit('did-change-statuses');

      return statusMapPathToStatusId;
    })
  }, {
    key: '_addAllParentDirectoriesToCache',
    value: function _addAllParentDirectoriesToCache(filePath) {
      addAllParentDirectoriesToCache(this._modifiedDirectoryCache, filePath, this._projectDirectory.getParent().getPath());
    }
  }, {
    key: '_removeAllParentDirectoriesFromCache',
    value: function _removeAllParentDirectoriesFromCache(filePath) {
      removeAllParentDirectoriesFromCache(this._modifiedDirectoryCache, filePath, this._projectDirectory.getParent().getPath());
    }

    /**
     * Helper function for ::getStatuses.
     * Returns a filter for whether or not the given status code should be
     * returned, given the passed-in options for ::getStatuses.
     */
  }, {
    key: '_getPredicateForRelevantStatuses',
    value: function _getPredicateForRelevantStatuses(options) {
      var hasOptions = options && 'hgStatusOption' in options;

      if (hasOptions && options.hgStatusOption === HgStatusOption.ONLY_IGNORED) {
        return filterForOnlyIgnored;
      } else if (hasOptions && options.hgStatusOption === HgStatusOption.ALL_STATUSES) {
        return filterForAllStatues;
      } else {
        return filterForOnlyNotIgnored;
      }
    }

    /**
     *
     * Section: Retrieving Diffs (parity with GitRepository)
     *
     */

  }, {
    key: 'getDiffStats',
    value: function getDiffStats(filePath) {
      var cleanStats = { added: 0, deleted: 0 };
      if (!filePath) {
        return cleanStats;
      }
      var cachedData = this._hgDiffCache[filePath];
      return cachedData ? { added: cachedData.added, deleted: cachedData.deleted } : cleanStats;
    }

    /**
     * Returns an array of LineDiff that describes the diffs between the given
     * file's `HEAD` contents and its current contents.
     * NOTE: this method currently ignores the passed-in text, and instead diffs
     * against the currently saved contents of the file.
     */
    // TODO (jessicalin) Export the LineDiff type (from hg-output-helpers) when
    // types can be exported.
    // TODO (jessicalin) Make this method work with the passed-in `text`. t6391579
  }, {
    key: 'getLineDiffs',
    value: function getLineDiffs(filePath, text) {
      if (!filePath) {
        return [];
      }
      var diffInfo = this._hgDiffCache[filePath];
      return diffInfo ? diffInfo.lineDiffs : [];
    }

    /**
     *
     * Section: Retrieving Diffs (async methods)
     *
     */

    /**
     * Recommended method to use to get the diff stats of files in this repo.
     * @param path The file path to get the status for. If a path is not in the
     *   project, default "clean" stats will be returned.
     */
  }, {
    key: 'getDiffStatsForPath',
    value: _asyncToGenerator(function* (filePath) {
      var cleanStats = { added: 0, deleted: 0 };
      if (!filePath) {
        return cleanStats;
      }

      // Check the cache.
      var cachedDiffInfo = this._hgDiffCache[filePath];
      if (cachedDiffInfo) {
        return { added: cachedDiffInfo.added, deleted: cachedDiffInfo.deleted };
      }

      // Fall back to a fetch.
      var fetchedDiffInfo = yield this._updateDiffInfo(filePath);
      if (fetchedDiffInfo) {
        return { added: fetchedDiffInfo.added, deleted: fetchedDiffInfo.deleted };
      }

      return cleanStats;
    })

    /**
     * Recommended method to use to get the line diffs of files in this repo.
     * @param path The absolute file path to get the line diffs for. If the path \
     *   is not in the project, an empty Array will be returned.
     */
  }, {
    key: 'getLineDiffsForPath',
    value: _asyncToGenerator(function* (filePath) {
      var lineDiffs = [];
      if (!filePath) {
        return lineDiffs;
      }

      // Check the cache.
      var cachedDiffInfo = this._hgDiffCache[filePath];
      if (cachedDiffInfo) {
        return cachedDiffInfo.lineDiffs;
      }

      // Fall back to a fetch.
      var fetchedDiffInfo = yield this._updateDiffInfo(filePath);
      if (fetchedDiffInfo) {
        return fetchedDiffInfo.lineDiffs;
      }

      return lineDiffs;
    })

    /**
     * Updates the diff information for the given path, and updates the cache.
     * This method may return `null` if the path is not in the project; the call to
     * `hg diff` fails; or an update for this path is already in progress.
     */
  }, {
    key: '_updateDiffInfo',
    value: _asyncToGenerator(function* (filePath) {
      var _this5 = this;

      if (!this._isPathRelevant(filePath)) {
        return null;
      }
      // Don't do another update if we are in the middle of running an update
      // for this file.
      if (this._hgDiffCacheFilesUpdating.has(filePath)) {
        return null;
      } else {
        this._hgDiffCacheFilesUpdating.add(filePath);
      }

      var diffInfo = yield this._service.fetchDiffInfo(filePath);
      if (diffInfo) {
        this._hgDiffCache[filePath] = diffInfo;
      }

      // Remove files marked for deletion.
      this._hgDiffCacheFilesToClear.forEach(function (fileToClear) {
        delete _this5._hgDiffCache[fileToClear];
      });
      this._hgDiffCacheFilesToClear.clear();

      // This file can now be updated again.
      this._hgDiffCacheFilesUpdating['delete'](filePath);

      return diffInfo;
    })

    /**
     *
     * Section: Retrieving Bookmark (async methods)
     *
     */
  }, {
    key: 'fetchCurrentBookmark',
    value: _asyncToGenerator(function* () {
      var newlyFetchedBookmark = '';
      try {
        var newlyFetchedBookmark = yield this._service.fetchCurrentBookmark();
      } catch (e) {
        // Suppress the error. There are legitimate times when there may be no
        // current bookmark, such as during a rebase. In this case, we just want
        // to return an empty string if there is no current bookmark.
      }
      if (newlyFetchedBookmark !== this._currentBookmark) {
        this._currentBookmark = newlyFetchedBookmark;
        // The Atom status-bar uses this as a signal to refresh the 'shortHead'.
        // There is currently no dedicated 'shortHeadDidChange' event.
        this._emitter.emit('did-change-statuses');
      }
      return this._currentBookmark;
    })

    /**
     *
     * Section: Checking Out
     *
     */

    // TODO This is a stub.
  }, {
    key: 'checkoutHead',
    value: function checkoutHead(path) {
      return false;
    }

    // TODO This is a stub.
  }, {
    key: 'checkoutReference',
    value: function checkoutReference(reference, create) {
      return false;
    }

    /**
     * This is the async version of what checkoutReference() is meant to do.
     */
  }, {
    key: 'checkoutRevision',
    value: _asyncToGenerator(function* (reference, create) {
      return yield this._service.checkout(reference, create);
    })

    /**
     *
     * Section: HgService subscriptions
     *
     */

    /**
     * Updates the cache in response to any number of (non-.hgignore) files changing.
     * @param update The changed file paths.
     */
  }, {
    key: '_filesDidChange',
    value: function _filesDidChange(changedPaths) {
      var _this6 = this;

      var relevantChangedPaths = changedPaths.filter(this._isPathRelevant.bind(this));
      if (relevantChangedPaths.length) {
        this._updateStatuses(relevantChangedPaths, { hgStatusOption: HgStatusOption.ALL_STATUSES });
        relevantChangedPaths.forEach(function (filePath) {
          if (_this6._hgDiffCache[filePath]) {
            _this6._updateDiffInfo(filePath);
          }
        });
      }
    }
  }, {
    key: '_refreshStatusesOfAllFilesInCache',
    value: function _refreshStatusesOfAllFilesInCache() {
      var _this7 = this;

      var pathsInStatusCache = Object.keys(this._hgStatusCache);
      this._hgStatusCache = {};
      this._modifiedDirectoryCache = new Map();
      if (pathsInStatusCache.length) {
        this._updateStatuses(pathsInStatusCache, { hgStatusOption: HgStatusOption.ALL_STATUSES });
      }

      var pathsInDiffCache = Object.keys(this._hgDiffCache);
      this._hgDiffCache = {};
      if (pathsInDiffCache.length) {
        pathsInDiffCache.forEach(function (filePath) {
          _this7._updateDiffInfo(filePath);
        });
      }
    }

    /**
     *
     * Section: Repository State at Specific Revisions
     *
     */
  }, {
    key: 'fetchFileContentAtRevision',
    value: function fetchFileContentAtRevision(filePath, revision) {
      return this._service.fetchFileContentAtRevision(filePath, revision);
    }
  }, {
    key: 'fetchFilesChangedAtRevision',
    value: function fetchFilesChangedAtRevision(revision) {
      return this._service.fetchFilesChangedAtRevision(revision);
    }
  }, {
    key: 'fetchCommonAncestorOfHeadAndRevision',
    value: function fetchCommonAncestorOfHeadAndRevision(revision) {
      return this._service.fetchCommonAncestorOfHeadAndRevision(revision);
    }
  }, {
    key: 'fetchRevisionNumbersBetweenRevisions',
    value: function fetchRevisionNumbersBetweenRevisions(revisionFrom, revisionTo) {
      return this._service.fetchRevisionNumbersBetweenRevisions(revisionFrom, revisionTo);
    }

    /**
     * A convenience method wrapping `fetchRevisionNumbersBetweenRevisions`.
     */
  }, {
    key: 'fetchRevisionNumbersBetweenRevisionAndHead',
    value: function fetchRevisionNumbersBetweenRevisionAndHead(revision) {
      var expressionForRevisionsBeforeHead = require('nuclide-hg-repository-base').revisions.expressionForRevisionsBeforeHead;

      return this.fetchRevisionNumbersBetweenRevisions(revision, expressionForRevisionsBeforeHead(0));
    }
  }, {
    key: 'getSmartlog',
    value: function getSmartlog(ttyOutput, concise) {
      return this._service.getSmartlog(ttyOutput, concise);
    }
  }]);

  return HgRepositoryClient;
})();

module.exports = HgRepositoryClient;

// Map of directory path to the number of modified files within that directory.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktY2xpZW50L2xpYi9IZ1JlcG9zaXRvcnlDbGllbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O2VBV3FDLE9BQU8sQ0FBQyxNQUFNLENBQUM7O0lBQTNELG1CQUFtQixZQUFuQixtQkFBbUI7SUFBRSxPQUFPLFlBQVAsT0FBTztJQUFFLFVBQVUsWUFBVixVQUFVOzsyQkFFekMsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUMsV0FBVzs7SUFEaEQsWUFBWSx3QkFBWixZQUFZO0lBQUUsb0JBQW9CLHdCQUFwQixvQkFBb0I7SUFBRSxnQkFBZ0Isd0JBQWhCLGdCQUFnQjtJQUFFLGNBQWMsd0JBQWQsY0FBYzs7SUFFcEUsdUJBQXVCLEdBQUksT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsS0FBSyxDQUEzRCx1QkFBdUI7O2dCQUNYLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQzs7SUFBekMsUUFBUSxhQUFSLFFBQVE7O0FBQ2IsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztnQkFDaUQsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7SUFBekYsOEJBQThCLGFBQTlCLDhCQUE4QjtJQUFFLG1DQUFtQyxhQUFuQyxtQ0FBbUM7Ozs7Ozs7O0FBUXhFLElBQUksd0JBQXdCLEdBQUcsbUNBQW1DLENBQUM7Ozs7O0FBYW5FLFNBQVMsdUJBQXVCLENBQUMsSUFBa0IsRUFBVztBQUM1RCxTQUFRLElBQUksS0FBSyxZQUFZLENBQUMsT0FBTyxDQUFFO0NBQ3hDOztBQUVELFNBQVMsb0JBQW9CLENBQUMsSUFBa0IsRUFBVztBQUN6RCxTQUFRLElBQUksS0FBSyxZQUFZLENBQUMsT0FBTyxDQUFFO0NBQ3hDOztBQUVELFNBQVMsbUJBQW1CLEdBQUc7QUFDN0IsU0FBTyxJQUFJLENBQUM7Q0FDYjs7Ozs7Ozs7Ozs7Ozs7OztJQWlCSyxrQkFBa0I7QUFLWCxXQUxQLGtCQUFrQixDQUtWLFFBQWdCLEVBQUUsU0FBb0IsRUFBRSxPQUE0QixFQUFFOzs7MEJBTDlFLGtCQUFrQjs7QUFNcEIsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7QUFDdEIsUUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUNsRCxRQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDO0FBQ3RELFFBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUNwQyxRQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQzs7QUFFMUIsUUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDOztBQUU5QixRQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzs7QUFFdkIsUUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDekIsUUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7O0FBRXpDLFFBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQzNDLFFBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQzFDLFFBQUksQ0FBQyxZQUFZLENBQUMsd0JBQXdCLENBQUMsR0FDdEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFDLE1BQU0sRUFBSztBQUNqRCxVQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxFQUFFOztBQUVyQixlQUFPO09BQ1I7O0FBRUQsVUFBSSxDQUFDLE1BQUssZUFBZSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFO0FBQzNDLGVBQU87T0FDUjs7QUFFRCxVQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7OztBQUdoQyxVQUFJLE1BQUssWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQy9CLGVBQU87T0FDUjs7OztBQUlELFlBQUssZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUUvQixZQUFLLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLG1CQUFtQixFQUFFLENBQUM7QUFDeEQsWUFBSyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBQyxLQUFLLEVBQUs7QUFDMUQsY0FBSyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ2xDLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFTSixZQUFLLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxZQUFNO0FBQ3hELGNBQUssd0JBQXdCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzVDLGNBQUssWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3RDLGVBQU8sTUFBSyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDcEMsQ0FBQyxDQUFDLENBQUM7S0FDTCxDQUFDLEFBQUMsQ0FBQzs7O0FBR0osUUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksbUJBQW1CLEVBQUUsQ0FBQztBQUN0RCxRQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQzFELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUNoQyxDQUFDLENBQUM7QUFDSCxRQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQ2pFLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ2xELENBQUMsQ0FBQztBQUNILFFBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsQ0FDaEUsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDbEQsQ0FBQyxDQUFDO0FBQ0gsUUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUMvRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUNyQyxDQUFDLENBQUM7R0FDSjs7ZUE3RUcsa0JBQWtCOztXQStFZixtQkFBRzs7O0FBQ1IsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDbEMsVUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN4QixVQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNyQixZQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHLEVBQUs7QUFDOUMsZUFBSyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7T0FDbEMsQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ3JDOzs7Ozs7Ozs7O1dBUVcsc0JBQUMsUUFBa0IsRUFBYztBQUMzQyxVQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDM0M7OztXQUVnQiwyQkFDZixRQUFxRSxFQUN6RDtBQUNaLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDeEQ7OztXQUVrQiw2QkFBQyxRQUFrQixFQUFjO0FBQ2xELGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMscUJBQXFCLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDMUQ7Ozs7Ozs7Ozs7V0FTTSxtQkFBVztBQUNoQixhQUFPLElBQUksQ0FBQztLQUNiOzs7V0FFTSxtQkFBVztBQUNoQixhQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7OztXQUVrQiwrQkFBVztBQUM1QixhQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztLQUN6Qzs7Ozs7O1dBSWtCLCtCQUFXO0FBQzVCLGFBQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ3pDOzs7OztXQUdjLDJCQUFZO0FBQ3pCLGFBQU8sSUFBSSxDQUFDO0tBQ2I7OztXQUVTLG9CQUFDLFFBQWdCLEVBQVU7QUFDbkMsYUFBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3BEOzs7OztXQUdRLG1CQUFDLE1BQWMsRUFBRTtBQUN4QixhQUFPLEtBQUssQ0FBQztLQUNkOzs7Ozs7O1dBS1csc0JBQUMsUUFBUSxFQUFVO0FBQzdCLFVBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7O0FBRTFCLFlBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0FBQzVCLGVBQU8sRUFBRSxDQUFDO09BQ1g7QUFDRCxhQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztLQUM5Qjs7Ozs7V0FHVSxxQkFBQyxJQUFJLEVBQUU7QUFDaEIsYUFBTyxLQUFLLENBQUM7S0FDZDs7Ozs7V0FHa0IsNkJBQUMsU0FBUyxFQUFFLElBQUksRUFBRTtBQUNuQyxhQUFPLENBQUMsQ0FBQztLQUNWOzs7OztXQUdnQywyQ0FBQyxJQUFJLEVBQUU7QUFDdEMsYUFBTztBQUNMLGFBQUssRUFBRSxDQUFDO0FBQ1IsY0FBTSxFQUFFLENBQUM7T0FDVixDQUFDO0tBQ0g7Ozs7O1dBR2Esd0JBQUMsR0FBVyxFQUFFLElBQWEsRUFBVztBQUNsRCxhQUFPLElBQUksQ0FBQztLQUNiOzs7V0FFVyxzQkFBQyxJQUFhLEVBQVc7QUFDbkMsYUFBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0tBQ3hCOzs7OztXQUdnQiwyQkFBQyxJQUFhLEVBQVc7QUFDeEMsYUFBTyxJQUFJLENBQUM7S0FDYjs7Ozs7V0FHWSx1QkFBQyxJQUFhLEVBQUU7QUFDM0IsYUFBTztBQUNMLGFBQUssRUFBRSxFQUFFO0FBQ1QsZUFBTyxFQUFFLEVBQUU7QUFDWCxZQUFJLEVBQUUsRUFBRTtPQUNULENBQUM7S0FDSDs7Ozs7V0FHaUIsNEJBQUMsU0FBaUIsRUFBRSxJQUFhLEVBQUU7QUFDbkQsYUFBTyxJQUFJLENBQUM7S0FDYjs7Ozs7Ozs7Ozs7O1dBV2Esd0JBQUMsUUFBZ0IsRUFBVztBQUN4QyxVQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsZUFBTyxLQUFLLENBQUM7T0FDZDtBQUNELFVBQUksZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNyRCxVQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFDckIsZUFBTyxLQUFLLENBQUM7T0FDZCxNQUFNO0FBQ0wsZUFBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO09BQ3RFO0tBQ0Y7Ozs7OztXQUlRLG1CQUFDLFFBQWdCLEVBQVc7QUFDbkMsVUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLGVBQU8sS0FBSyxDQUFDO09BQ2Q7QUFDRCxVQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckQsVUFBSSxDQUFDLGdCQUFnQixFQUFFO0FBQ3JCLGVBQU8sS0FBSyxDQUFDO09BQ2QsTUFBTTtBQUNMLGVBQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7T0FDakU7S0FDRjs7Ozs7OztXQUtZLHVCQUFDLFFBQWdCLEVBQVc7QUFDdkMsVUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLGVBQU8sS0FBSyxDQUFDO09BQ2Q7Ozs7O0FBS0QsYUFBTyxBQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxDQUFDLE9BQU8sSUFDMUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3hDOzs7Ozs7O1dBS2tCLDZCQUFDLFFBQWdCLEVBQVc7QUFDN0MsVUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLGVBQU8sS0FBSyxDQUFDO09BQ2Q7QUFDRCxhQUFPLEFBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBTSxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEFBQUMsQ0FBQztLQUN4Rjs7Ozs7Ozs7V0FNYyx5QkFBQyxRQUFnQixFQUFXO0FBQ3pDLGFBQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNsRDs7Ozs7Ozs7V0FNaUIsNEJBQUMsYUFBc0IsRUFBb0I7QUFDM0QsVUFBSSxDQUFDLGFBQWEsRUFBRTtBQUNsQixlQUFPLGdCQUFnQixDQUFDLEtBQUssQ0FBQztPQUMvQjtBQUNELFVBQUksMEJBQTBCLEdBQUcsdUJBQXVCLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDeEUsVUFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLEVBQUU7QUFDaEUsZUFBTyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7T0FDbEM7QUFDRCxhQUFPLGdCQUFnQixDQUFDLEtBQUssQ0FBQztLQUMvQjs7Ozs7V0FHWSx1QkFBQyxRQUFnQixFQUFvQjtBQUNoRCxhQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUMzQzs7O1dBRWtCLDZCQUFDLFFBQWdCLEVBQW9CO0FBQ3RELFVBQUksQ0FBQyxRQUFRLEVBQUU7QUFDYixlQUFPLGdCQUFnQixDQUFDLEtBQUssQ0FBQztPQUMvQjtBQUNELFVBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakQsVUFBSSxZQUFZLEVBQUU7QUFDaEIsZUFBTyxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztPQUMzQztBQUNELGFBQU8sZ0JBQWdCLENBQUMsS0FBSyxDQUFDO0tBQy9COzs7V0FFZSwwQkFBQyxNQUFjLEVBQVc7QUFDeEMsYUFDRSxNQUFNLEtBQUssZ0JBQWdCLENBQUMsUUFBUSxJQUNwQyxNQUFNLEtBQUssZ0JBQWdCLENBQUMsT0FBTyxJQUNuQyxNQUFNLEtBQUssZ0JBQWdCLENBQUMsT0FBTyxDQUNuQztLQUNIOzs7V0FFVSxxQkFBQyxNQUFjLEVBQVc7QUFDbkMsYUFDRSxNQUFNLEtBQUssZ0JBQWdCLENBQUMsS0FBSyxJQUNqQyxNQUFNLEtBQUssZ0JBQWdCLENBQUMsU0FBUyxDQUNyQztLQUNIOzs7Ozs7Ozs7Ozs7Ozs7OzZCQWVnQixXQUFDLEtBQW9CLEVBQUUsT0FBYSxFQUE4Qzs7O0FBQ2pHLFVBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNuQixVQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7OztBQUl0RSxVQUFJLGtCQUFrQixHQUFHLEVBQUUsQ0FBQztBQUM1QixXQUFLLENBQUMsT0FBTyxDQUFDLFVBQUMsUUFBUSxFQUFLO0FBQzFCLFlBQUksUUFBUSxHQUFHLE9BQUssY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdDLFlBQUksUUFBUSxFQUFFO0FBQ1osY0FBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQy9CLG1CQUFPO1dBQ1I7QUFDRCxtQkFBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3RELE1BQU07QUFDTCw0QkFBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDbkM7T0FDRixDQUFDLENBQUM7OztBQUdILFVBQUksa0JBQWtCLENBQUMsTUFBTSxFQUFFO0FBQzdCLFlBQUksYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUM1RSxjQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUMvQyxtQkFBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQ3JFLENBQUMsQ0FBQztPQUNKO0FBQ0QsYUFBTyxTQUFTLENBQUM7S0FDbEI7Ozs7Ozs7Ozs7NkJBUW9CLFdBQUMsU0FBd0IsRUFBRSxPQUFhLEVBQTBDOzs7QUFDckcsVUFBSSxXQUFXLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUMvQyxlQUFPLE9BQUssZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3ZDLENBQUMsQ0FBQztBQUNILFVBQUksdUJBQXVCLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7OztBQUd0RixVQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRTtBQUM5QyxZQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO0FBQzVDLGNBQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxRQUFRLEVBQUs7QUFDekQsY0FBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM5QyxjQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM1RCxpQ0FBdUIsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzlFLGlCQUFPLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzFDLENBQUMsQ0FBQztPQUNKOztBQUVELFVBQUksWUFBWSxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3hDLFVBQUksa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0FBQzVCLFlBQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxRQUFRLEVBQUs7QUFDekQsWUFBSSxXQUFXLEdBQUcsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRXBELFlBQUksU0FBUyxHQUFHLE9BQUssY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzlDLFlBQUksU0FBUyxJQUFLLFNBQVMsS0FBSyxXQUFXLEFBQUMsSUFDeEMsQ0FBQyxTQUFTLElBQUssV0FBVyxLQUFLLFlBQVksQ0FBQyxLQUFLLEFBQUMsRUFBRTtBQUN0RCw0QkFBa0IsQ0FBQyxJQUFJLENBQUM7QUFDdEIsZ0JBQUksRUFBRSxRQUFRO0FBQ2Qsc0JBQVUsRUFBRSxvQkFBb0IsQ0FBQyxXQUFXLENBQUM7V0FDOUMsQ0FBQyxDQUFDO0FBQ0gsY0FBSSxXQUFXLEtBQUssWUFBWSxDQUFDLEtBQUssRUFBRTs7QUFFdEMsbUJBQU8sT0FBSyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckMsbUJBQUssb0NBQW9DLENBQUMsUUFBUSxDQUFDLENBQUM7V0FDckQsTUFBTTtBQUNMLG1CQUFLLGNBQWMsQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUM7QUFDNUMsZ0JBQUksV0FBVyxLQUFLLFlBQVksQ0FBQyxRQUFRLEVBQUU7QUFDekMscUJBQUssK0JBQStCLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDaEQ7V0FDRjtTQUNGO0FBQ0Qsb0JBQVksVUFBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQy9CLENBQUMsQ0FBQzs7Ozs7Ozs7O0FBU0gsVUFBSSxVQUFVLEdBQUcsT0FBTyxJQUFLLGdCQUFnQixJQUFJLE9BQU8sQUFBQyxDQUFDO0FBQzFELFVBQUksVUFBVSxJQUFLLE9BQU8sQ0FBQyxjQUFjLEtBQUssY0FBYyxDQUFDLFlBQVksQUFBQyxFQUFFO0FBQzFFLG9CQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsUUFBUSxFQUFLO0FBQ2pDLGNBQUksT0FBSyxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUMxRCxtQkFBTyxPQUFLLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztXQUN0QztTQUNGLENBQUMsQ0FBQztPQUNKLE1BQU0sSUFBSSxVQUFVLElBQUssT0FBTyxDQUFDLGNBQWMsS0FBSyxjQUFjLENBQUMsWUFBWSxBQUFDLEVBQUU7O09BRWxGLE1BQU07QUFDTCxzQkFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUNqQyxnQkFBSSxjQUFjLEdBQUcsT0FBSyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbkQsZ0JBQUksY0FBYyxLQUFLLFlBQVksQ0FBQyxPQUFPLEVBQUU7QUFDM0MscUJBQU8sT0FBSyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckMsa0JBQUksY0FBYyxLQUFLLFlBQVksQ0FBQyxRQUFRLEVBQUU7QUFDNUMsdUJBQUssb0NBQW9DLENBQUMsUUFBUSxDQUFDLENBQUM7ZUFDckQ7YUFDRjtXQUNGLENBQUMsQ0FBQztTQUNKOzs7QUFHRCx3QkFBa0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUs7QUFDcEMsZUFBSyxRQUFRLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEtBQUssQ0FBQyxDQUFDO09BQ2hELENBQUMsQ0FBQztBQUNILFVBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7O0FBRTFDLGFBQU8sdUJBQXVCLENBQUM7S0FDaEM7OztXQUU4Qix5Q0FBQyxRQUFnQixFQUFFO0FBQ2hELG9DQUE4QixDQUM1QixJQUFJLENBQUMsdUJBQXVCLEVBQzVCLFFBQVEsRUFDUixJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQzdDLENBQUM7S0FDSDs7O1dBRW1DLDhDQUFDLFFBQWdCLEVBQUU7QUFDckQseUNBQW1DLENBQ2pDLElBQUksQ0FBQyx1QkFBdUIsRUFDNUIsUUFBUSxFQUNSLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FDN0MsQ0FBQztLQUNIOzs7Ozs7Ozs7V0FPK0IsMENBQUMsT0FBYSxFQUFtQztBQUMvRSxVQUFJLFVBQVUsR0FBRyxPQUFPLElBQUssZ0JBQWdCLElBQUksT0FBTyxBQUFDLENBQUM7O0FBRTFELFVBQUksVUFBVSxJQUFLLE9BQU8sQ0FBQyxjQUFjLEtBQUssY0FBYyxDQUFDLFlBQVksQUFBQyxFQUFFO0FBQzFFLGVBQU8sb0JBQW9CLENBQUM7T0FDN0IsTUFBTSxJQUFJLFVBQVUsSUFBSyxPQUFPLENBQUMsY0FBYyxLQUFLLGNBQWMsQ0FBQyxZQUFZLEFBQUMsRUFBRTtBQUNqRixlQUFPLG1CQUFtQixDQUFDO09BQzVCLE1BQU07QUFDTCxlQUFPLHVCQUF1QixDQUFDO09BQ2hDO0tBQ0Y7Ozs7Ozs7Ozs7V0FTVyxzQkFBQyxRQUFnQixFQUFxQztBQUNoRSxVQUFJLFVBQVUsR0FBRyxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBQyxDQUFDO0FBQ3hDLFVBQUksQ0FBQyxRQUFRLEVBQUU7QUFDYixlQUFPLFVBQVUsQ0FBQztPQUNuQjtBQUNELFVBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0MsYUFBTyxVQUFVLEdBQUcsRUFBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLE9BQU8sRUFBQyxHQUN0RSxVQUFVLENBQUM7S0FDaEI7Ozs7Ozs7Ozs7Ozs7V0FXVyxzQkFBQyxRQUFnQixFQUFFLElBQVksRUFBbUI7QUFDNUQsVUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNiLGVBQU8sRUFBRSxDQUFDO09BQ1g7QUFDRCxVQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzNDLGFBQU8sUUFBUSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0tBQzNDOzs7Ozs7Ozs7Ozs7Ozs7NkJBY3dCLFdBQUMsUUFBZ0IsRUFBOEM7QUFDdEYsVUFBSSxVQUFVLEdBQUcsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUMsQ0FBQztBQUN4QyxVQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsZUFBTyxVQUFVLENBQUM7T0FDbkI7OztBQUdELFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakQsVUFBSSxjQUFjLEVBQUU7QUFDbEIsZUFBTyxFQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsT0FBTyxFQUFDLENBQUM7T0FDdkU7OztBQUdELFVBQUksZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMzRCxVQUFJLGVBQWUsRUFBRTtBQUNuQixlQUFPLEVBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxPQUFPLEVBQUMsQ0FBQztPQUN6RTs7QUFFRCxhQUFPLFVBQVUsQ0FBQztLQUNuQjs7Ozs7Ozs7OzZCQU93QixXQUFDLFFBQWdCLEVBQTRCO0FBQ3BFLFVBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNuQixVQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2IsZUFBTyxTQUFTLENBQUM7T0FDbEI7OztBQUdELFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakQsVUFBSSxjQUFjLEVBQUU7QUFDbEIsZUFBTyxjQUFjLENBQUMsU0FBUyxDQUFDO09BQ2pDOzs7QUFHRCxVQUFJLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDM0QsVUFBSSxlQUFlLEVBQUU7QUFDbkIsZUFBTyxlQUFlLENBQUMsU0FBUyxDQUFDO09BQ2xDOztBQUVELGFBQU8sU0FBUyxDQUFDO0tBQ2xCOzs7Ozs7Ozs7NkJBT29CLFdBQUMsUUFBZ0IsRUFBc0I7OztBQUMxRCxVQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsRUFBRTtBQUNuQyxlQUFPLElBQUksQ0FBQztPQUNiOzs7QUFHRCxVQUFJLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDaEQsZUFBTyxJQUFJLENBQUM7T0FDYixNQUFNO0FBQ0wsWUFBSSxDQUFDLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUM5Qzs7QUFFRCxVQUFJLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzNELFVBQUksUUFBUSxFQUFFO0FBQ1osWUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLENBQUM7T0FDeEM7OztBQUdELFVBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxXQUFXLEVBQUs7QUFDckQsZUFBTyxPQUFLLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztPQUN2QyxDQUFDLENBQUM7QUFDSCxVQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLENBQUM7OztBQUd0QyxVQUFJLENBQUMseUJBQXlCLFVBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFaEQsYUFBTyxRQUFRLENBQUM7S0FDakI7Ozs7Ozs7Ozs2QkFReUIsYUFBb0I7QUFDNUMsVUFBSSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7QUFDOUIsVUFBSTtBQUNGLFlBQUksb0JBQW9CLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLG9CQUFvQixFQUFFLENBQUM7T0FDdkUsQ0FBQyxPQUFPLENBQUMsRUFBRTs7OztPQUlYO0FBQ0QsVUFBSSxvQkFBb0IsS0FBSyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFDbEQsWUFBSSxDQUFDLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDOzs7QUFHN0MsWUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztPQUMzQztBQUNELGFBQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0tBQzlCOzs7Ozs7Ozs7OztXQVVXLHNCQUFDLElBQVksRUFBVztBQUNsQyxhQUFPLEtBQUssQ0FBQztLQUNkOzs7OztXQUdnQiwyQkFBQyxTQUFpQixFQUFFLE1BQWUsRUFBVztBQUM3RCxhQUFPLEtBQUssQ0FBQztLQUNkOzs7Ozs7OzZCQUtxQixXQUFDLFNBQWlCLEVBQUUsTUFBZSxFQUFvQjtBQUMzRSxhQUFPLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ3hEOzs7Ozs7Ozs7Ozs7OztXQWFjLHlCQUFDLFlBQTJCLEVBQVE7OztBQUNqRCxVQUFJLG9CQUFvQixHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNoRixVQUFJLG9CQUFvQixDQUFDLE1BQU0sRUFBRTtBQUMvQixZQUFJLENBQUMsZUFBZSxDQUFDLG9CQUFvQixFQUFFLEVBQUMsY0FBYyxFQUFFLGNBQWMsQ0FBQyxZQUFZLEVBQUMsQ0FBQyxDQUFDO0FBQzFGLDRCQUFvQixDQUFDLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUN6QyxjQUFJLE9BQUssWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQy9CLG1CQUFLLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztXQUNoQztTQUNGLENBQUMsQ0FBQztPQUNKO0tBQ0Y7OztXQUVnQyw2Q0FBRzs7O0FBQ2xDLFVBQUksa0JBQWtCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDMUQsVUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDekIsVUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7QUFDekMsVUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEVBQUU7QUFDN0IsWUFBSSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsWUFBWSxFQUFDLENBQUMsQ0FBQztPQUN6Rjs7QUFFRCxVQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3RELFVBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFVBQUksZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQzNCLHdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUNyQyxpQkFBSyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDaEMsQ0FBQyxDQUFDO09BQ0o7S0FDRjs7Ozs7Ozs7O1dBT3lCLG9DQUFDLFFBQW9CLEVBQUUsUUFBZ0IsRUFBb0I7QUFDbkYsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNyRTs7O1dBRTBCLHFDQUFDLFFBQWdCLEVBQWlDO0FBQzNFLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQywyQkFBMkIsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM1RDs7O1dBRW1DLDhDQUFDLFFBQWdCLEVBQW1CO0FBQ3RFLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQ0FBb0MsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNyRTs7O1dBRW1DLDhDQUFDLFlBQW9CLEVBQUUsVUFBa0IsRUFBMEI7QUFDckcsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLG9DQUFvQyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztLQUNyRjs7Ozs7OztXQUt5QyxvREFBQyxRQUFnQixFQUEwQjtVQUM5RSxnQ0FBZ0MsR0FBSSxPQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxTQUFTLENBQW5GLGdDQUFnQzs7QUFDckMsYUFBTyxJQUFJLENBQUMsb0NBQW9DLENBQUMsUUFBUSxFQUFFLGdDQUFnQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDakc7OztXQUVVLHFCQUFDLFNBQWtCLEVBQUUsT0FBZ0IsRUFBbUI7QUFDakUsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDdEQ7OztTQXZ0Qkcsa0JBQWtCOzs7QUEwdEJ4QixNQUFNLENBQUMsT0FBTyxHQUFHLGtCQUFrQixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktY2xpZW50L2xpYi9IZ1JlcG9zaXRvcnlDbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIge0NvbXBvc2l0ZURpc3Bvc2FibGUsIEVtaXR0ZXIsIFRleHRFZGl0b3J9ID0gcmVxdWlyZSgnYXRvbScpO1xudmFyIHtTdGF0dXNDb2RlSWQsIFN0YXR1c0NvZGVJZFRvTnVtYmVyLCBTdGF0dXNDb2RlTnVtYmVyLCBIZ1N0YXR1c09wdGlvbn0gPVxuICAgIHJlcXVpcmUoJ251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlJykuaGdDb25zdGFudHM7XG52YXIge2Vuc3VyZVRyYWlsaW5nU2VwYXJhdG9yfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpLnBhdGhzO1xudmFyIHtpc1JlbW90ZX0gPSByZXF1aXJlKCdudWNsaWRlLXJlbW90ZS11cmknKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHthZGRBbGxQYXJlbnREaXJlY3Rvcmllc1RvQ2FjaGUsIHJlbW92ZUFsbFBhcmVudERpcmVjdG9yaWVzRnJvbUNhY2hlfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKlxuICogU2VjdGlvbjogQ29uc3RhbnRzLCBUeXBlIERlZmluaXRpb25zXG4gKlxuICovXG5cbnZhciBFRElUT1JfU1VCU0NSSVBUSU9OX05BTUUgPSAnaGctcmVwb3NpdG9yeS1lZGl0b3Itc3Vic2NyaXB0aW9uJztcblxuLy8gVE9ETyAoamVzc2ljYWxpbikgRXhwb3J0IHRoZXNlIHR5cGVzIGZyb20gaGctY29uc3RhbnRzLmpzIHdoZW4gdHlwZXMgY2FuIGJlXG4vLyBleHBvcnRlZC5cbnR5cGUgSGdSZXBvc2l0b3J5T3B0aW9ucyA9IHtcbiAgb3JpZ2luVVJMOiBzdHJpbmc7XG4gIHdvcmtpbmdEaXJlY3Rvcnk6IERpcmVjdG9yeTtcbiAgcHJvamVjdFJvb3REaXJlY3Rvcnk6IERpcmVjdG9yeTtcbn07XG50eXBlIFN0YXR1c0NvZGVJZCA9IHN0cmluZztcbnR5cGUgU3RhdHVzQ29kZU51bWJlciA9IG51bWJlcjtcbnR5cGUgSGdTdGF0dXNPcHRpb24gPSBudW1iZXI7XG5cbmZ1bmN0aW9uIGZpbHRlckZvck9ubHlOb3RJZ25vcmVkKGNvZGU6IFN0YXR1c0NvZGVJZik6IGJvb2xlYW4ge1xuICByZXR1cm4gKGNvZGUgIT09IFN0YXR1c0NvZGVJZC5JR05PUkVEKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyRm9yT25seUlnbm9yZWQoY29kZTogU3RhdHVzQ29kZUlkKTogYm9vbGVhbiB7XG4gIHJldHVybiAoY29kZSA9PT0gU3RhdHVzQ29kZUlkLklHTk9SRUQpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJGb3JBbGxTdGF0dWVzKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqXG4gKiBTZWN0aW9uOiBIZ1JlcG9zaXRvcnlDbGllbnRcbiAqXG4gKi9cblxuLyoqXG4gKiBIZ1JlcG9zaXRvcnlDbGllbnQgcnVucyBvbiB0aGUgbWFjaGluZSB0aGF0IE51Y2xpZGUvQXRvbSBpcyBydW5uaW5nIG9uLlxuICogSXQgaXMgdGhlIGludGVyZmFjZSB0aGF0IG90aGVyIEF0b20gcGFja2FnZXMgd2lsbCB1c2UgdG8gYWNjZXNzIE1lcmN1cmlhbC5cbiAqIEl0IGNhY2hlcyBkYXRhIGZldGNoZWQgZnJvbSBhbiBIZ1NlcnZpY2UuXG4gKiBJdCBpbXBsZW1lbnRzIHRoZSBzYW1lIGludGVyZmFjZSBhcyBHaXRSZXBvc2l0b3J5LCAoaHR0cHM6Ly9hdG9tLmlvL2RvY3MvYXBpL2xhdGVzdC9HaXRSZXBvc2l0b3J5KVxuICogaW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIGFzeW5jaHJvbm91cyBtZXRob2RzIGZvciBzb21lIGdldHRlcnMuXG4gKi9cblxuY2xhc3MgSGdSZXBvc2l0b3J5Q2xpZW50IHtcbiAgLy8gTWFwIG9mIGRpcmVjdG9yeSBwYXRoIHRvIHRoZSBudW1iZXIgb2YgbW9kaWZpZWQgZmlsZXMgd2l0aGluIHRoYXQgZGlyZWN0b3J5LlxuICBfbW9kaWZpZWREaXJlY3RvcnlDYWNoZTogTWFwPHN0cmluZywgbnVtYmVyPjtcbiAgX3NlcnZpY2U6IEhnU2VydmljZTtcblxuICBjb25zdHJ1Y3RvcihyZXBvUGF0aDogc3RyaW5nLCBoZ1NlcnZpY2U6IEhnU2VydmljZSwgb3B0aW9uczogSGdSZXBvc2l0b3J5T3B0aW9ucykge1xuICAgIHRoaXMuX3BhdGggPSByZXBvUGF0aDtcbiAgICB0aGlzLl93b3JraW5nRGlyZWN0b3J5ID0gb3B0aW9ucy53b3JraW5nRGlyZWN0b3J5O1xuICAgIHRoaXMuX3Byb2plY3REaXJlY3RvcnkgPSBvcHRpb25zLnByb2plY3RSb290RGlyZWN0b3J5O1xuICAgIHRoaXMuX29yaWdpblVSTCA9IG9wdGlvbnMub3JpZ2luVVJMO1xuICAgIHRoaXMuX3NlcnZpY2UgPSBoZ1NlcnZpY2U7XG5cbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAvLyBBIG1hcCBmcm9tIGEga2V5IChpbiBtb3N0IGNhc2VzLCBhIGZpbGUgcGF0aCksIHRvIGEgcmVsYXRlZCBEaXNwb3NhYmxlLlxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0ge307XG5cbiAgICB0aGlzLl9oZ1N0YXR1c0NhY2hlID0ge307XG4gICAgdGhpcy5fbW9kaWZpZWREaXJlY3RvcnlDYWNoZSA9IG5ldyBNYXAoKTtcblxuICAgIHRoaXMuX2hnRGlmZkNhY2hlID0ge307XG4gICAgdGhpcy5faGdEaWZmQ2FjaGVGaWxlc1VwZGF0aW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2hnRGlmZkNhY2hlRmlsZXNUb0NsZWFyID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2Rpc3Bvc2FibGVzW0VESVRPUl9TVUJTQ1JJUFRJT05fTkFNRV0gPVxuICAgICAgICAoYXRvbS53b3Jrc3BhY2Uub2JzZXJ2ZVRleHRFZGl0b3JzKChlZGl0b3IpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmdldFBhdGgoKSkge1xuICAgICAgICAvLyBUT0RPOiBvYnNlcnZlIGZvciB3aGVuIHRoaXMgZWRpdG9yJ3MgcGF0aCBjaGFuZ2VzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNQYXRoUmVsZXZhbnQoZWRpdG9yLmdldFBhdGgoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsZVBhdGggPSBlZGl0b3IuZ2V0UGF0aCgpO1xuICAgICAgLy8gSWYgdGhpcyBlZGl0b3IgaGFzIGJlZW4gcHJldmlvdXNseSBhY3RpdmUsIHdlIHdpbGwgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBpbml0aWFsaXplZCBkaWZmIGluZm8gYW5kIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIG9uIGl0LlxuICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2FibGVzW2ZpbGVQYXRoXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBpbml0aWFsIGRpZmYgc3RhdHMgZm9yIHRoaXMgZWRpdG9yLCBhbmQgcmVmcmVzaCB0aGlzIGluZm9ybWF0aW9uXG4gICAgICAvLyB3aGVuZXZlciB0aGUgY29udGVudCBvZiB0aGUgZWRpdG9yIGNoYW5nZXMuXG4gICAgICB0aGlzLl91cGRhdGVEaWZmSW5mbyhmaWxlUGF0aCk7XG5cbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzW2ZpbGVQYXRoXSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlc1tmaWxlUGF0aF0uYWRkKGVkaXRvci5vbkRpZFNhdmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpZmZJbmZvKGV2ZW50LnBhdGgpO1xuICAgICAgfSkpO1xuICAgICAgLy8gUmVtb3ZlIHRoZSBmaWxlIGZyb20gdGhlIGRpZmYgc3RhdHMgY2FjaGUgd2hlbiB0aGUgZWRpdG9yIGlzIGNsb3NlZC5cbiAgICAgIC8vIFRoaXMgaXNuJ3Qgc3RyaWN0bHkgbmVjZXNzYXJ5LCBidXQga2VlcHMgdGhlIGNhY2hlIGFzIHNtYWxsIGFzIHBvc3NpYmxlLlxuICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoaXMgcmVtb3ZhbCBtYXkgcmVzdWx0IGluIHJlbW92aW5nIGluZm9ybWF0aW9uXG4gICAgICAvLyB0aGF0IGlzIHN0aWxsIHJlbGV2YW50OiBlLmcuXG4gICAgICAvLyAgICogaWYgdGhlIHVzZXIgdmVyeSBxdWlja2x5IGNsb3NlcyBhbmQgcmVvcGVucyBhIGZpbGU7IG9yXG4gICAgICAvLyAgICogaWYgdGhlIGZpbGUgaXMgb3BlbiBpbiBtdWx0aXBsZSBlZGl0b3JzLCBhbmQgb25lIG9mIHRob3NlIGlzIGNsb3NlZC5cbiAgICAgIC8vIFRoZXNlIGFyZSBwcm9iYWJseSBlZGdlIGNhc2VzLCB0aG91Z2gsIGFuZCB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZVxuICAgICAgLy8gcmVmZXRjaGVkIHRoZSBuZXh0IHRpbWUgdGhlIGZpbGUgaXMgZWRpdGVkLlxuICAgICAgdGhpcy5fZGlzcG9zYWJsZXNbZmlsZVBhdGhdLmFkZChlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcbiAgICAgICAgdGhpcy5faGdEaWZmQ2FjaGVGaWxlc1RvQ2xlYXIuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXNbZmlsZVBhdGhdLmRpc3Bvc2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Rpc3Bvc2FibGVzW2ZpbGVQYXRoXTtcbiAgICAgIH0pKTtcbiAgICB9KSk7XG5cbiAgICAvLyBHZXQgdXBkYXRlcyB0aGF0IHRlbGwgdGhlIEhnUmVwb3NpdG9yeUNsaWVudCB3aGVuIHRvIGNsZWFyIGl0cyBjYWNoZXMuXG4gICAgdGhpcy5fY29tcG9zaXRlRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgdGhpcy5fY29tcG9zaXRlRGlzcG9zYWJsZS5hZGQodGhpcy5fc2VydmljZS5vbkZpbGVzRGlkQ2hhbmdlKFxuICAgICAgdGhpcy5fZmlsZXNEaWRDaGFuZ2UuYmluZCh0aGlzKVxuICAgICkpO1xuICAgIHRoaXMuX2NvbXBvc2l0ZURpc3Bvc2FibGUuYWRkKHRoaXMuX3NlcnZpY2Uub25IZ0lnbm9yZUZpbGVEaWRDaGFuZ2UoXG4gICAgICB0aGlzLl9yZWZyZXNoU3RhdHVzZXNPZkFsbEZpbGVzSW5DYWNoZS5iaW5kKHRoaXMpXG4gICAgKSk7XG4gICAgdGhpcy5fY29tcG9zaXRlRGlzcG9zYWJsZS5hZGQodGhpcy5fc2VydmljZS5vbkhnUmVwb1N0YXRlRGlkQ2hhbmdlKFxuICAgICAgdGhpcy5fcmVmcmVzaFN0YXR1c2VzT2ZBbGxGaWxlc0luQ2FjaGUuYmluZCh0aGlzKVxuICAgICkpO1xuICAgIHRoaXMuX2NvbXBvc2l0ZURpc3Bvc2FibGUuYWRkKHRoaXMuX3NlcnZpY2Uub25IZ0Jvb2ttYXJrRGlkQ2hhbmdlKFxuICAgICAgdGhpcy5mZXRjaEN1cnJlbnRCb29rbWFyay5iaW5kKHRoaXMpXG4gICAgKSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnZGlkLWRlc3Ryb3knKTtcbiAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9kaXNwb3NhYmxlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlc1trZXldLmRpc3Bvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb21wb3NpdGVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBTZWN0aW9uOiBFdmVudCBTdWJzY3JpcHRpb25cbiAgICpcbiAgICovXG5cbiAgb25EaWREZXN0cm95KGNhbGxiYWNrOiAoKSA9PiB7fSk6IERpc3Bvc2FibGUge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2RpZC1kZXN0cm95JywgY2FsbGJhY2spO1xuICB9XG5cbiAgb25EaWRDaGFuZ2VTdGF0dXMoXG4gICAgY2FsbGJhY2s6IChldmVudDoge3BhdGg6IHN0cmluZzsgcGF0aFN0YXR1czogU3RhdHVzQ29kZU51bWJlcn0pID0+IHt9XG4gICk6IERpc3Bvc2FibGUge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLm9uKCdkaWQtY2hhbmdlLXN0YXR1cycsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG9uRGlkQ2hhbmdlU3RhdHVzZXMoY2FsbGJhY2s6ICgpID0+IHt9KTogRGlzcG9zYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIub24oJ2RpZC1jaGFuZ2Utc3RhdHVzZXMnLCBjYWxsYmFjayk7XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBTZWN0aW9uOiBSZXBvc2l0b3J5IERldGFpbHNcbiAgICpcbiAgICovXG5cbiAgZ2V0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaGcnO1xuICB9XG5cbiAgZ2V0UGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICB9XG5cbiAgZ2V0V29ya2luZ0RpcmVjdG9yeSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93b3JraW5nRGlyZWN0b3J5LmdldFBhdGgoKTtcbiAgfVxuXG4gIC8vIEByZXR1cm4gVGhlIHBhdGggb2YgdGhlIHJvb3QgcHJvamVjdCBmb2xkZXIgaW4gQXRvbSB0aGF0IHRoaXNcbiAgLy8gSGdSZXBvc2l0b3J5Q2xpZW50IHByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0LlxuICBnZXRQcm9qZWN0RGlyZWN0b3J5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2plY3REaXJlY3RvcnkuZ2V0UGF0aCgpO1xuICB9XG5cbiAgLy8gVE9ETyBUaGlzIGlzIGEgc3R1Yi5cbiAgaXNQcm9qZWN0QXRSb290KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmVsYXRpdml6ZShmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd29ya2luZ0RpcmVjdG9yeS5yZWxhdGl2aXplKGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8vIFRPRE8gVGhpcyBpcyBhIHN0dWIuXG4gIGhhc0JyYW5jaChicmFuY2g6IHN0cmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFRoZSBjdXJyZW50IEhnIGJvb2ttYXJrLlxuICAgKi9cbiAgZ2V0U2hvcnRIZWFkKGZpbGVQYXRoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRCb29rbWFyaykge1xuICAgICAgLy8gS2ljayBvZmYgYSBmZXRjaCB0byBnZXQgdGhlIGN1cnJlbnQgYm9va21hcmsuIFRoaXMgaXMgYXN5bmMuXG4gICAgICB0aGlzLmZldGNoQ3VycmVudEJvb2ttYXJrKCk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qm9va21hcms7XG4gIH1cblxuICAvLyBUT0RPIFRoaXMgaXMgYSBzdHViLlxuICBpc1N1Ym1vZHVsZShwYXRoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVE9ETyBUaGlzIGlzIGEgc3R1Yi5cbiAgZ2V0QWhlYWRCZWhpbmRDb3VudChyZWZlcmVuY2UsIHBhdGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIFRPRE8gVGhpcyBpcyBhIHN0dWIuXG4gIGdldENhY2hlZFVwc3RyZWFtQWhlYWRCZWhpbmRDb3VudChwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFoZWFkOiAwLFxuICAgICAgYmVoaW5kOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBUT0RPIFRoaXMgaXMgYSBzdHViLlxuICBnZXRDb25maWdWYWx1ZShrZXk6IHN0cmluZywgcGF0aDogP3N0cmluZyk6ID9zdHJpbmcge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0T3JpZ2luVVJMKHBhdGg6ID9zdHJpbmcpOiA/c3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luVVJMO1xuICB9XG5cbiAgLy8gVE9ETyBUaGlzIGlzIGEgc3R1Yi5cbiAgZ2V0VXBzdHJlYW1CcmFuY2gocGF0aDogP3N0cmluZyk6ID9zdHJpbmcge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETyBUaGlzIGlzIGEgc3R1Yi5cbiAgZ2V0UmVmZXJlbmNlcyhwYXRoOiA/c3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRzOiBbXSxcbiAgICAgIHJlbW90ZXM6IFtdLFxuICAgICAgdGFnczogW10sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE8gVGhpcyBpcyBhIHN0dWIuXG4gIGdldFJlZmVyZW5jZVRhcmdldChyZWZlcmVuY2U6IHN0cmluZywgcGF0aDogP3N0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cblxuICAvKipcbiAgICpcbiAgICogU2VjdGlvbjogUmVhZGluZyBTdGF0dXMgKHBhcml0eSB3aXRoIEdpdFJlcG9zaXRvcnkpXG4gICAqXG4gICAqL1xuXG4gIC8vIFRPRE8gKGplc3NpY2FsaW4pIENhbiB3ZSBjaGFuZ2UgdGhlIEFQSSB0byBtYWtlIHRoaXMgbWV0aG9kIHJldHVybiBhIFByb21pc2U/XG4gIC8vIElmIG5vdCwgbWlnaHQgbmVlZCB0byBkbyBhIHN5bmNocm9ub3VzIGBoZyBzdGF0dXNgIHF1ZXJ5LlxuICBpc1BhdGhNb2RpZmllZChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGVkUGF0aFN0YXR1cyA9IHRoaXMuX2hnU3RhdHVzQ2FjaGVbZmlsZVBhdGhdO1xuICAgIGlmICghY2FjaGVkUGF0aFN0YXR1cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N0YXR1c01vZGlmaWVkKFN0YXR1c0NvZGVJZFRvTnVtYmVyW2NhY2hlZFBhdGhTdGF0dXNdKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIChqZXNzaWNhbGluKSBDYW4gd2UgY2hhbmdlIHRoZSBBUEkgdG8gbWFrZSB0aGlzIG1ldGhvZCByZXR1cm4gYSBQcm9taXNlP1xuICAvLyBJZiBub3QsIG1pZ2h0IG5lZWQgdG8gZG8gYSBzeW5jaHJvbm91cyBgaGcgc3RhdHVzYCBxdWVyeS5cbiAgaXNQYXRoTmV3KGZpbGVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZWRQYXRoU3RhdHVzID0gdGhpcy5faGdTdGF0dXNDYWNoZVtmaWxlUGF0aF07XG4gICAgaWYgKCFjYWNoZWRQYXRoU3RhdHVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3RhdHVzTmV3KFN0YXR1c0NvZGVJZFRvTnVtYmVyW2NhY2hlZFBhdGhTdGF0dXNdKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIChqZXNzaWNhbGluKSBDYW4gd2UgY2hhbmdlIHRoZSBBUEkgdG8gbWFrZSB0aGlzIG1ldGhvZCByZXR1cm4gYSBQcm9taXNlP1xuICAvLyBJZiBub3QsIHRoaXMgbWV0aG9kIGxpZXMgYSBiaXQgYnkgdXNpbmcgY2FjaGVkIGluZm9ybWF0aW9uLlxuICAvLyBUT0RPIChqZXNzaWNhbGluKSBNYWtlIHRoaXMgd29yayBmb3IgaWdub3JlZCBkaXJlY3Rvcmllcy5cbiAgaXNQYXRoSWdub3JlZChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBgaGcgc3RhdHVzIC1pYCBkb2VzIG5vdCBsaXN0IHRoZSByZXBvICh0aGUgLmhnIGRpcmVjdG9yeSksIHByZXN1bWFibHlcbiAgICAvLyBiZWNhdXNlIHRoZSByZXBvIGRvZXMgbm90IHRyYWNrIGl0c2VsZi5cbiAgICAvLyBXZSB3YW50IHRvIHJlcHJlc2VudCB0aGUgZmFjdCB0aGF0IGl0J3Mgbm90IHBhcnQgb2YgdGhlIHRyYWNrZWQgY29udGVudHMsXG4gICAgLy8gc28gd2UgbWFudWFsbHkgYWRkIGFuIGV4Y2VwdGlvbiBmb3IgaXQgdmlhIHRoZSBfaXNQYXRoV2l0aGluSGdSZXBvIGNoZWNrLlxuICAgIHJldHVybiAodGhpcy5faGdTdGF0dXNDYWNoZVtmaWxlUGF0aF0gPT09IFN0YXR1c0NvZGVJZC5JR05PUkVEKSB8fFxuICAgICAgICB0aGlzLl9pc1BhdGhXaXRoaW5IZ1JlcG8oZmlsZVBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyB3aXRoaW4gdGhlIHJlcG8gZGlyZWN0b3J5IChpLmUuIGAuaGcvYCkuXG4gICAqL1xuICBfaXNQYXRoV2l0aGluSGdSZXBvKGZpbGVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoZmlsZVBhdGggPT09IHRoaXMuZ2V0UGF0aCgpKSB8fCAoZmlsZVBhdGguaW5kZXhPZih0aGlzLmdldFBhdGgoKSArICcvJykgPT09IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcGF0aCBpcyByZWxldmFudCB0byB0aGlzIEhnUmVwb3NpdG9yeUNsaWVudC4gQSBwYXRoIGlzXG4gICAqIGRlZmluZWQgYXMgJ3JlbGV2YW50JyBpZiBpdCBpcyB3aXRoaW4gdGhlIHByb2plY3QgZGlyZWN0b3J5IG9wZW5lZCB3aXRoaW4gdGhlIHJlcG8uXG4gICAqL1xuICBfaXNQYXRoUmVsZXZhbnQoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RGlyZWN0b3J5LmNvbnRhaW5zKGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8vIEZvciBub3csIHRoaXMgbWV0aG9kIG9ubHkgcmVmbGVjdHMgdGhlIHN0YXR1cyBvZiBcIm1vZGlmaWVkXCIgZGlyZWN0b3JpZXMuXG4gIC8vIFRyYWNraW5nIGRpcmVjdG9yeSBzdGF0dXMgaXNuJ3Qgc3RyYWlnaHRmb3J3YXJkLCBhcyBIZyBvbmx5IHRyYWNrcyBmaWxlcy5cbiAgLy8gaHR0cDovL21lcmN1cmlhbC5zZWxlbmljLmNvbS93aWtpL0ZBUSNGQVEuMkZDb21tb25Qcm9ibGVtcy5JX3RyaWVkX3RvX2NoZWNrX2luX2FuX2VtcHR5X2RpcmVjdG9yeV9hbmRfaXRfZmFpbGVkLjIxXG4gIC8vIFRPRE86IE1ha2UgdGhpcyBtZXRob2QgcmVmbGVjdCBOZXcgYW5kIElnbm9yZWQgc3RhdHVzZXMuXG4gIGdldERpcmVjdG9yeVN0YXR1cyhkaXJlY3RvcnlQYXRoOiA/c3RyaW5nKTogU3RhdHVzQ29kZU51bWJlciB7XG4gICAgaWYgKCFkaXJlY3RvcnlQYXRoKSB7XG4gICAgICByZXR1cm4gU3RhdHVzQ29kZU51bWJlci5DTEVBTjtcbiAgICB9XG4gICAgdmFyIGRpcmVjdG9yeVBhdGhXaXRoU2VwYXJhdG9yID0gZW5zdXJlVHJhaWxpbmdTZXBhcmF0b3IoZGlyZWN0b3J5UGF0aCk7XG4gICAgaWYgKHRoaXMuX21vZGlmaWVkRGlyZWN0b3J5Q2FjaGUuaGFzKGRpcmVjdG9yeVBhdGhXaXRoU2VwYXJhdG9yKSkge1xuICAgICAgcmV0dXJuIFN0YXR1c0NvZGVOdW1iZXIuTU9ESUZJRUQ7XG4gICAgfVxuICAgIHJldHVybiBTdGF0dXNDb2RlTnVtYmVyLkNMRUFOO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBkbyBhbnkgc3luY2hyb25vdXMgJ2hnIHN0YXR1cycgY2FsbHMuIEp1c3QgdXNlIGNhY2hlZCB2YWx1ZXMuXG4gIGdldFBhdGhTdGF0dXMoZmlsZVBhdGg6IHN0cmluZyk6IFN0YXR1c0NvZGVOdW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldENhY2hlZFBhdGhTdGF0dXMoZmlsZVBhdGgpO1xuICB9XG5cbiAgZ2V0Q2FjaGVkUGF0aFN0YXR1cyhmaWxlUGF0aDogc3RyaW5nKTogU3RhdHVzQ29kZU51bWJlciB7XG4gICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgcmV0dXJuIFN0YXR1c0NvZGVOdW1iZXIuQ0xFQU47XG4gICAgfVxuICAgIHZhciBjYWNoZWRTdGF0dXMgPSB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXTtcbiAgICBpZiAoY2FjaGVkU3RhdHVzKSB7XG4gICAgICByZXR1cm4gU3RhdHVzQ29kZUlkVG9OdW1iZXJbY2FjaGVkU3RhdHVzXTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YXR1c0NvZGVOdW1iZXIuQ0xFQU47XG4gIH1cblxuICBpc1N0YXR1c01vZGlmaWVkKHN0YXR1czogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXR1cyA9PT0gU3RhdHVzQ29kZU51bWJlci5NT0RJRklFRCB8fFxuICAgICAgc3RhdHVzID09PSBTdGF0dXNDb2RlTnVtYmVyLk1JU1NJTkcgfHxcbiAgICAgIHN0YXR1cyA9PT0gU3RhdHVzQ29kZU51bWJlci5SRU1PVkVEXG4gICAgKTtcbiAgfVxuXG4gIGlzU3RhdHVzTmV3KHN0YXR1czogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXR1cyA9PT0gU3RhdHVzQ29kZU51bWJlci5BRERFRCB8fFxuICAgICAgc3RhdHVzID09PSBTdGF0dXNDb2RlTnVtYmVyLlVOVFJBQ0tFRFxuICAgICk7XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBTZWN0aW9uOiBSZWFkaW5nIEhnIFN0YXR1cyAoYXN5bmMgbWV0aG9kcylcbiAgICpcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlY29tbWVuZGVkIG1ldGhvZCB0byB1c2UgdG8gZ2V0IHRoZSBzdGF0dXMgb2YgZmlsZXMgaW4gdGhpcyByZXBvLlxuICAgKiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZSBwYXRocyB0byBnZXQgdGhlIHN0YXR1cyBmb3IuIElmIGEgcGF0aCBpcyBub3QgaW4gdGhlXG4gICAqICAgcHJvamVjdCwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBTZWUgSGdTZXJ2aWNlOjpnZXRTdGF0dXNlcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGFzeW5jIGdldFN0YXR1c2VzKHBhdGhzOiBBcnJheTxzdHJpbmc+LCBvcHRpb25zOiA/YW55KTogUHJvbWlzZTx7W2tleTogc3RyaW5nXTogU3RhdHVzQ29kZU51bWJlcn0+IHtcbiAgICB2YXIgc3RhdHVzTWFwID0ge307XG4gICAgdmFyIGlzUmVsYXZhbnRTdGF0dXMgPSB0aGlzLl9nZXRQcmVkaWNhdGVGb3JSZWxldmFudFN0YXR1c2VzKG9wdGlvbnMpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNhY2hlLlxuICAgIC8vIE5vdGU6IElmIHBhdGhzIGlzIGVtcHR5LCBhIGZ1bGwgYGhnIHN0YXR1c2Agd2lsbCBiZSBydW4sIHdoaWNoIGZvbGxvd3MgdGhlIHNwZWMuXG4gICAgdmFyIHBhdGhzV2l0aENhY2hlTWlzcyA9IFtdO1xuICAgIHBhdGhzLmZvckVhY2goKGZpbGVQYXRoKSA9PiB7XG4gICAgICB2YXIgc3RhdHVzSWQgPSB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXTtcbiAgICAgIGlmIChzdGF0dXNJZCkge1xuICAgICAgICBpZiAoIWlzUmVsYXZhbnRTdGF0dXMoc3RhdHVzSWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1c01hcFtmaWxlUGF0aF0gPSBTdGF0dXNDb2RlSWRUb051bWJlcltzdGF0dXNJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoc1dpdGhDYWNoZU1pc3MucHVzaChmaWxlUGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGZXRjaCBhbnkgdW5jYWNoZWQgc3RhdHVzZXMuXG4gICAgaWYgKHBhdGhzV2l0aENhY2hlTWlzcy5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXdTdGF0dXNJbmZvID0gYXdhaXQgdGhpcy5fdXBkYXRlU3RhdHVzZXMocGF0aHNXaXRoQ2FjaGVNaXNzLCBvcHRpb25zKTtcbiAgICAgIE9iamVjdC5rZXlzKG5ld1N0YXR1c0luZm8pLmZvckVhY2goKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIHN0YXR1c01hcFtmaWxlUGF0aF0gPSBTdGF0dXNDb2RlSWRUb051bWJlcltuZXdTdGF0dXNJbmZvW2ZpbGVQYXRoXV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1c01hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBzdGF0dXNlcyBmb3IgdGhlIGdpdmVuIGZpbGUgcGF0aHMsIGFuZCB1cGRhdGVzIHRoZSBjYWNoZSBhbmRcbiAgICogc2VuZHMgb3V0IGNoYW5nZSBldmVudHMgYXMgYXBwcm9wcmlhdGUuXG4gICAqIEBwYXJhbSBmaWxlUGF0aHMgQW4gYXJyYXkgb2YgZmlsZSBwYXRocyB0byB1cGRhdGUgdGhlIHN0YXR1cyBmb3IuIElmIGEgcGF0aFxuICAgKiAgIGlzIG5vdCBpbiB0aGUgcHJvamVjdCwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZVN0YXR1c2VzKGZpbGVQYXRoczogQXJyYXk8c3RyaW5nPiwgb3B0aW9uczogP2FueSk6IFByb21pc2U8e1trZXk6IHN0cmluZ106IFN0YXR1c0NvZGVJZH0+IHtcbiAgICB2YXIgcGF0aHNJblJlcG8gPSBmaWxlUGF0aHMuZmlsdGVyKChmaWxlUGF0aCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUGF0aFJlbGV2YW50KGZpbGVQYXRoKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhdHVzTWFwUGF0aFRvU3RhdHVzSWQgPSBhd2FpdCB0aGlzLl9zZXJ2aWNlLmZldGNoU3RhdHVzZXMocGF0aHNJblJlcG8sIG9wdGlvbnMpO1xuICAgIC8vIFVudGlsIHRoZSBzZXJ2aWNlIGZyYW1ld29yayBjYW4gZG8gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgd2UgZG8gdGhpcyBtYW51YWxcbiAgICAvLyBhZGp1c3RtZW50IGZvciByZW1vdGUgcGF0aHMuXG4gICAgaWYgKGlzUmVtb3RlKHRoaXMuX3dvcmtpbmdEaXJlY3RvcnkuZ2V0UGF0aCgpKSkge1xuICAgICAgdmFyIHJlbW90ZSA9IHRoaXMuX3dvcmtpbmdEaXJlY3RvcnkuX3JlbW90ZTtcbiAgICAgIE9iamVjdC5rZXlzKHN0YXR1c01hcFBhdGhUb1N0YXR1c0lkKS5mb3JFYWNoKChmaWxlUGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9jYWxQYXRoID0gcmVtb3RlLmdldFBhdGhPZlVyaShmaWxlUGF0aCk7XG4gICAgICAgIHZhciBhZGp1c3RlZEZpbGVQYXRoID0gcmVtb3RlLmdldFVyaU9mUmVtb3RlUGF0aChsb2NhbFBhdGgpO1xuICAgICAgICBzdGF0dXNNYXBQYXRoVG9TdGF0dXNJZFthZGp1c3RlZEZpbGVQYXRoXSA9IHN0YXR1c01hcFBhdGhUb1N0YXR1c0lkW2ZpbGVQYXRoXTtcbiAgICAgICAgZGVsZXRlIHN0YXR1c01hcFBhdGhUb1N0YXR1c0lkW2ZpbGVQYXRoXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBxdWVyaWVkRmlsZXMgPSBuZXcgU2V0KHBhdGhzSW5SZXBvKTtcbiAgICB2YXIgc3RhdHVzQ2hhbmdlRXZlbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMoc3RhdHVzTWFwUGF0aFRvU3RhdHVzSWQpLmZvckVhY2goKGZpbGVQYXRoKSA9PiB7XG4gICAgICB2YXIgbmV3U3RhdHVzSWQgPSBzdGF0dXNNYXBQYXRoVG9TdGF0dXNJZFtmaWxlUGF0aF07XG5cbiAgICAgIHZhciBvbGRTdGF0dXMgPSB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXTtcbiAgICAgIGlmIChvbGRTdGF0dXMgJiYgKG9sZFN0YXR1cyAhPT0gbmV3U3RhdHVzSWQpIHx8XG4gICAgICAgICAgIW9sZFN0YXR1cyAmJiAobmV3U3RhdHVzSWQgIT09IFN0YXR1c0NvZGVJZC5DTEVBTikpIHtcbiAgICAgICAgc3RhdHVzQ2hhbmdlRXZlbnRzLnB1c2goe1xuICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgIHBhdGhTdGF0dXM6IFN0YXR1c0NvZGVJZFRvTnVtYmVyW25ld1N0YXR1c0lkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdTdGF0dXNJZCA9PT0gU3RhdHVzQ29kZUlkLkNMRUFOKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGtlZXBpbmcgJ2NsZWFuJyBmaWxlcyBpbiB0aGUgY2FjaGUuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hnU3RhdHVzQ2FjaGVbZmlsZVBhdGhdO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFBhcmVudERpcmVjdG9yaWVzRnJvbUNhY2hlKGZpbGVQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXSA9IG5ld1N0YXR1c0lkO1xuICAgICAgICAgIGlmIChuZXdTdGF0dXNJZCA9PT0gU3RhdHVzQ29kZUlkLk1PRElGSUVEKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRBbGxQYXJlbnREaXJlY3Rvcmllc1RvQ2FjaGUoZmlsZVBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVlcmllZEZpbGVzLmRlbGV0ZShmaWxlUGF0aCk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgc3RhdHVzZXMgd2VyZSBmZXRjaGVkIGZvciBvbmx5IGNoYW5nZWQgKGBoZyBzdGF0dXNgKSBvclxuICAgIC8vIGlnbm9yZWQgKCdoZyBzdGF0dXMgLS1pZ25vcmVkYCkgZmlsZXMsIGEgcXVlcmllZCBmaWxlIG1heSBub3QgYmVcbiAgICAvLyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuIElmIGl0IHdhc24ndCByZXR1cm5lZCwgdGhpcyBtZWFucyBpdHMgc3RhdHVzXG4gICAgLy8gbWF5IGhhdmUgY2hhbmdlZCwgaW4gd2hpY2ggY2FzZSBpdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBoZ1N0YXR1c0NhY2hlLlxuICAgIC8vIE5vdGU6IHdlIGRvbid0IGtub3cgdGhlIHJlYWwgdXBkYXRlZCBzdGF0dXMgb2YgdGhlIGZpbGUsIHNvIGRvbid0IHNlbmQgYSBjaGFuZ2UgZXZlbnQuXG4gICAgLy8gVE9ETyAoamVzc2ljYWxpbikgQ2FuIHdlIG1ha2UgdGhlICdwYXRoU3RhdHVzJyBmaWVsZCBpbiB0aGUgY2hhbmdlIGV2ZW50IG9wdGlvbmFsP1xuICAgIC8vIFRoZW4gd2UgY2FuIHNlbmQgdGhlc2UgZXZlbnRzLlxuICAgIHZhciBoYXNPcHRpb25zID0gb3B0aW9ucyAmJiAoJ2hnU3RhdHVzT3B0aW9uJyBpbiBvcHRpb25zKTtcbiAgICBpZiAoaGFzT3B0aW9ucyAmJiAob3B0aW9ucy5oZ1N0YXR1c09wdGlvbiA9PT0gSGdTdGF0dXNPcHRpb24uT05MWV9JR05PUkVEKSkge1xuICAgICAgcXVlcmllZEZpbGVzLmZvckVhY2goKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXSA9PT0gU3RhdHVzQ29kZUlkLklHTk9SRUQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faGdTdGF0dXNDYWNoZVtmaWxlUGF0aF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzT3B0aW9ucyAmJiAob3B0aW9ucy5oZ1N0YXR1c09wdGlvbiA9PT0gSGdTdGF0dXNPcHRpb24uQUxMX1NUQVRVU0VTKSkge1xuICAgICAgLy8gTm8gYWN0aW9uIG5lZWRzIHRvIGJlIHRha2VuIGZvciB0aGUgSGdTdGF0dXNPcHRpb24uQUxMX1NUQVRVU0VTIGNhc2UuXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJpZWRGaWxlcy5mb3JFYWNoKChmaWxlUGF0aCkgPT4ge1xuICAgICAgICB2YXIgY2FjaGVkU3RhdHVzSWQgPSB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXTtcbiAgICAgICAgaWYgKGNhY2hlZFN0YXR1c0lkICE9PSBTdGF0dXNDb2RlSWQuSUdOT1JFRCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZ1N0YXR1c0NhY2hlW2ZpbGVQYXRoXTtcbiAgICAgICAgICBpZiAoY2FjaGVkU3RhdHVzSWQgPT09IFN0YXR1c0NvZGVJZC5NT0RJRklFRCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsUGFyZW50RGlyZWN0b3JpZXNGcm9tQ2FjaGUoZmlsZVBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBjaGFuZ2UgZXZlbnRzIG9ubHkgYWZ0ZXIgdGhlIGNhY2hlIGhhcyBiZWVuIGZ1bGx5IHVwZGF0ZWQuXG4gICAgc3RhdHVzQ2hhbmdlRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoJ2RpZC1jaGFuZ2Utc3RhdHVzJywgZXZlbnQpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnZGlkLWNoYW5nZS1zdGF0dXNlcycpO1xuXG4gICAgcmV0dXJuIHN0YXR1c01hcFBhdGhUb1N0YXR1c0lkO1xuICB9XG5cbiAgX2FkZEFsbFBhcmVudERpcmVjdG9yaWVzVG9DYWNoZShmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgYWRkQWxsUGFyZW50RGlyZWN0b3JpZXNUb0NhY2hlKFxuICAgICAgdGhpcy5fbW9kaWZpZWREaXJlY3RvcnlDYWNoZSxcbiAgICAgIGZpbGVQYXRoLFxuICAgICAgdGhpcy5fcHJvamVjdERpcmVjdG9yeS5nZXRQYXJlbnQoKS5nZXRQYXRoKClcbiAgICApO1xuICB9XG5cbiAgX3JlbW92ZUFsbFBhcmVudERpcmVjdG9yaWVzRnJvbUNhY2hlKGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICByZW1vdmVBbGxQYXJlbnREaXJlY3Rvcmllc0Zyb21DYWNoZShcbiAgICAgIHRoaXMuX21vZGlmaWVkRGlyZWN0b3J5Q2FjaGUsXG4gICAgICBmaWxlUGF0aCxcbiAgICAgIHRoaXMuX3Byb2plY3REaXJlY3RvcnkuZ2V0UGFyZW50KCkuZ2V0UGF0aCgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIDo6Z2V0U3RhdHVzZXMuXG4gICAqIFJldHVybnMgYSBmaWx0ZXIgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBzdGF0dXMgY29kZSBzaG91bGQgYmVcbiAgICogcmV0dXJuZWQsIGdpdmVuIHRoZSBwYXNzZWQtaW4gb3B0aW9ucyBmb3IgOjpnZXRTdGF0dXNlcy5cbiAgICovXG4gIF9nZXRQcmVkaWNhdGVGb3JSZWxldmFudFN0YXR1c2VzKG9wdGlvbnM6ID9hbnkpOiAoY29kZTogU3RhdHVzQ29kZUlkKSA9PiBib29sZWFuIHtcbiAgICB2YXIgaGFzT3B0aW9ucyA9IG9wdGlvbnMgJiYgKCdoZ1N0YXR1c09wdGlvbicgaW4gb3B0aW9ucyk7XG5cbiAgICBpZiAoaGFzT3B0aW9ucyAmJiAob3B0aW9ucy5oZ1N0YXR1c09wdGlvbiA9PT0gSGdTdGF0dXNPcHRpb24uT05MWV9JR05PUkVEKSkge1xuICAgICAgcmV0dXJuIGZpbHRlckZvck9ubHlJZ25vcmVkO1xuICAgIH0gZWxzZSBpZiAoaGFzT3B0aW9ucyAmJiAob3B0aW9ucy5oZ1N0YXR1c09wdGlvbiA9PT0gSGdTdGF0dXNPcHRpb24uQUxMX1NUQVRVU0VTKSkge1xuICAgICAgcmV0dXJuIGZpbHRlckZvckFsbFN0YXR1ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaWx0ZXJGb3JPbmx5Tm90SWdub3JlZDtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBTZWN0aW9uOiBSZXRyaWV2aW5nIERpZmZzIChwYXJpdHkgd2l0aCBHaXRSZXBvc2l0b3J5KVxuICAgKlxuICAgKi9cblxuICBnZXREaWZmU3RhdHMoZmlsZVBhdGg6IHN0cmluZyk6IHthZGRlZDogbnVtYmVyOyBkZWxldGVkOiBudW1iZXI7fSB7XG4gICAgdmFyIGNsZWFuU3RhdHMgPSB7YWRkZWQ6IDAsIGRlbGV0ZWQ6IDB9O1xuICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBjbGVhblN0YXRzO1xuICAgIH1cbiAgICB2YXIgY2FjaGVkRGF0YSA9IHRoaXMuX2hnRGlmZkNhY2hlW2ZpbGVQYXRoXTtcbiAgICByZXR1cm4gY2FjaGVkRGF0YSA/IHthZGRlZDogY2FjaGVkRGF0YS5hZGRlZCwgZGVsZXRlZDogY2FjaGVkRGF0YS5kZWxldGVkfSA6XG4gICAgICAgIGNsZWFuU3RhdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBMaW5lRGlmZiB0aGF0IGRlc2NyaWJlcyB0aGUgZGlmZnMgYmV0d2VlbiB0aGUgZ2l2ZW5cbiAgICogZmlsZSdzIGBIRUFEYCBjb250ZW50cyBhbmQgaXRzIGN1cnJlbnQgY29udGVudHMuXG4gICAqIE5PVEU6IHRoaXMgbWV0aG9kIGN1cnJlbnRseSBpZ25vcmVzIHRoZSBwYXNzZWQtaW4gdGV4dCwgYW5kIGluc3RlYWQgZGlmZnNcbiAgICogYWdhaW5zdCB0aGUgY3VycmVudGx5IHNhdmVkIGNvbnRlbnRzIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgLy8gVE9ETyAoamVzc2ljYWxpbikgRXhwb3J0IHRoZSBMaW5lRGlmZiB0eXBlIChmcm9tIGhnLW91dHB1dC1oZWxwZXJzKSB3aGVuXG4gIC8vIHR5cGVzIGNhbiBiZSBleHBvcnRlZC5cbiAgLy8gVE9ETyAoamVzc2ljYWxpbikgTWFrZSB0aGlzIG1ldGhvZCB3b3JrIHdpdGggdGhlIHBhc3NlZC1pbiBgdGV4dGAuIHQ2MzkxNTc5XG4gIGdldExpbmVEaWZmcyhmaWxlUGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpOiBBcnJheTxMaW5lRGlmZj4ge1xuICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGRpZmZJbmZvID0gdGhpcy5faGdEaWZmQ2FjaGVbZmlsZVBhdGhdO1xuICAgIHJldHVybiBkaWZmSW5mbyA/IGRpZmZJbmZvLmxpbmVEaWZmcyA6IFtdO1xuICB9XG5cblxuICAvKipcbiAgICpcbiAgICogU2VjdGlvbjogUmV0cmlldmluZyBEaWZmcyAoYXN5bmMgbWV0aG9kcylcbiAgICpcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlY29tbWVuZGVkIG1ldGhvZCB0byB1c2UgdG8gZ2V0IHRoZSBkaWZmIHN0YXRzIG9mIGZpbGVzIGluIHRoaXMgcmVwby5cbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCB0byBnZXQgdGhlIHN0YXR1cyBmb3IuIElmIGEgcGF0aCBpcyBub3QgaW4gdGhlXG4gICAqICAgcHJvamVjdCwgZGVmYXVsdCBcImNsZWFuXCIgc3RhdHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICovXG4gIGFzeW5jIGdldERpZmZTdGF0c0ZvclBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8e2FkZGVkOiBudW1iZXI7IGRlbGV0ZWQ6IG51bWJlcjt9PiB7XG4gICAgdmFyIGNsZWFuU3RhdHMgPSB7YWRkZWQ6IDAsIGRlbGV0ZWQ6IDB9O1xuICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBjbGVhblN0YXRzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBjYWNoZS5cbiAgICB2YXIgY2FjaGVkRGlmZkluZm8gPSB0aGlzLl9oZ0RpZmZDYWNoZVtmaWxlUGF0aF07XG4gICAgaWYgKGNhY2hlZERpZmZJbmZvKSB7XG4gICAgICByZXR1cm4ge2FkZGVkOiBjYWNoZWREaWZmSW5mby5hZGRlZCwgZGVsZXRlZDogY2FjaGVkRGlmZkluZm8uZGVsZXRlZH07XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIGEgZmV0Y2guXG4gICAgdmFyIGZldGNoZWREaWZmSW5mbyA9IGF3YWl0IHRoaXMuX3VwZGF0ZURpZmZJbmZvKGZpbGVQYXRoKTtcbiAgICBpZiAoZmV0Y2hlZERpZmZJbmZvKSB7XG4gICAgICByZXR1cm4ge2FkZGVkOiBmZXRjaGVkRGlmZkluZm8uYWRkZWQsIGRlbGV0ZWQ6IGZldGNoZWREaWZmSW5mby5kZWxldGVkfTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW5TdGF0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbW1lbmRlZCBtZXRob2QgdG8gdXNlIHRvIGdldCB0aGUgbGluZSBkaWZmcyBvZiBmaWxlcyBpbiB0aGlzIHJlcG8uXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBhYnNvbHV0ZSBmaWxlIHBhdGggdG8gZ2V0IHRoZSBsaW5lIGRpZmZzIGZvci4gSWYgdGhlIHBhdGggXFxcbiAgICogICBpcyBub3QgaW4gdGhlIHByb2plY3QsIGFuIGVtcHR5IEFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBhc3luYyBnZXRMaW5lRGlmZnNGb3JQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PExpbmVEaWZmPj4ge1xuICAgIHZhciBsaW5lRGlmZnMgPSBbXTtcbiAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICByZXR1cm4gbGluZURpZmZzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBjYWNoZS5cbiAgICB2YXIgY2FjaGVkRGlmZkluZm8gPSB0aGlzLl9oZ0RpZmZDYWNoZVtmaWxlUGF0aF07XG4gICAgaWYgKGNhY2hlZERpZmZJbmZvKSB7XG4gICAgICByZXR1cm4gY2FjaGVkRGlmZkluZm8ubGluZURpZmZzO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byBhIGZldGNoLlxuICAgIHZhciBmZXRjaGVkRGlmZkluZm8gPSBhd2FpdCB0aGlzLl91cGRhdGVEaWZmSW5mbyhmaWxlUGF0aCk7XG4gICAgaWYgKGZldGNoZWREaWZmSW5mbykge1xuICAgICAgcmV0dXJuIGZldGNoZWREaWZmSW5mby5saW5lRGlmZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVEaWZmcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWZmIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gcGF0aCwgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlLlxuICAgKiBUaGlzIG1ldGhvZCBtYXkgcmV0dXJuIGBudWxsYCBpZiB0aGUgcGF0aCBpcyBub3QgaW4gdGhlIHByb2plY3Q7IHRoZSBjYWxsIHRvXG4gICAqIGBoZyBkaWZmYCBmYWlsczsgb3IgYW4gdXBkYXRlIGZvciB0aGlzIHBhdGggaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICovXG4gIGFzeW5jIF91cGRhdGVEaWZmSW5mbyhmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTw/RGlmZkluZm8+IHtcbiAgICBpZiAoIXRoaXMuX2lzUGF0aFJlbGV2YW50KGZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIERvbid0IGRvIGFub3RoZXIgdXBkYXRlIGlmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHJ1bm5pbmcgYW4gdXBkYXRlXG4gICAgLy8gZm9yIHRoaXMgZmlsZS5cbiAgICBpZiAodGhpcy5faGdEaWZmQ2FjaGVGaWxlc1VwZGF0aW5nLmhhcyhmaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZ0RpZmZDYWNoZUZpbGVzVXBkYXRpbmcuYWRkKGZpbGVQYXRoKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZkluZm8gPSBhd2FpdCB0aGlzLl9zZXJ2aWNlLmZldGNoRGlmZkluZm8oZmlsZVBhdGgpO1xuICAgIGlmIChkaWZmSW5mbykge1xuICAgICAgdGhpcy5faGdEaWZmQ2FjaGVbZmlsZVBhdGhdID0gZGlmZkluZm87XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGZpbGVzIG1hcmtlZCBmb3IgZGVsZXRpb24uXG4gICAgdGhpcy5faGdEaWZmQ2FjaGVGaWxlc1RvQ2xlYXIuZm9yRWFjaCgoZmlsZVRvQ2xlYXIpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9oZ0RpZmZDYWNoZVtmaWxlVG9DbGVhcl07XG4gICAgfSk7XG4gICAgdGhpcy5faGdEaWZmQ2FjaGVGaWxlc1RvQ2xlYXIuY2xlYXIoKTtcblxuICAgIC8vIFRoaXMgZmlsZSBjYW4gbm93IGJlIHVwZGF0ZWQgYWdhaW4uXG4gICAgdGhpcy5faGdEaWZmQ2FjaGVGaWxlc1VwZGF0aW5nLmRlbGV0ZShmaWxlUGF0aCk7XG5cbiAgICByZXR1cm4gZGlmZkluZm87XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBTZWN0aW9uOiBSZXRyaWV2aW5nIEJvb2ttYXJrIChhc3luYyBtZXRob2RzKVxuICAgKlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hDdXJyZW50Qm9va21hcmsoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB2YXIgbmV3bHlGZXRjaGVkQm9va21hcmsgPSAnJztcbiAgICB0cnkge1xuICAgICAgdmFyIG5ld2x5RmV0Y2hlZEJvb2ttYXJrID0gYXdhaXQgdGhpcy5fc2VydmljZS5mZXRjaEN1cnJlbnRCb29rbWFyaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFN1cHByZXNzIHRoZSBlcnJvci4gVGhlcmUgYXJlIGxlZ2l0aW1hdGUgdGltZXMgd2hlbiB0aGVyZSBtYXkgYmUgbm9cbiAgICAgIC8vIGN1cnJlbnQgYm9va21hcmssIHN1Y2ggYXMgZHVyaW5nIGEgcmViYXNlLiBJbiB0aGlzIGNhc2UsIHdlIGp1c3Qgd2FudFxuICAgICAgLy8gdG8gcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBjdXJyZW50IGJvb2ttYXJrLlxuICAgIH1cbiAgICBpZiAobmV3bHlGZXRjaGVkQm9va21hcmsgIT09IHRoaXMuX2N1cnJlbnRCb29rbWFyaykge1xuICAgICAgdGhpcy5fY3VycmVudEJvb2ttYXJrID0gbmV3bHlGZXRjaGVkQm9va21hcms7XG4gICAgICAvLyBUaGUgQXRvbSBzdGF0dXMtYmFyIHVzZXMgdGhpcyBhcyBhIHNpZ25hbCB0byByZWZyZXNoIHRoZSAnc2hvcnRIZWFkJy5cbiAgICAgIC8vIFRoZXJlIGlzIGN1cnJlbnRseSBubyBkZWRpY2F0ZWQgJ3Nob3J0SGVhZERpZENoYW5nZScgZXZlbnQuXG4gICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoJ2RpZC1jaGFuZ2Utc3RhdHVzZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCb29rbWFyaztcbiAgfVxuXG5cbiAgLyoqXG4gICAqXG4gICAqIFNlY3Rpb246IENoZWNraW5nIE91dFxuICAgKlxuICAgKi9cblxuICAvLyBUT0RPIFRoaXMgaXMgYSBzdHViLlxuICBjaGVja291dEhlYWQocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVE9ETyBUaGlzIGlzIGEgc3R1Yi5cbiAgY2hlY2tvdXRSZWZlcmVuY2UocmVmZXJlbmNlOiBzdHJpbmcsIGNyZWF0ZTogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBhc3luYyB2ZXJzaW9uIG9mIHdoYXQgY2hlY2tvdXRSZWZlcmVuY2UoKSBpcyBtZWFudCB0byBkby5cbiAgICovXG4gIGFzeW5jIGNoZWNrb3V0UmV2aXNpb24ocmVmZXJlbmNlOiBzdHJpbmcsIGNyZWF0ZTogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXJ2aWNlLmNoZWNrb3V0KHJlZmVyZW5jZSwgY3JlYXRlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqXG4gICAqIFNlY3Rpb246IEhnU2VydmljZSBzdWJzY3JpcHRpb25zXG4gICAqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYWNoZSBpbiByZXNwb25zZSB0byBhbnkgbnVtYmVyIG9mIChub24tLmhnaWdub3JlKSBmaWxlcyBjaGFuZ2luZy5cbiAgICogQHBhcmFtIHVwZGF0ZSBUaGUgY2hhbmdlZCBmaWxlIHBhdGhzLlxuICAgKi9cbiAgX2ZpbGVzRGlkQ2hhbmdlKGNoYW5nZWRQYXRoczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgIHZhciByZWxldmFudENoYW5nZWRQYXRocyA9IGNoYW5nZWRQYXRocy5maWx0ZXIodGhpcy5faXNQYXRoUmVsZXZhbnQuYmluZCh0aGlzKSk7XG4gICAgaWYgKHJlbGV2YW50Q2hhbmdlZFBhdGhzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzZXMocmVsZXZhbnRDaGFuZ2VkUGF0aHMsIHtoZ1N0YXR1c09wdGlvbjogSGdTdGF0dXNPcHRpb24uQUxMX1NUQVRVU0VTfSk7XG4gICAgICByZWxldmFudENoYW5nZWRQYXRocy5mb3JFYWNoKChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faGdEaWZmQ2FjaGVbZmlsZVBhdGhdKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlRGlmZkluZm8oZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfcmVmcmVzaFN0YXR1c2VzT2ZBbGxGaWxlc0luQ2FjaGUoKSB7XG4gICAgdmFyIHBhdGhzSW5TdGF0dXNDYWNoZSA9IE9iamVjdC5rZXlzKHRoaXMuX2hnU3RhdHVzQ2FjaGUpO1xuICAgIHRoaXMuX2hnU3RhdHVzQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9tb2RpZmllZERpcmVjdG9yeUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIGlmIChwYXRoc0luU3RhdHVzQ2FjaGUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0dXNlcyhwYXRoc0luU3RhdHVzQ2FjaGUsIHtoZ1N0YXR1c09wdGlvbjogSGdTdGF0dXNPcHRpb24uQUxMX1NUQVRVU0VTfSk7XG4gICAgfVxuXG4gICAgdmFyIHBhdGhzSW5EaWZmQ2FjaGUgPSBPYmplY3Qua2V5cyh0aGlzLl9oZ0RpZmZDYWNoZSk7XG4gICAgdGhpcy5faGdEaWZmQ2FjaGUgPSB7fTtcbiAgICBpZiAocGF0aHNJbkRpZmZDYWNoZS5sZW5ndGgpIHtcbiAgICAgIHBhdGhzSW5EaWZmQ2FjaGUuZm9yRWFjaCgoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlmZkluZm8oZmlsZVBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFNlY3Rpb246IFJlcG9zaXRvcnkgU3RhdGUgYXQgU3BlY2lmaWMgUmV2aXNpb25zXG4gICAqXG4gICAqL1xuICBmZXRjaEZpbGVDb250ZW50QXRSZXZpc2lvbihmaWxlUGF0aDogTnVjbGlkZVVyaSwgcmV2aXNpb246IHN0cmluZyk6IFByb21pc2U8P3N0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLmZldGNoRmlsZUNvbnRlbnRBdFJldmlzaW9uKGZpbGVQYXRoLCByZXZpc2lvbik7XG4gIH1cblxuICBmZXRjaEZpbGVzQ2hhbmdlZEF0UmV2aXNpb24ocmV2aXNpb246IHN0cmluZyk6IFByb21pc2U8P1JldmlzaW9uRmlsZUNoYW5nZXM+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZS5mZXRjaEZpbGVzQ2hhbmdlZEF0UmV2aXNpb24ocmV2aXNpb24pO1xuICB9XG5cbiAgZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uKHJldmlzaW9uOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLmZldGNoQ29tbW9uQW5jZXN0b3JPZkhlYWRBbmRSZXZpc2lvbihyZXZpc2lvbik7XG4gIH1cblxuICBmZXRjaFJldmlzaW9uTnVtYmVyc0JldHdlZW5SZXZpc2lvbnMocmV2aXNpb25Gcm9tOiBzdHJpbmcsIHJldmlzaW9uVG86IHN0cmluZyk6IFByb21pc2U8QXJyYXk8c3RyaW5nPj4ge1xuICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlLmZldGNoUmV2aXNpb25OdW1iZXJzQmV0d2VlblJldmlzaW9ucyhyZXZpc2lvbkZyb20sIHJldmlzaW9uVG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHdyYXBwaW5nIGBmZXRjaFJldmlzaW9uTnVtYmVyc0JldHdlZW5SZXZpc2lvbnNgLlxuICAgKi9cbiAgZmV0Y2hSZXZpc2lvbk51bWJlcnNCZXR3ZWVuUmV2aXNpb25BbmRIZWFkKHJldmlzaW9uOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHN0cmluZz4+IHtcbiAgICB2YXIge2V4cHJlc3Npb25Gb3JSZXZpc2lvbnNCZWZvcmVIZWFkfSA9IHJlcXVpcmUoJ251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlJykucmV2aXNpb25zO1xuICAgIHJldHVybiB0aGlzLmZldGNoUmV2aXNpb25OdW1iZXJzQmV0d2VlblJldmlzaW9ucyhyZXZpc2lvbiwgZXhwcmVzc2lvbkZvclJldmlzaW9uc0JlZm9yZUhlYWQoMCkpO1xuICB9XG5cbiAgZ2V0U21hcnRsb2codHR5T3V0cHV0OiBib29sZWFuLCBjb25jaXNlOiBib29sZWFuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZS5nZXRTbWFydGxvZyh0dHlPdXRwdXQsIGNvbmNpc2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGdSZXBvc2l0b3J5Q2xpZW50O1xuIl19
