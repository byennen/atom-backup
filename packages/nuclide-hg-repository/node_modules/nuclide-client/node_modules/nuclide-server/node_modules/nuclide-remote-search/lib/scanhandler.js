

/**
 * Searches for all instances of a pattern in a directory.
 * @param directory - The directory in which to perform a search.
 * @param regex - The pattern to match.
 * @param onFileMatchesUpdate - An optional callback, invoked whenever new matches are found.
 *  The results are cumulative, so each invokation also contains all the previous matches
 *  in the file.
 * @param caseSensitive - True if the grep search should be performed case sensitively.
 * @param subdirs - An array of subdirectories to search within `directory`. If subdirs is an
    empty array, then simply search in directory.
 * @returns A promise resolving to an array of all matches, grouped by file.
 */

var search = _asyncToGenerator(function* (directory, regex, onFileMatchesUpdate, caseSensitive, subdirs) {
  // Matches are stored in a Map of filename => Array<Match>.
  var matchesByFile = new Map();

  if (!subdirs || subdirs.length === 0) {
    // Since no subdirs were specified, run search on the root directory.
    yield searchInSubdir(matchesByFile, directory, '.', regex, onFileMatchesUpdate, caseSensitive);
  } else {
    // Run the search on each subdirectory that exists.
    yield Promise.all(subdirs.map(_asyncToGenerator(function* (subdir) {
      try {
        var stat = yield fsPromise.lstat(path.join(directory, subdir));
      } catch (e) {
        return;
      }

      if (!stat.isDirectory()) {
        return;
      }

      return searchInSubdir(matchesByFile, directory, subdir, regex, onFileMatchesUpdate, caseSensitive);
    })));
  }

  // Return final results.
  var results = [];
  matchesByFile.forEach(function (matches, filePath) {
    results.push({ matches: matches, filePath: filePath });
  });
  return results;
}

// Helper function that runs the search command on the given directory
// `subdir`, relative to `directory`. The function returns a promise
// that resolves when the command is done.
);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

'use babel';

var path = require('path');

var _require = require('nuclide-commons');

var safeSpawn = _require.safeSpawn;
var fsPromise = _require.fsPromise;

var split = require('split');

// This pattern is used for parsing the output of grep.
var GREP_PARSE_PATTERN = /(.*):(\d*):(.*)/;

function searchInSubdir(matchesByFile, directory, subdir, regex, onFileMatchesUpdate, caseSensitive) {

  // Callback invoked on each output line from the grep process.
  var onLine = function onLine(line) {
    // Try to parse the output of grep.
    var grepMatchResult = line.match(GREP_PARSE_PATTERN);
    if (!grepMatchResult) {
      return;
    }

    // Extract the filename, line number, and line text from grep output.
    var lineText = grepMatchResult[3];
    var lineNo = parseInt(grepMatchResult[2], 10) - 1;
    var filePath = path.join(subdir, grepMatchResult[1]);

    // Try to extract the actual "matched" text.
    var matchTextResult = new RegExp(regex, caseSensitive ? '' : 'i').exec(lineText);
    if (!matchTextResult) {
      return;
    }
    var matchText = matchTextResult[0];
    var matchIndex = matchTextResult.index;

    // Put this match into lists grouped by files.
    if (!matchesByFile.has(filePath)) {
      matchesByFile.set(filePath, []);
    }
    matchesByFile.get(filePath).push({
      lineText: lineText,
      lineTextOffset: 0,
      matchText: matchText,
      range: [[lineNo, matchIndex], [lineNo, matchIndex + matchText.length]]
    });

    // If a callback was provided, invoke it with the newest update.
    if (onFileMatchesUpdate) {
      onFileMatchesUpdate({
        matches: matchesByFile.get(filePath),
        filePath: filePath
      });
    }
  };

  // Try running search commands, falling through to the next if there is an error.
  var vcsargs = (caseSensitive ? [] : ['-i']).concat(['-n', regex]);
  var grepargs = (caseSensitive ? [] : ['-i']).concat(['-rHn', '-e', regex, '.']);

  var cmdDir = path.join(directory, subdir);
  return getLinesFromCommand('hg', ['wgrep'].concat(vcsargs), cmdDir, onLine)['catch'](function () {
    return getLinesFromCommand('git', ['grep'].concat(vcsargs), cmdDir, onLine);
  })['catch'](function () {
    return getLinesFromCommand('grep', grepargs, cmdDir, onLine);
  })['catch'](function () {
    throw new Error('Failed to execute a grep search.');
  });
}

// Helper function that runs a command in a given directory, invoking a callback
// as each line is written to stdout.
function getLinesFromCommand(command, args, localDirectoryPath, onLine) {

  return new Promise(function (resolve, reject) {
    // Spawn the search command in the given directory.
    var proc = safeSpawn(command, args, { cwd: localDirectoryPath });

    proc.on('error', reject); // Reject on error.
    proc.stdout.pipe(split()).on('data', onLine); // Call the callback on each line.

    // Keep a running string of stderr, in case we need to throw an error.
    var stderr = '';
    proc.stderr.on('data', function (data) {
      stderr += data;
    });

    // Resolve promise if error code is 0 (found matches) or 1 (found no matches). Otherwise reject.
    proc.on('close', function (code) {
      if (code > 1) {
        reject(new Error(stderr));
      } else {
        resolve();
      }
    });
  });
}

module.exports = {
  search: search
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1zZWFyY2gvbGliL3NjYW5oYW5kbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQWtDZSxNQUFNLHFCQUFyQixXQUNFLFNBQWlCLEVBQ2pCLEtBQWEsRUFDYixtQkFBK0MsRUFDL0MsYUFBc0IsRUFDdEIsT0FBc0IsRUFDZTs7QUFFckMsTUFBSSxhQUErQyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7O0FBRWhFLE1BQUcsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRW5DLFVBQU0sY0FBYyxDQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFDdkQsbUJBQW1CLEVBQUUsYUFBYSxDQUFDLENBQUM7R0FDdkMsTUFBTTs7QUFFTCxVQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsbUJBQUMsV0FBTSxNQUFNLEVBQUk7QUFDNUMsVUFBSTtBQUNGLFlBQUksSUFBSSxHQUFHLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQ2hFLENBQUMsT0FBTSxDQUFDLEVBQUU7QUFDVCxlQUFPO09BQ1I7O0FBRUQsVUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRTtBQUN2QixlQUFPO09BQ1I7O0FBRUQsYUFBTyxjQUFjLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUMzRCxtQkFBbUIsRUFBRSxhQUFhLENBQUMsQ0FBQztLQUN2QyxFQUFDLENBQUMsQ0FBQztHQUNMOzs7QUFHRCxNQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDakIsZUFBYSxDQUFD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LFlBQU0sSUFBSSxJQUFJLENBQUM7S0FDaEIsQ0FBQyxDQUFDOzs7QUFHSCxRQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFBLElBQUksRUFBSTtBQUN2QixVQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7QUFDWixjQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztPQUMzQixNQUFNO0FBQ0wsZUFBTyxFQUFFLENBQUM7T0FDWDtLQUNGLENBQUMsQ0FBQztHQUNKLENBQUMsQ0FBQztDQUNKOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixRQUFNLEVBQU4sTUFBTTtDQUNQLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtcmVtb3RlLXNlYXJjaC9saWIvc2NhbmhhbmRsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7c2VhcmNoJEZpbGVSZXN1bHQsIHNlYXJjaCRNYXRjaH0gZnJvbSAnLi90eXBlcyc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHtzYWZlU3Bhd24sIGZzUHJvbWlzZX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbnZhciBzcGxpdCA9IHJlcXVpcmUoJ3NwbGl0Jyk7XG5cbi8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgZ3JlcC5cbnZhciBHUkVQX1BBUlNFX1BBVFRFUk4gPSAvKC4qKTooXFxkKik6KC4qKS87XG5cbnR5cGUgVXBkYXRlRmlsZU1hdGNoZXNDYWxsYmFjayA9IChyZXN1bHQ6IHNlYXJjaCRGaWxlUmVzdWx0KSA9PiB2b2lkO1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBhbGwgaW5zdGFuY2VzIG9mIGEgcGF0dGVybiBpbiBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBkaXJlY3RvcnkgLSBUaGUgZGlyZWN0b3J5IGluIHdoaWNoIHRvIHBlcmZvcm0gYSBzZWFyY2guXG4gKiBAcGFyYW0gcmVnZXggLSBUaGUgcGF0dGVybiB0byBtYXRjaC5cbiAqIEBwYXJhbSBvbkZpbGVNYXRjaGVzVXBkYXRlIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2ssIGludm9rZWQgd2hlbmV2ZXIgbmV3IG1hdGNoZXMgYXJlIGZvdW5kLlxuICogIFRoZSByZXN1bHRzIGFyZSBjdW11bGF0aXZlLCBzbyBlYWNoIGludm9rYXRpb24gYWxzbyBjb250YWlucyBhbGwgdGhlIHByZXZpb3VzIG1hdGNoZXNcbiAqICBpbiB0aGUgZmlsZS5cbiAqIEBwYXJhbSBjYXNlU2Vuc2l0aXZlIC0gVHJ1ZSBpZiB0aGUgZ3JlcCBzZWFyY2ggc2hvdWxkIGJlIHBlcmZvcm1lZCBjYXNlIHNlbnNpdGl2ZWx5LlxuICogQHBhcmFtIHN1YmRpcnMgLSBBbiBhcnJheSBvZiBzdWJkaXJlY3RvcmllcyB0byBzZWFyY2ggd2l0aGluIGBkaXJlY3RvcnlgLiBJZiBzdWJkaXJzIGlzIGFuXG4gICAgZW1wdHkgYXJyYXksIHRoZW4gc2ltcGx5IHNlYXJjaCBpbiBkaXJlY3RvcnkuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGFsbCBtYXRjaGVzLCBncm91cGVkIGJ5IGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlYXJjaChcbiAgZGlyZWN0b3J5OiBzdHJpbmcsXG4gIHJlZ2V4OiBzdHJpbmcsXG4gIG9uRmlsZU1hdGNoZXNVcGRhdGU6ID9VcGRhdGVGaWxlTWF0Y2hlc0NhbGxiYWNrLFxuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuLFxuICBzdWJkaXJzOiBBcnJheTxzdHJpbmc+XG4gICk6IFByb21pc2U8QXJyYXk8c2VhcmNoJEZpbGVSZXN1bHQ+PiB7XG4gIC8vIE1hdGNoZXMgYXJlIHN0b3JlZCBpbiBhIE1hcCBvZiBmaWxlbmFtZSA9PiBBcnJheTxNYXRjaD4uXG4gIHZhciBtYXRjaGVzQnlGaWxlOiBNYXA8c3RyaW5nLCBBcnJheTxzZWFyY2gkTWF0Y2g+PiA9IG5ldyBNYXAoKTtcblxuICBpZighc3ViZGlycyB8fCBzdWJkaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNpbmNlIG5vIHN1YmRpcnMgd2VyZSBzcGVjaWZpZWQsIHJ1biBzZWFyY2ggb24gdGhlIHJvb3QgZGlyZWN0b3J5LlxuICAgIGF3YWl0IHNlYXJjaEluU3ViZGlyKG1hdGNoZXNCeUZpbGUsIGRpcmVjdG9yeSwgJy4nLCByZWdleCxcbiAgICAgIG9uRmlsZU1hdGNoZXNVcGRhdGUsIGNhc2VTZW5zaXRpdmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJ1biB0aGUgc2VhcmNoIG9uIGVhY2ggc3ViZGlyZWN0b3J5IHRoYXQgZXhpc3RzLlxuICAgIGF3YWl0IFByb21pc2UuYWxsKHN1YmRpcnMubWFwKGFzeW5jIHN1YmRpciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RhdCA9IGF3YWl0IGZzUHJvbWlzZS5sc3RhdChwYXRoLmpvaW4oZGlyZWN0b3J5LCBzdWJkaXIpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlYXJjaEluU3ViZGlyKG1hdGNoZXNCeUZpbGUsIGRpcmVjdG9yeSwgc3ViZGlyLCByZWdleCxcbiAgICAgICAgb25GaWxlTWF0Y2hlc1VwZGF0ZSwgY2FzZVNlbnNpdGl2ZSk7XG4gICAgfSkpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGZpbmFsIHJlc3VsdHMuXG4gIHZhciByZXN1bHRzID0gW107XG4gIG1hdGNoZXNCeUZpbGUuZm9yRWFjaCgobWF0Y2hlcywgZmlsZVBhdGgpID0+IHsgcmVzdWx0cy5wdXNoKHttYXRjaGVzLCBmaWxlUGF0aH0pIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgcnVucyB0aGUgc2VhcmNoIGNvbW1hbmQgb24gdGhlIGdpdmVuIGRpcmVjdG9yeVxuLy8gYHN1YmRpcmAsIHJlbGF0aXZlIHRvIGBkaXJlY3RvcnlgLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2Vcbi8vIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29tbWFuZCBpcyBkb25lLlxuZnVuY3Rpb24gc2VhcmNoSW5TdWJkaXIoXG4gIG1hdGNoZXNCeUZpbGU6IE1hcDxzdHJpbmcsIEFycmF5PHNlYXJjaCRNYXRjaD4+LFxuICBkaXJlY3Rvcnk6IHN0cmluZyxcbiAgc3ViZGlyOiBzdHJpbmcsXG4gIHJlZ2V4OiBzdHJpbmcsXG4gIG9uRmlsZU1hdGNoZXNVcGRhdGU6ID9VcGRhdGVGaWxlTWF0Y2hlc0NhbGxiYWNrLFxuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuKSB7XG5cbiAgLy8gQ2FsbGJhY2sgaW52b2tlZCBvbiBlYWNoIG91dHB1dCBsaW5lIGZyb20gdGhlIGdyZXAgcHJvY2Vzcy5cbiAgdmFyIG9uTGluZSA9IGxpbmUgPT4ge1xuICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGdyZXAuXG4gICAgdmFyIGdyZXBNYXRjaFJlc3VsdCA9IGxpbmUubWF0Y2goR1JFUF9QQVJTRV9QQVRURVJOKTtcbiAgICBpZiAoIWdyZXBNYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgdGhlIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kIGxpbmUgdGV4dCBmcm9tIGdyZXAgb3V0cHV0LlxuICAgIHZhciBsaW5lVGV4dCA9IGdyZXBNYXRjaFJlc3VsdFszXTtcbiAgICB2YXIgbGluZU5vID0gcGFyc2VJbnQoZ3JlcE1hdGNoUmVzdWx0WzJdLCAxMCkgLSAxO1xuICAgIHZhciBmaWxlUGF0aCA9IHBhdGguam9pbihzdWJkaXIsIGdyZXBNYXRjaFJlc3VsdFsxXSk7XG5cbiAgICAvLyBUcnkgdG8gZXh0cmFjdCB0aGUgYWN0dWFsIFwibWF0Y2hlZFwiIHRleHQuXG4gICAgdmFyIG1hdGNoVGV4dFJlc3VsdCA9IG5ldyBSZWdFeHAocmVnZXgsIGNhc2VTZW5zaXRpdmUgPyAnJyA6ICdpJykuZXhlYyhsaW5lVGV4dCk7XG4gICAgaWYgKCFtYXRjaFRleHRSZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1hdGNoVGV4dCA9IG1hdGNoVGV4dFJlc3VsdFswXTtcbiAgICB2YXIgbWF0Y2hJbmRleCA9IG1hdGNoVGV4dFJlc3VsdC5pbmRleDtcblxuICAgIC8vIFB1dCB0aGlzIG1hdGNoIGludG8gbGlzdHMgZ3JvdXBlZCBieSBmaWxlcy5cbiAgICBpZiAoIW1hdGNoZXNCeUZpbGUuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgbWF0Y2hlc0J5RmlsZS5zZXQoZmlsZVBhdGgsIFtdKTtcbiAgICB9XG4gICAgbWF0Y2hlc0J5RmlsZS5nZXQoZmlsZVBhdGgpLnB1c2goe1xuICAgICAgbGluZVRleHQsXG4gICAgICBsaW5lVGV4dE9mZnNldDogMCxcbiAgICAgIG1hdGNoVGV4dCxcbiAgICAgIHJhbmdlOiBbW2xpbmVObywgbWF0Y2hJbmRleF0sIFtsaW5lTm8sIG1hdGNoSW5kZXggKyBtYXRjaFRleHQubGVuZ3RoXV0sXG4gICAgfSk7XG5cbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgaW52b2tlIGl0IHdpdGggdGhlIG5ld2VzdCB1cGRhdGUuXG4gICAgaWYgKG9uRmlsZU1hdGNoZXNVcGRhdGUpIHtcbiAgICAgIG9uRmlsZU1hdGNoZXNVcGRhdGUoe1xuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzQnlGaWxlLmdldChmaWxlUGF0aCksXG4gICAgICAgIGZpbGVQYXRoLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRyeSBydW5uaW5nIHNlYXJjaCBjb21tYW5kcywgZmFsbGluZyB0aHJvdWdoIHRvIHRoZSBuZXh0IGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICB2YXIgdmNzYXJncyA9IChjYXNlU2Vuc2l0aXZlID8gW10gOiBbJy1pJ10pLmNvbmNhdChbJy1uJywgcmVnZXhdKTtcbiAgdmFyIGdyZXBhcmdzID0gKGNhc2VTZW5zaXRpdmUgPyBbXSA6ICBbJy1pJ10pLmNvbmNhdChbJy1ySG4nLCAnLWUnLCByZWdleCwgJy4nXSk7XG5cbiAgdmFyIGNtZERpciA9IHBhdGguam9pbihkaXJlY3RvcnksIHN1YmRpcik7XG4gIHJldHVybiBnZXRMaW5lc0Zyb21Db21tYW5kKCdoZycsIFsnd2dyZXAnXS5jb25jYXQodmNzYXJncyksIGNtZERpciwgb25MaW5lKVxuICAgIC5jYXRjaCgoKSA9PiBnZXRMaW5lc0Zyb21Db21tYW5kKCdnaXQnLCBbJ2dyZXAnXS5jb25jYXQodmNzYXJncyksIGNtZERpciwgb25MaW5lKSlcbiAgICAuY2F0Y2goKCkgPT4gZ2V0TGluZXNGcm9tQ29tbWFuZCgnZ3JlcCcsIGdyZXBhcmdzLCBjbWREaXIsIG9uTGluZSkpXG4gICAgLmNhdGNoKCgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBhIGdyZXAgc2VhcmNoLicpfSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJ1bnMgYSBjb21tYW5kIGluIGEgZ2l2ZW4gZGlyZWN0b3J5LCBpbnZva2luZyBhIGNhbGxiYWNrXG4vLyBhcyBlYWNoIGxpbmUgaXMgd3JpdHRlbiB0byBzdGRvdXQuXG5mdW5jdGlvbiBnZXRMaW5lc0Zyb21Db21tYW5kKGNvbW1hbmQ6IHN0cmluZyxcbiAgYXJnczogQXJyYXk8c3RyaW5nPixcbiAgbG9jYWxEaXJlY3RvcnlQYXRoOiBzdHJpbmcsXG4gIG9uTGluZTogPyhsaW5lOiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIFNwYXduIHRoZSBzZWFyY2ggY29tbWFuZCBpbiB0aGUgZ2l2ZW4gZGlyZWN0b3J5LlxuICAgIHZhciBwcm9jID0gc2FmZVNwYXduKGNvbW1hbmQsIGFyZ3MsIHsgY3dkOiBsb2NhbERpcmVjdG9yeVBhdGggfSk7XG5cbiAgICBwcm9jLm9uKCdlcnJvcicsIHJlamVjdCk7IC8vIFJlamVjdCBvbiBlcnJvci5cbiAgICBwcm9jLnN0ZG91dC5waXBlKHNwbGl0KCkpLm9uKCdkYXRhJywgb25MaW5lKTsgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgb24gZWFjaCBsaW5lLlxuXG4gICAgLy8gS2VlcCBhIHJ1bm5pbmcgc3RyaW5nIG9mIHN0ZGVyciwgaW4gY2FzZSB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICAgIHZhciBzdGRlcnIgPSAnJztcbiAgICBwcm9jLnN0ZGVyci5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgc3RkZXJyICs9IGRhdGE7XG4gICAgfSk7XG5cbiAgICAvLyBSZXNvbHZlIHByb21pc2UgaWYgZXJyb3IgY29kZSBpcyAwIChmb3VuZCBtYXRjaGVzKSBvciAxIChmb3VuZCBubyBtYXRjaGVzKS4gT3RoZXJ3aXNlIHJlamVjdC5cbiAgICBwcm9jLm9uKCdjbG9zZScsIGNvZGUgPT4ge1xuICAgICAgaWYgKGNvZGUgPiAxKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3Ioc3RkZXJyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2VhcmNoLFxufTtcbiJdfQ==
