
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * Verifies that a Promise fails with an Error with specific expectations. When
 * running a test where a Promise is expected to fail, it is important to verify
 * that it failed in the expected way to avoid false positives in test results.
 *
 * This function should be used with `await` inside `waitsForPromise()`.
 *
 * @param promise will be awaited. It is expected to reject. If it does not
 *     reject, then this function will return a rejected Promise.
 * @param verify should confirm expectations about the Error produced by the
 *     rejection of `promise`. If these expectations are not met, then
 *     `verify()` must throw an exception.
 */

var expectAsyncFailure = _asyncToGenerator(function* (promise, verify) {
  try {
    yield promise;
    return Promise.reject('Promise should have failed, but did not.');
  } catch (e) {
    verify(e);
  }
}

/**
  * This is useful for mocking a module that the module under test requires.
  * After setting up the mocks, you must invalidate the require cache and then
  * re-require the module under test so that it picks up the mocked
  * dependencies.
  *
  * The require parameter is needed because require is bound differently in each
  * file, and we need to execute this in the caller's context.
  */
);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function clearRequireCache(require, module) {
  delete require.cache[require.resolve(module)];
}

function uncachedRequire(require, module) {
  clearRequireCache(require, module);
  return require(module);
}

/**
 * Jasmine has trouble spying on properties supplied by getters, so to make it
 * work we have to get the value, delete the getter, and set the value as a
 * property.
 *
 * This makes two assumptions:
 * - The getter is idempotent (otherwise, callers in other tests might be
 *   surprised when the value here is returned)
 * - The getter returns a function (otherwise, it doesn't make sense to spy on
 *   it)
 */
function spyOnGetterValue(object, f) {
  var value = object[f];
  delete object[f];
  object[f] = value;
  return spyOn(object, f);
}

module.exports = {
  spyOnGetterValue: spyOnGetterValue,
  uncachedRequire: uncachedRequire,
  clearRequireCache: clearRequireCache,
  expectAsyncFailure: expectAsyncFailure,
  matchers: require('./matchers')
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXRlc3QtaGVscGVycy9saWIvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdCRyxrQkFBa0IscUJBQWpDLFdBQ0ksT0FBZ0IsRUFDaEIsTUFBOEIsRUFBVztBQUMzQyxNQUFJO0FBQ0YsVUFBTSxPQUFPLENBQUM7QUFDZCxXQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsMENBQTBDLENBQUMsQ0FBQztHQUNuRSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsVUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ1g7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7O0FBV0QsU0FBUyxpQkFBaUIsQ0FBQyxPQUFlLEVBQUUsTUFBYyxFQUFRO0FBQ2hFLFNBQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Q0FDL0M7O0FBRUQsU0FBUyxlQUFlLENBQUMsT0FBZSxFQUFFLE1BQWMsRUFBUztBQUMvRCxtQkFBaUIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbkMsU0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDeEI7Ozs7Ozs7Ozs7Ozs7QUFhRCxTQUFTLGdCQUFnQixDQUFDLE1BQWMsRUFBRSxDQUFTLEVBQUU7QUFDbkQsTUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFNBQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pCLFFBQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDbEIsU0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3pCOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixrQkFBZ0IsRUFBaEIsZ0JBQWdCO0FBQ2hCLGlCQUFlLEVBQWYsZUFBZTtBQUNmLG1CQUFpQixFQUFqQixpQkFBaUI7QUFDakIsb0JBQWtCLEVBQWxCLGtCQUFrQjtBQUNsQixVQUFRLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQztDQUNoQyxDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXRlc3QtaGVscGVycy9saWIvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIFByb21pc2UgZmFpbHMgd2l0aCBhbiBFcnJvciB3aXRoIHNwZWNpZmljIGV4cGVjdGF0aW9ucy4gV2hlblxuICogcnVubmluZyBhIHRlc3Qgd2hlcmUgYSBQcm9taXNlIGlzIGV4cGVjdGVkIHRvIGZhaWwsIGl0IGlzIGltcG9ydGFudCB0byB2ZXJpZnlcbiAqIHRoYXQgaXQgZmFpbGVkIGluIHRoZSBleHBlY3RlZCB3YXkgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGluIHRlc3QgcmVzdWx0cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHdpdGggYGF3YWl0YCBpbnNpZGUgYHdhaXRzRm9yUHJvbWlzZSgpYC5cbiAqXG4gKiBAcGFyYW0gcHJvbWlzZSB3aWxsIGJlIGF3YWl0ZWQuIEl0IGlzIGV4cGVjdGVkIHRvIHJlamVjdC4gSWYgaXQgZG9lcyBub3RcbiAqICAgICByZWplY3QsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHJlamVjdGVkIFByb21pc2UuXG4gKiBAcGFyYW0gdmVyaWZ5IHNob3VsZCBjb25maXJtIGV4cGVjdGF0aW9ucyBhYm91dCB0aGUgRXJyb3IgcHJvZHVjZWQgYnkgdGhlXG4gKiAgICAgcmVqZWN0aW9uIG9mIGBwcm9taXNlYC4gSWYgdGhlc2UgZXhwZWN0YXRpb25zIGFyZSBub3QgbWV0LCB0aGVuXG4gKiAgICAgYHZlcmlmeSgpYCBtdXN0IHRocm93IGFuIGV4Y2VwdGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhwZWN0QXN5bmNGYWlsdXJlKFxuICAgIHByb21pc2U6IFByb21pc2UsXG4gICAgdmVyaWZ5OiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkKTogUHJvbWlzZSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgcHJvbWlzZTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1Byb21pc2Ugc2hvdWxkIGhhdmUgZmFpbGVkLCBidXQgZGlkIG5vdC4nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZlcmlmeShlKTtcbiAgfVxufVxuXG4vKipcbiAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9ja2luZyBhIG1vZHVsZSB0aGF0IHRoZSBtb2R1bGUgdW5kZXIgdGVzdCByZXF1aXJlcy5cbiAgKiBBZnRlciBzZXR0aW5nIHVwIHRoZSBtb2NrcywgeW91IG11c3QgaW52YWxpZGF0ZSB0aGUgcmVxdWlyZSBjYWNoZSBhbmQgdGhlblxuICAqIHJlLXJlcXVpcmUgdGhlIG1vZHVsZSB1bmRlciB0ZXN0IHNvIHRoYXQgaXQgcGlja3MgdXAgdGhlIG1vY2tlZFxuICAqIGRlcGVuZGVuY2llcy5cbiAgKlxuICAqIFRoZSByZXF1aXJlIHBhcmFtZXRlciBpcyBuZWVkZWQgYmVjYXVzZSByZXF1aXJlIGlzIGJvdW5kIGRpZmZlcmVudGx5IGluIGVhY2hcbiAgKiBmaWxlLCBhbmQgd2UgbmVlZCB0byBleGVjdXRlIHRoaXMgaW4gdGhlIGNhbGxlcidzIGNvbnRleHQuXG4gICovXG5mdW5jdGlvbiBjbGVhclJlcXVpcmVDYWNoZShyZXF1aXJlOiBPYmplY3QsIG1vZHVsZTogc3RyaW5nKTogdm9pZCB7XG4gIGRlbGV0ZSByZXF1aXJlLmNhY2hlW3JlcXVpcmUucmVzb2x2ZShtb2R1bGUpXTtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZWRSZXF1aXJlKHJlcXVpcmU6IE9iamVjdCwgbW9kdWxlOiBzdHJpbmcpOiBtaXhlZCB7XG4gIGNsZWFyUmVxdWlyZUNhY2hlKHJlcXVpcmUsIG1vZHVsZSk7XG4gIHJldHVybiByZXF1aXJlKG1vZHVsZSk7XG59XG5cbi8qKlxuICogSmFzbWluZSBoYXMgdHJvdWJsZSBzcHlpbmcgb24gcHJvcGVydGllcyBzdXBwbGllZCBieSBnZXR0ZXJzLCBzbyB0byBtYWtlIGl0XG4gKiB3b3JrIHdlIGhhdmUgdG8gZ2V0IHRoZSB2YWx1ZSwgZGVsZXRlIHRoZSBnZXR0ZXIsIGFuZCBzZXQgdGhlIHZhbHVlIGFzIGFcbiAqIHByb3BlcnR5LlxuICpcbiAqIFRoaXMgbWFrZXMgdHdvIGFzc3VtcHRpb25zOlxuICogLSBUaGUgZ2V0dGVyIGlzIGlkZW1wb3RlbnQgKG90aGVyd2lzZSwgY2FsbGVycyBpbiBvdGhlciB0ZXN0cyBtaWdodCBiZVxuICogICBzdXJwcmlzZWQgd2hlbiB0aGUgdmFsdWUgaGVyZSBpcyByZXR1cm5lZClcbiAqIC0gVGhlIGdldHRlciByZXR1cm5zIGEgZnVuY3Rpb24gKG90aGVyd2lzZSwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHNweSBvblxuICogICBpdClcbiAqL1xuZnVuY3Rpb24gc3B5T25HZXR0ZXJWYWx1ZShvYmplY3Q6IE9iamVjdCwgZjogc3RyaW5nKSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdFtmXTtcbiAgZGVsZXRlIG9iamVjdFtmXTtcbiAgb2JqZWN0W2ZdID0gdmFsdWU7XG4gIHJldHVybiBzcHlPbihvYmplY3QsIGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3B5T25HZXR0ZXJWYWx1ZSxcbiAgdW5jYWNoZWRSZXF1aXJlLFxuICBjbGVhclJlcXVpcmVDYWNoZSxcbiAgZXhwZWN0QXN5bmNGYWlsdXJlLFxuICBtYXRjaGVyczogcmVxdWlyZSgnLi9tYXRjaGVycycpLFxufTtcbiJdfQ==
