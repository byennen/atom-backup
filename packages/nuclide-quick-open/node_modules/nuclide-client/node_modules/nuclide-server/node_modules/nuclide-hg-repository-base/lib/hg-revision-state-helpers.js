

/**
 * @param revision A string representation of the revision desired. See
 * Mercurial documentation for ways to specify a revision.
 * @return The content of the filePath at the given revision. Returns null
 * if the operation fails for whatever reason, including invalid input (e.g. if
 * you pass an invalid revision).
 */

var fetchFilesChangedAtRevision = _asyncToGenerator(function* (revision, workingDirectory) {
  var args = ['log', '--template', REVISION_FILE_CHANGES_TEMPLATE, '--rev', revision];
  var execOptions = {
    cwd: workingDirectory
  };
  var output = yield hgAsyncExecute(args, execOptions);
  if (output) {
    output = parseRevisionFileChangeOutput(output, workingDirectory);
  }
  return output;
}

/**
 * @param output Raw output string from 'hg log' call in `fetchFilesChangedAtRevision`.
 * @param workingDirectory The absolute path to the working directory of the hg repository.
 * @return A RevisionFileChanges object where the paths are all absolute paths.
 */
);

var hgAsyncExecute = _asyncToGenerator(function* (args, execOptions) {
  try {
    var output = yield asyncExecute('hg', args, execOptions);
  } catch (e) {
    logger.error('Hg command: failed with error: ', e.stderr);
    return null;
  }
  return output.stdout;
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

'use babel';

var _require = require('nuclide-commons');

var asyncExecute = _require.asyncExecute;

var logger = require('nuclide-logging').getLogger();
var path = require('path');

var ALL_FILES_LABEL = 'files:';
var FILE_ADDS_LABEL = 'file-adds:';
var FILE_DELETES_LABEL = 'file-dels:';
var FILE_COPIES_LABEL = 'file-copies:';
var FILE_MODS_LABEL = 'file-mods:';
var REVISION_FILE_CHANGES_TEMPLATE = ALL_FILES_LABEL + ' {files}\n' + FILE_ADDS_LABEL + ' {file_adds}\n' + FILE_DELETES_LABEL + ' {file_dels}\n' + FILE_COPIES_LABEL + ' {file_copies}\n' + FILE_MODS_LABEL + ' {file_mods}';
// Regex for: "new_file (previous_file", with two capture groups, one for each file.
var COPIED_FILE_PAIR_REGEX = /(.+) \((.+)/;

/**
 * @param filePath An absolute path to a file.
 * @param revision A string representation of the revision desired. See
 * Mercurial documentation for ways to specify a revision.
 * @param The working directory (aka root directory) of the Hg repository.
 * @return The content of the filePath at the given revision. Returns null
 * if the operation fails for whatever reason, including invalid input (e.g. if
 * you pass a filePath that does not exist at the given revision).
 */
function fetchFileContentAtRevision(filePath, revision, workingDirectory) {
  var args = ['cat', filePath];
  if (revision) {
    args.splice(1, 0, '--rev', revision);
  }
  var execOptions = {
    cwd: workingDirectory
  };
  return hgAsyncExecute(args, execOptions);
}function parseRevisionFileChangeOutput(output, workingDirectory) {
  var lines = output.trim().split('\n');
  var allFiles = lines[0].slice(ALL_FILES_LABEL.length + 1).trim();
  allFiles = allFiles.length ? allFiles.split(' ') : [];
  allFiles = absolutizeAll(allFiles, workingDirectory);

  var addedFiles = lines[1].slice(FILE_ADDS_LABEL.length + 1).trim();
  addedFiles = addedFiles.length ? addedFiles.split(' ') : [];
  addedFiles = absolutizeAll(addedFiles, workingDirectory);

  var deletedFiles = lines[2].slice(FILE_DELETES_LABEL.length + 1).trim();
  deletedFiles = deletedFiles.length ? deletedFiles.split(' ') : [];
  deletedFiles = absolutizeAll(deletedFiles, workingDirectory);

  // Copied files are in the form: new_file (previous_file)new_file2 (previous_file2)[...]
  // There is no space between entries.
  var copiedFiles = lines[3].slice(FILE_COPIES_LABEL.length + 1).trim();
  copiedFiles = copiedFiles.length ? copiedFiles.split(')') : [];
  // We expect the string to end with a ')', so the last entry in copiedFiles will
  // be an empty string. Remove this.
  copiedFiles.pop();
  // Parse the lines, now in the form: new_file (previous_file)
  copiedFiles = copiedFiles.map(function (filePathPair) {
    var fileNameMatches = filePathPair.match(COPIED_FILE_PAIR_REGEX);
    if (fileNameMatches) {
      return {
        from: absolutize(fileNameMatches[2], workingDirectory),
        to: absolutize(fileNameMatches[1], workingDirectory)
      };
    }
  });

  var modifiedFiles = lines[4].slice(FILE_MODS_LABEL.length + 1).trim();
  modifiedFiles = modifiedFiles.length ? modifiedFiles.split(' ') : [];
  modifiedFiles = absolutizeAll(modifiedFiles, workingDirectory);

  return {
    all: allFiles,
    added: addedFiles,
    deleted: deletedFiles,
    copied: copiedFiles,
    modified: modifiedFiles
  };
}

function absolutize(filePath, workingDirectory) {
  return path.join(workingDirectory, filePath);
}

function absolutizeAll(filePaths, workingDirectory) {
  return filePaths.map(function (filePath) {
    return absolutize(filePath, workingDirectory);
  });
}

module.exports = {
  fetchFileContentAtRevision: fetchFileContentAtRevision,
  fetchFilesChangedAtRevision: fetchFilesChangedAtRevision,
  parseRevisionFileChangeOutput: parseRevisionFileChangeOutput };
// exposed for testing
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvaGctcmV2aXNpb24tc3RhdGUtaGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBMkRlLDJCQUEyQixxQkFBMUMsV0FBMkMsUUFBZ0IsRUFBRSxnQkFBd0IsRUFBaUM7QUFDcEgsTUFBSSxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLDhCQUE4QixFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNwRixNQUFJLFdBQVcsR0FBRztBQUNoQixPQUFHLEVBQUUsZ0JBQWdCO0dBQ3RCLENBQUM7QUFDRixNQUFJLE1BQU0sR0FBRyxNQUFNLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDckQsTUFBSSxNQUFNLEVBQUU7QUFDVixVQUFNLEdBQUcsNkJBQTZCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7R0FDbEU7QUFDRCxTQUFPLE1BQU0sQ0FBQztDQUNmOzs7Ozs7Ozs7SUFxRGMsY0FBYyxxQkFBN0IsV0FBOEIsSUFBbUIsRUFBRSxXQUFnQixFQUFnQjtBQUNqRixNQUFJO0FBQ0YsUUFBSSxNQUFNLEdBQUcsTUFBTSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztHQUMxRCxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsVUFBTSxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDMUQsV0FBTyxJQUFJLENBQUM7R0FDYjtBQUNELFNBQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztDQUN0Qjs7Ozs7Ozs7Ozs7O0FBbElELFdBQVcsQ0FBQzs7ZUFhUyxPQUFPLENBQUMsaUJBQWlCLENBQUM7O0lBQTFD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QSxDQUFDLENBQUM7Q0FDMUU7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLDRCQUEwQixFQUExQiwwQkFBMEI7QUFDMUIsNkJBQTJCLEVBQTNCLDJCQUEyQjtBQUMzQiwrQkFBNkIsRUFBN0IsNkJBQTZCLEVBQzlCLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlL2xpYi9oZy1yZXZpc2lvbi1zdGF0ZS1oZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHR5cGUge1JldmlzaW9uRmlsZUNoYW5nZXN9IGZyb20gXCJIZ0NvbnN0YW50c1wiO1xuXG52YXIge2FzeW5jRXhlY3V0ZX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgQUxMX0ZJTEVTX0xBQkVMID0gJ2ZpbGVzOic7XG52YXIgRklMRV9BRERTX0xBQkVMID0gJ2ZpbGUtYWRkczonO1xudmFyIEZJTEVfREVMRVRFU19MQUJFTCA9ICdmaWxlLWRlbHM6JztcbnZhciBGSUxFX0NPUElFU19MQUJFTCA9ICdmaWxlLWNvcGllczonO1xudmFyIEZJTEVfTU9EU19MQUJFTCA9ICdmaWxlLW1vZHM6JztcbnZhciBSRVZJU0lPTl9GSUxFX0NIQU5HRVNfVEVNUExBVEUgPVxuYCR7QUxMX0ZJTEVTX0xBQkVMfSB7ZmlsZXN9XG4ke0ZJTEVfQUREU19MQUJFTH0ge2ZpbGVfYWRkc31cbiR7RklMRV9ERUxFVEVTX0xBQkVMfSB7ZmlsZV9kZWxzfVxuJHtGSUxFX0NPUElFU19MQUJFTH0ge2ZpbGVfY29waWVzfVxuJHtGSUxFX01PRFNfTEFCRUx9IHtmaWxlX21vZHN9YDtcbi8vIFJlZ2V4IGZvcjogXCJuZXdfZmlsZSAocHJldmlvdXNfZmlsZVwiLCB3aXRoIHR3byBjYXB0dXJlIGdyb3Vwcywgb25lIGZvciBlYWNoIGZpbGUuXG52YXIgQ09QSUVEX0ZJTEVfUEFJUl9SRUdFWCA9IC8oLispIFxcKCguKykvO1xuXG5cbi8qKlxuICogQHBhcmFtIGZpbGVQYXRoIEFuIGFic29sdXRlIHBhdGggdG8gYSBmaWxlLlxuICogQHBhcmFtIHJldmlzaW9uIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXZpc2lvbiBkZXNpcmVkLiBTZWVcbiAqIE1lcmN1cmlhbCBkb2N1bWVudGF0aW9uIGZvciB3YXlzIHRvIHNwZWNpZnkgYSByZXZpc2lvbi5cbiAqIEBwYXJhbSBUaGUgd29ya2luZyBkaXJlY3RvcnkgKGFrYSByb290IGRpcmVjdG9yeSkgb2YgdGhlIEhnIHJlcG9zaXRvcnkuXG4gKiBAcmV0dXJuIFRoZSBjb250ZW50IG9mIHRoZSBmaWxlUGF0aCBhdCB0aGUgZ2l2ZW4gcmV2aXNpb24uIFJldHVybnMgbnVsbFxuICogaWYgdGhlIG9wZXJhdGlvbiBmYWlscyBmb3Igd2hhdGV2ZXIgcmVhc29uLCBpbmNsdWRpbmcgaW52YWxpZCBpbnB1dCAoZS5nLiBpZlxuICogeW91IHBhc3MgYSBmaWxlUGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0IGF0IHRoZSBnaXZlbiByZXZpc2lvbikuXG4gKi9cbmZ1bmN0aW9uIGZldGNoRmlsZUNvbnRlbnRBdFJldmlzaW9uKGZpbGVQYXRoOiBOdWNsaWRlVXJpLCByZXZpc2lvbjogP3N0cmluZywgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKTogUHJvbWlzZTw/c3RyaW5nPiB7XG4gIHZhciBhcmdzID0gWydjYXQnLCBmaWxlUGF0aF07XG4gIGlmIChyZXZpc2lvbikge1xuICAgIGFyZ3Muc3BsaWNlKDEsIDAsICctLXJldicsIHJldmlzaW9uKTtcbiAgfVxuICB2YXIgZXhlY09wdGlvbnMgPSB7XG4gICAgY3dkOiB3b3JraW5nRGlyZWN0b3J5LFxuICB9O1xuICByZXR1cm4gaGdBc3luY0V4ZWN1dGUoYXJncywgZXhlY09wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSByZXZpc2lvbiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmV2aXNpb24gZGVzaXJlZC4gU2VlXG4gKiBNZXJjdXJpYWwgZG9jdW1lbnRhdGlvbiBmb3Igd2F5cyB0byBzcGVjaWZ5IGEgcmV2aXNpb24uXG4gKiBAcmV0dXJuIFRoZSBjb250ZW50IG9mIHRoZSBmaWxlUGF0aCBhdCB0aGUgZ2l2ZW4gcmV2aXNpb24uIFJldHVybnMgbnVsbFxuICogaWYgdGhlIG9wZXJhdGlvbiBmYWlscyBmb3Igd2hhdGV2ZXIgcmVhc29uLCBpbmNsdWRpbmcgaW52YWxpZCBpbnB1dCAoZS5nLiBpZlxuICogeW91IHBhc3MgYW4gaW52YWxpZCByZXZpc2lvbikuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRmlsZXNDaGFuZ2VkQXRSZXZpc2lvbihyZXZpc2lvbjogc3RyaW5nLCB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcpOiBQcm9taXNlPD9SZXZpc2lvbkZpbGVDaGFuZ2VzPiB7XG4gIHZhciBhcmdzID0gWydsb2cnLCAnLS10ZW1wbGF0ZScsIFJFVklTSU9OX0ZJTEVfQ0hBTkdFU19URU1QTEFURSwgJy0tcmV2JywgcmV2aXNpb25dO1xuICB2YXIgZXhlY09wdGlvbnMgPSB7XG4gICAgY3dkOiB3b3JraW5nRGlyZWN0b3J5LFxuICB9O1xuICB2YXIgb3V0cHV0ID0gYXdhaXQgaGdBc3luY0V4ZWN1dGUoYXJncywgZXhlY09wdGlvbnMpO1xuICBpZiAob3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gcGFyc2VSZXZpc2lvbkZpbGVDaGFuZ2VPdXRwdXQob3V0cHV0LCB3b3JraW5nRGlyZWN0b3J5KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSBvdXRwdXQgUmF3IG91dHB1dCBzdHJpbmcgZnJvbSAnaGcgbG9nJyBjYWxsIGluIGBmZXRjaEZpbGVzQ2hhbmdlZEF0UmV2aXNpb25gLlxuICogQHBhcmFtIHdvcmtpbmdEaXJlY3RvcnkgVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoZSBoZyByZXBvc2l0b3J5LlxuICogQHJldHVybiBBIFJldmlzaW9uRmlsZUNoYW5nZXMgb2JqZWN0IHdoZXJlIHRoZSBwYXRocyBhcmUgYWxsIGFic29sdXRlIHBhdGhzLlxuICovXG5mdW5jdGlvbiBwYXJzZVJldmlzaW9uRmlsZUNoYW5nZU91dHB1dChvdXRwdXQ6IHN0cmluZywgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKTogUmV2aXNpb25GaWxlQ2hhbmdlcyB7XG4gIHZhciBsaW5lcyA9IG91dHB1dC50cmltKCkuc3BsaXQoJ1xcbicpO1xuICB2YXIgYWxsRmlsZXMgPSBsaW5lc1swXS5zbGljZShBTExfRklMRVNfTEFCRUwubGVuZ3RoICsgMSkudHJpbSgpO1xuICBhbGxGaWxlcyA9IGFsbEZpbGVzLmxlbmd0aCA/IGFsbEZpbGVzLnNwbGl0KCcgJykgOiBbXTtcbiAgYWxsRmlsZXMgPSBhYnNvbHV0aXplQWxsKGFsbEZpbGVzLCB3b3JraW5nRGlyZWN0b3J5KTtcblxuICB2YXIgYWRkZWRGaWxlcyA9IGxpbmVzWzFdLnNsaWNlKEZJTEVfQUREU19MQUJFTC5sZW5ndGggKyAxKS50cmltKCk7XG4gIGFkZGVkRmlsZXMgPSBhZGRlZEZpbGVzLmxlbmd0aCA/IGFkZGVkRmlsZXMuc3BsaXQoJyAnKSA6IFtdO1xuICBhZGRlZEZpbGVzID0gYWJzb2x1dGl6ZUFsbChhZGRlZEZpbGVzLCB3b3JraW5nRGlyZWN0b3J5KTtcblxuICB2YXIgZGVsZXRlZEZpbGVzID0gbGluZXNbMl0uc2xpY2UoRklMRV9ERUxFVEVTX0xBQkVMLmxlbmd0aCArIDEpLnRyaW0oKTtcbiAgZGVsZXRlZEZpbGVzID0gZGVsZXRlZEZpbGVzLmxlbmd0aCA/IGRlbGV0ZWRGaWxlcy5zcGxpdCgnICcpIDogW107XG4gIGRlbGV0ZWRGaWxlcyA9IGFic29sdXRpemVBbGwoZGVsZXRlZEZpbGVzLCB3b3JraW5nRGlyZWN0b3J5KTtcblxuICAvLyBDb3BpZWQgZmlsZXMgYXJlIGluIHRoZSBmb3JtOiBuZXdfZmlsZSAocHJldmlvdXNfZmlsZSluZXdfZmlsZTIgKHByZXZpb3VzX2ZpbGUyKVsuLi5dXG4gIC8vIFRoZXJlIGlzIG5vIHNwYWNlIGJldHdlZW4gZW50cmllcy5cbiAgdmFyIGNvcGllZEZpbGVzID0gbGluZXNbM10uc2xpY2UoRklMRV9DT1BJRVNfTEFCRUwubGVuZ3RoICsgMSkudHJpbSgpO1xuICBjb3BpZWRGaWxlcyA9IGNvcGllZEZpbGVzLmxlbmd0aCA/IGNvcGllZEZpbGVzLnNwbGl0KCcpJykgOiBbXTtcbiAgLy8gV2UgZXhwZWN0IHRoZSBzdHJpbmcgdG8gZW5kIHdpdGggYSAnKScsIHNvIHRoZSBsYXN0IGVudHJ5IGluIGNvcGllZEZpbGVzIHdpbGxcbiAgLy8gYmUgYW4gZW1wdHkgc3RyaW5nLiBSZW1vdmUgdGhpcy5cbiAgY29waWVkRmlsZXMucG9wKCk7XG4gIC8vIFBhcnNlIHRoZSBsaW5lcywgbm93IGluIHRoZSBmb3JtOiBuZXdfZmlsZSAocHJldmlvdXNfZmlsZSlcbiAgY29waWVkRmlsZXMgPSBjb3BpZWRGaWxlcy5tYXAoKGZpbGVQYXRoUGFpcikgPT4ge1xuICAgIHZhciBmaWxlTmFtZU1hdGNoZXMgPSBmaWxlUGF0aFBhaXIubWF0Y2goQ09QSUVEX0ZJTEVfUEFJUl9SRUdFWCk7XG4gICAgaWYgKGZpbGVOYW1lTWF0Y2hlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogYWJzb2x1dGl6ZShmaWxlTmFtZU1hdGNoZXNbMl0sIHdvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgICB0bzogYWJzb2x1dGl6ZShmaWxlTmFtZU1hdGNoZXNbMV0sIHdvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBtb2RpZmllZEZpbGVzID0gbGluZXNbNF0uc2xpY2UoRklMRV9NT0RTX0xBQkVMLmxlbmd0aCArIDEpLnRyaW0oKTtcbiAgbW9kaWZpZWRGaWxlcyA9IG1vZGlmaWVkRmlsZXMubGVuZ3RoID8gbW9kaWZpZWRGaWxlcy5zcGxpdCgnICcpIDogW107XG4gIG1vZGlmaWVkRmlsZXMgPSBhYnNvbHV0aXplQWxsKG1vZGlmaWVkRmlsZXMsIHdvcmtpbmdEaXJlY3RvcnkpO1xuXG4gIHJldHVybiB7XG4gICAgYWxsOiBhbGxGaWxlcyxcbiAgICBhZGRlZDogYWRkZWRGaWxlcyxcbiAgICBkZWxldGVkOiBkZWxldGVkRmlsZXMsXG4gICAgY29waWVkOiBjb3BpZWRGaWxlcyxcbiAgICBtb2RpZmllZDogbW9kaWZpZWRGaWxlcyxcbiAgfTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBoZ0FzeW5jRXhlY3V0ZShhcmdzOiBBcnJheTxzdHJpbmc+LCBleGVjT3B0aW9uczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0cHV0ID0gYXdhaXQgYXN5bmNFeGVjdXRlKCdoZycsIGFyZ3MsIGV4ZWNPcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci5lcnJvcignSGcgY29tbWFuZDogZmFpbGVkIHdpdGggZXJyb3I6ICcsIGUuc3RkZXJyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gb3V0cHV0LnN0ZG91dDtcbn1cblxuZnVuY3Rpb24gYWJzb2x1dGl6ZShmaWxlUGF0aDogc3RyaW5nLCB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5qb2luKHdvcmtpbmdEaXJlY3RvcnksIGZpbGVQYXRoKTtcbn1cblxuZnVuY3Rpb24gYWJzb2x1dGl6ZUFsbChmaWxlUGF0aHM6IEFycmF5PHN0cmluZz4sIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZykge1xuICByZXR1cm4gZmlsZVBhdGhzLm1hcChmaWxlUGF0aCA9PiBhYnNvbHV0aXplKGZpbGVQYXRoLCB3b3JraW5nRGlyZWN0b3J5KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmZXRjaEZpbGVDb250ZW50QXRSZXZpc2lvbixcbiAgZmV0Y2hGaWxlc0NoYW5nZWRBdFJldmlzaW9uLFxuICBwYXJzZVJldmlzaW9uRmlsZUNoYW5nZU91dHB1dCwgLy8gZXhwb3NlZCBmb3IgdGVzdGluZ1xufTtcbiJdfQ==
