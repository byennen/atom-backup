
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * Babel's plugin who auto generate remote service implementation based on service definition class.
 * If the method name starts with 'on' (assuming a camel-cased method), we will generate the event
 * registration method, otherwise, rpc call method will be generated.
 *
 * It is common that a remote service api take a file path as parameter or return a file path as
 * result. However, the same path has different forms locally and remotely.
 * In client a remote file's uri is in form of 'nuclide://$host:$port/$path', while in the server
 * we only need $path.
 *
 * To address this problem, we support flow type `NuclideUri` for parameter and `Promise<NuclideUri>`
 * for return value in RPC method definition:
 *   a) If a parameter is typed as `NuclideUri`, the generated method in remote service assumes
 *      the parameter is a remote file uri ('nuclide://$host:$post/$path'). So it parses the
 *      parameter and calls to rpc with the parsed path.
 *   b) If the return value is typed as `Promise<NuclideUri>`, the generated method treats result
 *      from rpc call as a path. It assembles the path with remote host/port to a remote file uri
 *      and return the uri to caller.
 *   c) For event method definition, if the callback's parameter is typed as `NuclideUri`, the
 *      generated method assembles the parameter with remote host/port information as well.
 *   d) We also support nested flow type definition for parameter and return value like
 *      `Array<NuclideUri>` or `{file: NuclideUri, sizeInByte: number}` etc, as it will be properly
 *      transformed. For more information, please read comments in 'nuclide-uri-transformer.js'.
 *
 * As an example, for a service definition:
 *
 * ```
 *  class TestService {
 *    getStatus(includeIgnored: boolean): Promise<any> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    getFileStatus(fileUri: NuclideUri): Promise<any> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    getLastOpenedFile(): Promise<NucideUri> {
 *      return Promise.reject('not implemented');
 *    }
 *
 *    onFileChanged(callback: (payload: any) => void): Disposable {
 *      return Promise.reject('not implemented');
 *    }
 *  }
 *
 * module.exports = TestService;
 * ```
 *
 * it will generate following code:
 *
 * ```
 *  var TestService = require(...);
 *
 *  // Auto-generated: DO NOT MODIFY.
 *
 *  class RemoteTestService extends TestService {
 *    constructor(connection, options) {
 *      super();
 *      this._connection = connection;
 *      this._options = options;
 *    }
 *    getStatus(includeIgnored) {
 *      return this._connection.makeRpc('TestService/getStatus', [includeIgnored], this._options);
 *    }
 *    getFileStatus(fileUri) {
 *      fileUri = this._connection.getPathOfUri(fileUri);
 *      return this._connection.makeRpc('TestService/getFileStatus', [fileUri], this._options);
 *    }
 *    getLastOpenedFile() {
 *      return this._connection.makeRpc('TestService/getLastOpenedFile', [], this._options).then(arg0 => {
 *          arg0 = this._connection.getUriOfRemotePath(arg0);
 *          return arg0;
 *      });
 *    }
 *    onFileChanged(callback) {
 *      return this._connection.registerEventListener('TestService/onFileChanged', callback, this._options);
 *    }
 *  }
 *
 * module.exports = RemoteTestService;
 * ```
 */

var _require = require('babel-core');

var Transformer = _require.Transformer;

var t = require('babel-core').types;

var _require2 = require('./method-name-parser');

var isEventMethodName = _require2.isEventMethodName;

var _require3 = require('./flow-annotation');

var isGenericFlowTypeAnnotation = _require3.isGenericFlowTypeAnnotation;

var _require4 = require('./nuclide-uri-transformer');

var createGetUriOfRemotePathAssignmentExpression = _require4.createGetUriOfRemotePathAssignmentExpression;
var createGetPathOfUriAssignmentExpression = _require4.createGetPathOfUriAssignmentExpression;

var GENERATED_CLASS_PREFIX = 'Remote';

/**
 * Create ast expression of `var $baseClassName = require('$baseClassFilePath')
 * .$baseClassName || require('$baseClassFilePath');`.
 */
function createBaseClassRequireExpression(baseClassName, baseClassFilePath) {
  // Create a require expression that loads the file of the service definition.
  var requireExpression = t.callExpression(t.identifier('require'), [t.literal(baseClassFilePath)]);
  // First try to access the service as a property of the module - if not,
  // the service is the module itself.
  var orExpression = t.binaryExpression('||', t.memberExpression(requireExpression, t.identifier(baseClassName)), requireExpression);

  return t.variableDeclaration(
  /* kind */'var',
  /* declarations */[t.variableDeclarator(
  /* id */t.identifier(baseClassName),
  /* init */orExpression)]);
}

/**
 * Create ast expression of `var analytics = require('nuclide-analytics');`.
 */
function createAnalyticsRequireExpression() {
  return t.variableDeclaration(
  /* kind */'var',
  /* declarations */[t.variableDeclarator(
  /* id */t.identifier('analytics'),
  /* init */t.callExpression(
  /* callee */t.identifier('require'),
  /* arguments */[t.literal('nuclide-analytics')]))]);
}

function createRemoteClassDeclaration(classDeclaration) {
  var remoteMethodDefinitions = classDeclaration.body.body.map(function (bodyPart) {
    // Create remote method definition for each class method. The part type must be checked because
    // ES7 class properties are also part of the `body` array and have type `ClassProperty`.
    if (bodyPart.type === 'MethodDefinition') {
      if (isEventMethodName(bodyPart.key.name)) {
        return createRemoteEventMethodDefinition(classDeclaration, bodyPart);
      } else {
        return createRemoteRpcMethodDefinition(classDeclaration, bodyPart);
      }
    }
  });

  var remoteClassDeclaration = t.classDeclaration(
  /* id */t.identifier(GENERATED_CLASS_PREFIX + classDeclaration.id.name),
  /* body */t.classBody([createConstructorDefinition()].concat(remoteMethodDefinitions)),
  /* superClass */classDeclaration.id);

  // There is no such function to create comment node in babel, so use following
  // hack to walk around for now.
  remoteClassDeclaration.leadingComments = [{
    type: 'Line',
    value: ' Auto-generated: DO NOT MODIFY.'
  }];

  return remoteClassDeclaration;
}

function createConstructorDefinition() {
  var constructorFunctionExpression = t.functionExpression(
  /* id */null,
  /* params */[t.identifier('connection'), t.identifier('options')],
  /* body */t.blockStatement([
  // AST node of `super()`.
  t.expressionStatement(t.callExpression( /* callee */t['super'](), /* arguments */[])),
  // AST node of `this._connection = connection`.
  t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */t.memberExpression(t.thisExpression(), t.identifier('_connection')),
  /* right */t.identifier('connection'))),
  // AST node of `this._options = options`.
  t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */t.memberExpression(t.thisExpression(), t.identifier('_options')),
  /* right */t.identifier('options')))]));

  return t.methodDefinition(
  /* key */t.identifier('constructor'),
  /* value */constructorFunctionExpression,
  /* kind */'constructor');
}

/**
 * Generate call expression of
 * `$promiseNode.then(arg0 => {manipulate(arg0); return arg0;})` if nestedflowTypeNodeOfPromise
 * or its child flow type node matches NuclideUri.
 */
function createGetUriFromPathPromiseExpression(promiseNode, nestedflowTypeNodeOfPromise) {

  var arrowFunctionParameter = t.identifier('result');
  var assignmentExpression = createGetUriOfRemotePathAssignmentExpression(nestedflowTypeNodeOfPromise, arrowFunctionParameter);

  if (!assignmentExpression) {
    return promiseNode;
  }

  var arrowFunction = t.arrowFunctionExpression(
  /* params */[arrowFunctionParameter],
  /* body */t.blockStatement([assignmentExpression, t.returnStatement(arrowFunctionParameter)]));

  return t.callExpression(
  /* callee */t.memberExpression(promiseNode, t.identifier('then')),
  /* arguments */[arrowFunction]);
}

function createRemoteRpcMethodDefinition(classDeclaration, methodDefinition) {

  // For each parameter of the method, check its flow type and create manipulation expression if
  // the flow type matches or contains `NuclideUri`.
  var parametersManipulationExpressions = [];

  methodDefinition.value.params.forEach(function (param) {
    var assignmentExpression = createGetPathOfUriAssignmentExpression(param.typeAnnotation.typeAnnotation, param);
    if (assignmentExpression) {
      parametersManipulationExpressions.push(assignmentExpression);
    }
  });

  // AST node of
  // `this._connection.makeRpc(
  //   '$className/$methodName',
  //   [$methodParam0,
  //    $methodParam1,
  //    ....],
  //   this._options);
  // );`
  var rpcCallExpression = t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('makeRpc')),
  /* arguments */[t.literal(classDeclaration.id.name + '/' + methodDefinition.key.name), t.arrayExpression(methodDefinition.value.params), t.memberExpression(t.thisExpression(), t.identifier('_options'))]);

  // If the method's return value is typed as Promise<..> and has nested `NuclideUri`, append
  // manipulation code in `returnValue.then(...)` block.
  var methodReturnType = methodDefinition.value.returnType;
  if (methodReturnType !== undefined && isGenericFlowTypeAnnotation(methodReturnType.typeAnnotation, 'Promise')) {

    var typeParameters = methodReturnType.typeAnnotation.typeParameters;

    if (typeParameters && typeParameters.params.length === 1) {
      rpcCallExpression = createGetUriFromPathPromiseExpression(rpcCallExpression, typeParameters.params[0]);
    }
  }

  var remoteFunctionExpression = t.functionExpression(
  /* id */null,
  /* params */methodDefinition.value.params,
  /* body */t.blockStatement(parametersManipulationExpressions.concat([t.returnStatement(rpcCallExpression)])));

  // Create the method defintion AST node.
  var remoteMethodDefinition = t.methodDefinition(
  /* key */t.identifier(methodDefinition.key.name),
  /* value */remoteFunctionExpression,
  /* kind */'method');

  // Annotate this node with the analytics.trackTiming decorator.
  remoteMethodDefinition.decorators = [t.decorator(t.callExpression(t.memberExpression(t.identifier('analytics'), t.identifier('trackTiming')), []))];

  return remoteMethodDefinition;
}

/**
 * If the callback function's parameter is typed as `NuclideUri` or has nested type of `NuclideUri`,
 * create a new callback function which transform the paramter's NuclideUri first then call to the
 * original callback.
 *
 * For example, given callback `callback: (payload: NuclideUri) => void`, it returns a new arrow
 * function:
 * ```
 * payload => {
 *   payload = this._connection.getUriOfRemotePath(payload);
 *   return callback(payload);
 * }
 * ```
 */
function createManipulatedCallbackArrowFunction(callbackAstNode) {
  if (!callbackAstNode.typeAnnotation.typeAnnotation.params) {
    return null;
  }

  var parameterManipulateExpressions = [];

  callbackAstNode.typeAnnotation.typeAnnotation.params.forEach(function (callbackParameterFlowtypeNode) {
    var identifier = callbackParameterFlowtypeNode.name;
    var manipulateCallbackParameterAssignmentExpression = createGetUriOfRemotePathAssignmentExpression(callbackParameterFlowtypeNode.typeAnnotation, identifier);
    if (manipulateCallbackParameterAssignmentExpression) {
      parameterManipulateExpressions.push(manipulateCallbackParameterAssignmentExpression);
    }
  });

  if (parameterManipulateExpressions.length === 0) {
    return null;
  }

  var parameterIdentifiers = callbackAstNode.typeAnnotation.typeAnnotation.params.map(function (node) {
    return node.name;
  });

  return t.arrowFunctionExpression(
  /* params */parameterIdentifiers,
  /* body */t.blockStatement(parameterManipulateExpressions.concat([t.returnStatement(t.callExpression(t.identifier(callbackAstNode.name), parameterIdentifiers))])));
}

function createRemoteEventMethodDefinition(classDeclaration, methodDefinition) {
  var remoteEventMethodBody = [];
  var callbackParameter = methodDefinition.value.params[0];

  var manipulatedCallback = createManipulatedCallbackArrowFunction(methodDefinition.value.params[0]);

  if (manipulatedCallback) {
    var callbackParameter = t.identifier('_' + callbackParameter.name);

    remoteEventMethodBody.push(t.variableDeclaration(
    /* kind */'var',
    /* declarations */[t.variableDeclarator(
    /* id */callbackParameter,
    /* init */manipulatedCallback)]));
  }

  remoteEventMethodBody.push(
  // AST node of
  // `return this._connection.registerEventListener(
  //   '$className/$methodName',
  //   callback,
  //   this._options,
  // );`
  t.returnStatement(t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('registerEventListener')),
  /* arguments */[t.literal(classDeclaration.id.name + '/' + methodDefinition.key.name), callbackParameter, t.memberExpression(t.thisExpression(), t.identifier('_options'))])));

  var remoteFunctionExpression = t.functionExpression(
  /* id */null,
  /* params */methodDefinition.value.params,
  /* body */t.blockStatement(remoteEventMethodBody));

  return t.methodDefinition(
  /* key */t.identifier(methodDefinition.key.name),
  /* value */remoteFunctionExpression,
  /* kind */'method');
}

function createRemoteServiceTransformer(baseClassFilePath) {
  return new Transformer('remote-service', {
    ClassDeclaration: function ClassDeclaration(node, parent) {
      // Skip classes with `Remote` prefix as it's generated.
      if (node.id.name.lastIndexOf(GENERATED_CLASS_PREFIX) === 0) {
        return;
      }

      // Make sure block comment `/* flow */` generated at the beginning of the file.
      // The way babel deal with comments is buggy, if we switch following two lines:
      // ```
      //   this.insertBefore(createBaseClassRequireExpression(...));
      //   return createRemoteClassDeclaration(...);
      // ```
      // The generated code will look like:
      // ```
      //   'use babel';
      //   var TestService = require('...');
      //   /* flow */
      //   class RemoteTestService extends TestService {
      //   ...
      // ```
      // which is not what we expect.
      this.insertAfter(createRemoteClassDeclaration(node));

      // Require the analytics package.
      this.insertAfter(createAnalyticsRequireExpression());

      return createBaseClassRequireExpression(node.id.name, baseClassFilePath);
    },

    // Update `module.exports` to export generated remote class.
    ExpressionStatement: function ExpressionStatement(node, parent) {
      // Ignore expression not in form of `module.exports = ...`.
      if (!t.isAssignmentExpression(node.expression) || node.expression.operator !== '=' || !t.isMemberExpression(node.expression.left) || !t.isIdentifier(node.expression.left.object) || !t.isIdentifier(node.expression.left.property) || node.expression.left.object.name !== 'module' || node.expression.left.property.name !== 'exports') {
        return;
      }
      var right = node.expression.right;

      // If expression takes form `module.exports = $identifier`, then we are exporting
      // only one class.
      if (t.isIdentifier(right)) {
        node.expression.right = t.identifier(GENERATED_CLASS_PREFIX + node.expression.right.name);
        return;
      }

      // If expression takes form `module.exports = { $identifier, ..., $identifer }`, then
      // we are exporting multiple classes.
      if (t.isObjectExpression(right)) {
        // Ensure that all the properties in this object are all identifier : identifier mappins.
        var identifiers = right.properties.every(function (prop) {
          return t.isIdentifier(prop.key) && t.isIdentifier(prop.value);
        });
        if (!identifiers) {
          return;
        }
        // Prepend GENERATED_CLASS_PREFIX to every key and value.
        right.properties.forEach(function (prop) {
          prop.value = t.identifier(GENERATED_CLASS_PREFIX + prop.value.name);
        });
      }
    }
  });
}

module.exports = createRemoteServiceTransformer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL3JlbW90ZS1zZXJ2aWNlLXRyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBOEZRLE9BQU8sQ0FBQyxZQUFZLENBQUM7O0lBQXBDLFdBQVcsWUFBWCxXQUFXOztBQUNoQixJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDOztnQkFDVixPQUFPLENBQUMsc0JBQXNCLENBQUM7O0lBQXBELGlCQUFpQixhQUFqQixpQkFBaUI7O2dCQUNjLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQzs7SUFBM0QsMkJBQTJCLGFBQTNCLDJCQUEyQjs7Z0JBRTFCLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQzs7SUFEckMsNENBQTRDLGFBQTVDLDRDQUE0QztJQUFFLHNDQUFzQyxhQUF0QyxzQ0FBc0M7O0FBR3pGLElBQUksc0JBQXNCLEdBQUcsUUFBUSxDQUFDOzs7Ozs7QUFNdEMsU0FBUyxnQ0FBZ0MsQ0FBQyxhQUFxQixFQUFFLGlCQUF5QixFQUFPOztBQUUvRixNQUFJLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFDOUQsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDOzs7QUFHbEMsTUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLEVB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SSxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ3pCLFlBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQ2xDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZELGVBQU87T0FDUjs7OztBQUlELFVBQUksQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxFQUFFOztBQUUvQixZQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFBLElBQUksRUFBSTtBQUMvQyxpQkFBTyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMvRCxDQUFDLENBQUM7QUFDSCxZQUFJLENBQUMsV0FBVyxFQUFFO0FBQ2hCLGlCQUFPO1NBQ1I7O0FBRUQsYUFBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDL0IsY0FBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckUsQ0FBQyxDQUFDO09BQ0o7S0FDRjtHQUNGLENBQUMsQ0FBQztDQUNKOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsOEJBQThCLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmljZS10cmFuc2Zvcm1lci9saWIvcmVtb3RlLXNlcnZpY2UtdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIEJhYmVsJ3MgcGx1Z2luIHdobyBhdXRvIGdlbmVyYXRlIHJlbW90ZSBzZXJ2aWNlIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHNlcnZpY2UgZGVmaW5pdGlvbiBjbGFzcy5cbiAqIElmIHRoZSBtZXRob2QgbmFtZSBzdGFydHMgd2l0aCAnb24nIChhc3N1bWluZyBhIGNhbWVsLWNhc2VkIG1ldGhvZCksIHdlIHdpbGwgZ2VuZXJhdGUgdGhlIGV2ZW50XG4gKiByZWdpc3RyYXRpb24gbWV0aG9kLCBvdGhlcndpc2UsIHJwYyBjYWxsIG1ldGhvZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAqXG4gKiBJdCBpcyBjb21tb24gdGhhdCBhIHJlbW90ZSBzZXJ2aWNlIGFwaSB0YWtlIGEgZmlsZSBwYXRoIGFzIHBhcmFtZXRlciBvciByZXR1cm4gYSBmaWxlIHBhdGggYXNcbiAqIHJlc3VsdC4gSG93ZXZlciwgdGhlIHNhbWUgcGF0aCBoYXMgZGlmZmVyZW50IGZvcm1zIGxvY2FsbHkgYW5kIHJlbW90ZWx5LlxuICogSW4gY2xpZW50IGEgcmVtb3RlIGZpbGUncyB1cmkgaXMgaW4gZm9ybSBvZiAnbnVjbGlkZTovLyRob3N0OiRwb3J0LyRwYXRoJywgd2hpbGUgaW4gdGhlIHNlcnZlclxuICogd2Ugb25seSBuZWVkICRwYXRoLlxuICpcbiAqIFRvIGFkZHJlc3MgdGhpcyBwcm9ibGVtLCB3ZSBzdXBwb3J0IGZsb3cgdHlwZSBgTnVjbGlkZVVyaWAgZm9yIHBhcmFtZXRlciBhbmQgYFByb21pc2U8TnVjbGlkZVVyaT5gXG4gKiBmb3IgcmV0dXJuIHZhbHVlIGluIFJQQyBtZXRob2QgZGVmaW5pdGlvbjpcbiAqICAgYSkgSWYgYSBwYXJhbWV0ZXIgaXMgdHlwZWQgYXMgYE51Y2xpZGVVcmlgLCB0aGUgZ2VuZXJhdGVkIG1ldGhvZCBpbiByZW1vdGUgc2VydmljZSBhc3N1bWVzXG4gKiAgICAgIHRoZSBwYXJhbWV0ZXIgaXMgYSByZW1vdGUgZmlsZSB1cmkgKCdudWNsaWRlOi8vJGhvc3Q6JHBvc3QvJHBhdGgnKS4gU28gaXQgcGFyc2VzIHRoZVxuICogICAgICBwYXJhbWV0ZXIgYW5kIGNhbGxzIHRvIHJwYyB3aXRoIHRoZSBwYXJzZWQgcGF0aC5cbiAqICAgYikgSWYgdGhlIHJldHVybiB2YWx1ZSBpcyB0eXBlZCBhcyBgUHJvbWlzZTxOdWNsaWRlVXJpPmAsIHRoZSBnZW5lcmF0ZWQgbWV0aG9kIHRyZWF0cyByZXN1bHRcbiAqICAgICAgZnJvbSBycGMgY2FsbCBhcyBhIHBhdGguIEl0IGFzc2VtYmxlcyB0aGUgcGF0aCB3aXRoIHJlbW90ZSBob3N0L3BvcnQgdG8gYSByZW1vdGUgZmlsZSB1cmlcbiAqICAgICAgYW5kIHJldHVybiB0aGUgdXJpIHRvIGNhbGxlci5cbiAqICAgYykgRm9yIGV2ZW50IG1ldGhvZCBkZWZpbml0aW9uLCBpZiB0aGUgY2FsbGJhY2sncyBwYXJhbWV0ZXIgaXMgdHlwZWQgYXMgYE51Y2xpZGVVcmlgLCB0aGVcbiAqICAgICAgZ2VuZXJhdGVkIG1ldGhvZCBhc3NlbWJsZXMgdGhlIHBhcmFtZXRlciB3aXRoIHJlbW90ZSBob3N0L3BvcnQgaW5mb3JtYXRpb24gYXMgd2VsbC5cbiAqICAgZCkgV2UgYWxzbyBzdXBwb3J0IG5lc3RlZCBmbG93IHR5cGUgZGVmaW5pdGlvbiBmb3IgcGFyYW1ldGVyIGFuZCByZXR1cm4gdmFsdWUgbGlrZVxuICogICAgICBgQXJyYXk8TnVjbGlkZVVyaT5gIG9yIGB7ZmlsZTogTnVjbGlkZVVyaSwgc2l6ZUluQnl0ZTogbnVtYmVyfWAgZXRjLCBhcyBpdCB3aWxsIGJlIHByb3Blcmx5XG4gKiAgICAgIHRyYW5zZm9ybWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHJlYWQgY29tbWVudHMgaW4gJ251Y2xpZGUtdXJpLXRyYW5zZm9ybWVyLmpzJy5cbiAqXG4gKiBBcyBhbiBleGFtcGxlLCBmb3IgYSBzZXJ2aWNlIGRlZmluaXRpb246XG4gKlxuICogYGBgXG4gKiAgY2xhc3MgVGVzdFNlcnZpY2Uge1xuICogICAgZ2V0U3RhdHVzKGluY2x1ZGVJZ25vcmVkOiBib29sZWFuKTogUHJvbWlzZTxhbnk+IHtcbiAqICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub3QgaW1wbGVtZW50ZWQnKTtcbiAqICAgIH1cbiAqXG4gKiAgICBnZXRGaWxlU3RhdHVzKGZpbGVVcmk6IE51Y2xpZGVVcmkpOiBQcm9taXNlPGFueT4ge1xuICogICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICogICAgfVxuICpcbiAqICAgIGdldExhc3RPcGVuZWRGaWxlKCk6IFByb21pc2U8TnVjaWRlVXJpPiB7XG4gKiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnbm90IGltcGxlbWVudGVkJyk7XG4gKiAgICB9XG4gKlxuICogICAgb25GaWxlQ2hhbmdlZChjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZCk6IERpc3Bvc2FibGUge1xuICogICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICogICAgfVxuICogIH1cbiAqXG4gKiBtb2R1bGUuZXhwb3J0cyA9IFRlc3RTZXJ2aWNlO1xuICogYGBgXG4gKlxuICogaXQgd2lsbCBnZW5lcmF0ZSBmb2xsb3dpbmcgY29kZTpcbiAqXG4gKiBgYGBcbiAqICB2YXIgVGVzdFNlcnZpY2UgPSByZXF1aXJlKC4uLik7XG4gKlxuICogIC8vIEF1dG8tZ2VuZXJhdGVkOiBETyBOT1QgTU9ESUZZLlxuICpcbiAqICBjbGFzcyBSZW1vdGVUZXN0U2VydmljZSBleHRlbmRzIFRlc3RTZXJ2aWNlIHtcbiAqICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAqICAgICAgc3VwZXIoKTtcbiAqICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gKiAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICogICAgfVxuICogICAgZ2V0U3RhdHVzKGluY2x1ZGVJZ25vcmVkKSB7XG4gKiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uLm1ha2VScGMoJ1Rlc3RTZXJ2aWNlL2dldFN0YXR1cycsIFtpbmNsdWRlSWdub3JlZF0sIHRoaXMuX29wdGlvbnMpO1xuICogICAgfVxuICogICAgZ2V0RmlsZVN0YXR1cyhmaWxlVXJpKSB7XG4gKiAgICAgIGZpbGVVcmkgPSB0aGlzLl9jb25uZWN0aW9uLmdldFBhdGhPZlVyaShmaWxlVXJpKTtcbiAqICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24ubWFrZVJwYygnVGVzdFNlcnZpY2UvZ2V0RmlsZVN0YXR1cycsIFtmaWxlVXJpXSwgdGhpcy5fb3B0aW9ucyk7XG4gKiAgICB9XG4gKiAgICBnZXRMYXN0T3BlbmVkRmlsZSgpIHtcbiAqICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24ubWFrZVJwYygnVGVzdFNlcnZpY2UvZ2V0TGFzdE9wZW5lZEZpbGUnLCBbXSwgdGhpcy5fb3B0aW9ucykudGhlbihhcmcwID0+IHtcbiAqICAgICAgICAgIGFyZzAgPSB0aGlzLl9jb25uZWN0aW9uLmdldFVyaU9mUmVtb3RlUGF0aChhcmcwKTtcbiAqICAgICAgICAgIHJldHVybiBhcmcwO1xuICogICAgICB9KTtcbiAqICAgIH1cbiAqICAgIG9uRmlsZUNoYW5nZWQoY2FsbGJhY2spIHtcbiAqICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24ucmVnaXN0ZXJFdmVudExpc3RlbmVyKCdUZXN0U2VydmljZS9vbkZpbGVDaGFuZ2VkJywgY2FsbGJhY2ssIHRoaXMuX29wdGlvbnMpO1xuICogICAgfVxuICogIH1cbiAqXG4gKiBtb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVRlc3RTZXJ2aWNlO1xuICogYGBgXG4gKi9cblxudmFyIHtUcmFuc2Zvcm1lcn0gPSByZXF1aXJlKCdiYWJlbC1jb3JlJyk7XG52YXIgdCA9IHJlcXVpcmUoJ2JhYmVsLWNvcmUnKS50eXBlcztcbnZhciB7aXNFdmVudE1ldGhvZE5hbWV9ID0gcmVxdWlyZSgnLi9tZXRob2QtbmFtZS1wYXJzZXInKTtcbnZhciB7aXNHZW5lcmljRmxvd1R5cGVBbm5vdGF0aW9ufSA9IHJlcXVpcmUoJy4vZmxvdy1hbm5vdGF0aW9uJyk7XG52YXIge2NyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbn1cbiAgICA9IHJlcXVpcmUoJy4vbnVjbGlkZS11cmktdHJhbnNmb3JtZXInKTtcblxudmFyIEdFTkVSQVRFRF9DTEFTU19QUkVGSVggPSAnUmVtb3RlJztcblxuLyoqXG4gKiBDcmVhdGUgYXN0IGV4cHJlc3Npb24gb2YgYHZhciAkYmFzZUNsYXNzTmFtZSA9IHJlcXVpcmUoJyRiYXNlQ2xhc3NGaWxlUGF0aCcpXG4gKiAuJGJhc2VDbGFzc05hbWUgfHwgcmVxdWlyZSgnJGJhc2VDbGFzc0ZpbGVQYXRoJyk7YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNsYXNzUmVxdWlyZUV4cHJlc3Npb24oYmFzZUNsYXNzTmFtZTogc3RyaW5nLCBiYXNlQ2xhc3NGaWxlUGF0aDogc3RyaW5nKTogYW55IHtcbiAgLy8gQ3JlYXRlIGEgcmVxdWlyZSBleHByZXNzaW9uIHRoYXQgbG9hZHMgdGhlIGZpbGUgb2YgdGhlIHNlcnZpY2UgZGVmaW5pdGlvbi5cbiAgdmFyIHJlcXVpcmVFeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoJ3JlcXVpcmUnKSxcbiAgICBbdC5saXRlcmFsKGJhc2VDbGFzc0ZpbGVQYXRoKV0pO1xuICAvLyBGaXJzdCB0cnkgdG8gYWNjZXNzIHRoZSBzZXJ2aWNlIGFzIGEgcHJvcGVydHkgb2YgdGhlIG1vZHVsZSAtIGlmIG5vdCxcbiAgLy8gdGhlIHNlcnZpY2UgaXMgdGhlIG1vZHVsZSBpdHNlbGYuXG4gIHZhciBvckV4cHJlc3Npb24gPSB0LmJpbmFyeUV4cHJlc3Npb24oJ3x8JywgdC5tZW1iZXJFeHByZXNzaW9uKHJlcXVpcmVFeHByZXNzaW9uLFxuICAgIHQuaWRlbnRpZmllcihiYXNlQ2xhc3NOYW1lKSksIHJlcXVpcmVFeHByZXNzaW9uKTtcblxuICByZXR1cm4gdC52YXJpYWJsZURlY2xhcmF0aW9uKFxuICAgIC8qIGtpbmQgKi8gJ3ZhcicsXG4gICAgLyogZGVjbGFyYXRpb25zICovIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICAvKiBpZCAqLyB0LmlkZW50aWZpZXIoYmFzZUNsYXNzTmFtZSksXG4gICAgICAgIC8qIGluaXQgKi8gb3JFeHByZXNzaW9uXG4gICAgICApLFxuICAgIF1cbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYXN0IGV4cHJlc3Npb24gb2YgYHZhciBhbmFseXRpY3MgPSByZXF1aXJlKCdudWNsaWRlLWFuYWx5dGljcycpO2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFuYWx5dGljc1JlcXVpcmVFeHByZXNzaW9uKCk6IGFueSB7XG4gIHJldHVybiB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgLyoga2luZCAqLyAndmFyJyxcbiAgICAvKiBkZWNsYXJhdGlvbnMgKi8gW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoXG4gICAgICAgIC8qIGlkICovIHQuaWRlbnRpZmllcignYW5hbHl0aWNzJyksXG4gICAgICAgIC8qIGluaXQgKi8gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAvKiBjYWxsZWUgKi8gdC5pZGVudGlmaWVyKCdyZXF1aXJlJyksXG4gICAgICAgICAgLyogYXJndW1lbnRzICovIFt0LmxpdGVyYWwoJ251Y2xpZGUtYW5hbHl0aWNzJyldXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVDbGFzc0RlY2xhcmF0aW9uKGNsYXNzRGVjbGFyYXRpb246IGFueSk6IGFueSB7XG4gIHZhciByZW1vdGVNZXRob2REZWZpbml0aW9ucyA9IGNsYXNzRGVjbGFyYXRpb24uYm9keS5ib2R5Lm1hcChib2R5UGFydCA9PiB7XG4gICAgLy8gQ3JlYXRlIHJlbW90ZSBtZXRob2QgZGVmaW5pdGlvbiBmb3IgZWFjaCBjbGFzcyBtZXRob2QuIFRoZSBwYXJ0IHR5cGUgbXVzdCBiZSBjaGVja2VkIGJlY2F1c2VcbiAgICAvLyBFUzcgY2xhc3MgcHJvcGVydGllcyBhcmUgYWxzbyBwYXJ0IG9mIHRoZSBgYm9keWAgYXJyYXkgYW5kIGhhdmUgdHlwZSBgQ2xhc3NQcm9wZXJ0eWAuXG4gICAgaWYgKGJvZHlQYXJ0LnR5cGUgPT09ICdNZXRob2REZWZpbml0aW9uJykge1xuICAgICAgaWYgKGlzRXZlbnRNZXRob2ROYW1lKGJvZHlQYXJ0LmtleS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3RlRXZlbnRNZXRob2REZWZpbml0aW9uKGNsYXNzRGVjbGFyYXRpb24sIGJvZHlQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdGVScGNNZXRob2REZWZpbml0aW9uKGNsYXNzRGVjbGFyYXRpb24sIGJvZHlQYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZW1vdGVDbGFzc0RlY2xhcmF0aW9uID0gdC5jbGFzc0RlY2xhcmF0aW9uKFxuICAgIC8qIGlkICovIHQuaWRlbnRpZmllcihHRU5FUkFURURfQ0xBU1NfUFJFRklYICsgY2xhc3NEZWNsYXJhdGlvbi5pZC5uYW1lKSxcbiAgICAvKiBib2R5ICovIHQuY2xhc3NCb2R5KFxuICAgICAgW2NyZWF0ZUNvbnN0cnVjdG9yRGVmaW5pdGlvbigpXS5jb25jYXQocmVtb3RlTWV0aG9kRGVmaW5pdGlvbnMpXG4gICAgKSxcbiAgICAvKiBzdXBlckNsYXNzICovIGNsYXNzRGVjbGFyYXRpb24uaWRcbiAgKTtcblxuICAvLyBUaGVyZSBpcyBubyBzdWNoIGZ1bmN0aW9uIHRvIGNyZWF0ZSBjb21tZW50IG5vZGUgaW4gYmFiZWwsIHNvIHVzZSBmb2xsb3dpbmdcbiAgLy8gaGFjayB0byB3YWxrIGFyb3VuZCBmb3Igbm93LlxuICByZW1vdGVDbGFzc0RlY2xhcmF0aW9uLmxlYWRpbmdDb21tZW50cyA9IFtcbiAgICB7XG4gICAgICB0eXBlOiAnTGluZScsXG4gICAgICB2YWx1ZTogJyBBdXRvLWdlbmVyYXRlZDogRE8gTk9UIE1PRElGWS4nLFxuICAgIH1cbiAgXTtcblxuICByZXR1cm4gcmVtb3RlQ2xhc3NEZWNsYXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29uc3RydWN0b3JEZWZpbml0aW9uKCk6IGFueSB7XG4gIHZhciBjb25zdHJ1Y3RvckZ1bmN0aW9uRXhwcmVzc2lvbiA9IHQuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIC8qIGlkICovIG51bGwsXG4gICAgLyogcGFyYW1zICovIFt0LmlkZW50aWZpZXIoJ2Nvbm5lY3Rpb24nKSwgdC5pZGVudGlmaWVyKCdvcHRpb25zJyldLFxuICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChcbiAgICAgIFtcbiAgICAgICAgLy8gQVNUIG5vZGUgb2YgYHN1cGVyKClgLlxuICAgICAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbigvKiBjYWxsZWUgKi8gdC5zdXBlcigpLCAvKiBhcmd1bWVudHMgKi8gW10pXG4gICAgICAgICksXG4gICAgICAgIC8vIEFTVCBub2RlIG9mIGB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbmAuXG4gICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICAgICAgLyogb3BlcmF0b3IgKi8gJz0nLFxuICAgICAgICAgICAgLyogbGVmdCAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdfY29ubmVjdGlvbicpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLyogcmlnaHQgKi8gdC5pZGVudGlmaWVyKCdjb25uZWN0aW9uJylcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIC8vIEFTVCBub2RlIG9mIGB0aGlzLl9vcHRpb25zID0gb3B0aW9uc2AuXG4gICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICAgICAgLyogb3BlcmF0b3IgKi8gJz0nLFxuICAgICAgICAgICAgLyogbGVmdCAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdfb3B0aW9ucycpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLyogcmlnaHQgKi8gdC5pZGVudGlmaWVyKCdvcHRpb25zJylcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIF1cbiAgICApXG4gICk7XG5cbiAgcmV0dXJuIHQubWV0aG9kRGVmaW5pdGlvbihcbiAgICAvKiBrZXkgKi8gdC5pZGVudGlmaWVyKCdjb25zdHJ1Y3RvcicpLFxuICAgIC8qIHZhbHVlICovIGNvbnN0cnVjdG9yRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgIC8qIGtpbmQgKi8gJ2NvbnN0cnVjdG9yJ1xuICApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNhbGwgZXhwcmVzc2lvbiBvZlxuICogYCRwcm9taXNlTm9kZS50aGVuKGFyZzAgPT4ge21hbmlwdWxhdGUoYXJnMCk7IHJldHVybiBhcmcwO30pYCBpZiBuZXN0ZWRmbG93VHlwZU5vZGVPZlByb21pc2VcbiAqIG9yIGl0cyBjaGlsZCBmbG93IHR5cGUgbm9kZSBtYXRjaGVzIE51Y2xpZGVVcmkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdldFVyaUZyb21QYXRoUHJvbWlzZUV4cHJlc3Npb24oXG4gICAgcHJvbWlzZU5vZGU6IGFueSxcbiAgICBuZXN0ZWRmbG93VHlwZU5vZGVPZlByb21pc2U6IGFueSk6IGFueSB7XG5cbiAgdmFyIGFycm93RnVuY3Rpb25QYXJhbWV0ZXIgPSB0LmlkZW50aWZpZXIoJ3Jlc3VsdCcpO1xuICB2YXIgYXNzaWdubWVudEV4cHJlc3Npb24gPSBjcmVhdGVHZXRVcmlPZlJlbW90ZVBhdGhBc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIG5lc3RlZGZsb3dUeXBlTm9kZU9mUHJvbWlzZSwgYXJyb3dGdW5jdGlvblBhcmFtZXRlcik7XG5cbiAgaWYgKCFhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgIHJldHVybiBwcm9taXNlTm9kZTtcbiAgfVxuXG4gIHZhciBhcnJvd0Z1bmN0aW9uID0gdC5hcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAvKiBwYXJhbXMgKi8gW2Fycm93RnVuY3Rpb25QYXJhbWV0ZXJdLFxuICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChcbiAgICAgIFtcbiAgICAgICAgYXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgIHQucmV0dXJuU3RhdGVtZW50KGFycm93RnVuY3Rpb25QYXJhbWV0ZXIpLFxuICAgICAgXVxuICAgIClcbiAgKTtcblxuICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAvKiBjYWxsZWUgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgcHJvbWlzZU5vZGUsXG4gICAgICB0LmlkZW50aWZpZXIoJ3RoZW4nKSxcbiAgICApLFxuICAgIC8qIGFyZ3VtZW50cyAqLyBbYXJyb3dGdW5jdGlvbl0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVJwY01ldGhvZERlZmluaXRpb24oY2xhc3NEZWNsYXJhdGlvbjogYW55LCBtZXRob2REZWZpbml0aW9uOiBhbnkpOiBhbnkge1xuXG4gIC8vIEZvciBlYWNoIHBhcmFtZXRlciBvZiB0aGUgbWV0aG9kLCBjaGVjayBpdHMgZmxvdyB0eXBlIGFuZCBjcmVhdGUgbWFuaXB1bGF0aW9uIGV4cHJlc3Npb24gaWZcbiAgLy8gdGhlIGZsb3cgdHlwZSBtYXRjaGVzIG9yIGNvbnRhaW5zIGBOdWNsaWRlVXJpYC5cbiAgdmFyIHBhcmFtZXRlcnNNYW5pcHVsYXRpb25FeHByZXNzaW9ucyA9IFtdO1xuXG4gIG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgIHZhciBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGNyZWF0ZUdldFBhdGhPZlVyaUFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiwgcGFyYW0pO1xuICAgIGlmIChhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgcGFyYW1ldGVyc01hbmlwdWxhdGlvbkV4cHJlc3Npb25zLnB1c2goYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQVNUIG5vZGUgb2ZcbiAgLy8gYHRoaXMuX2Nvbm5lY3Rpb24ubWFrZVJwYyhcbiAgLy8gICAnJGNsYXNzTmFtZS8kbWV0aG9kTmFtZScsXG4gIC8vICAgWyRtZXRob2RQYXJhbTAsXG4gIC8vICAgICRtZXRob2RQYXJhbTEsXG4gIC8vICAgIC4uLi5dLFxuICAvLyAgIHRoaXMuX29wdGlvbnMpO1xuICAvLyApO2BcbiAgdmFyIHJwY0NhbGxFeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAvKiBjYWxsZWUgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICAgIHQuaWRlbnRpZmllcignX2Nvbm5lY3Rpb24nKVxuICAgICAgKSxcbiAgICAgIHQuaWRlbnRpZmllcignbWFrZVJwYycpXG4gICAgKSxcbiAgICAvKiBhcmd1bWVudHMgKi8gW1xuICAgICAgdC5saXRlcmFsKGNsYXNzRGVjbGFyYXRpb24uaWQubmFtZSArICcvJyArIG1ldGhvZERlZmluaXRpb24ua2V5Lm5hbWUpLFxuICAgICAgdC5hcnJheUV4cHJlc3Npb24obWV0aG9kRGVmaW5pdGlvbi52YWx1ZS5wYXJhbXMpLFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHQudGhpc0V4cHJlc3Npb24oKSwgdC5pZGVudGlmaWVyKCdfb3B0aW9ucycpKSxcbiAgICBdXG4gICk7XG5cbiAgLy8gSWYgdGhlIG1ldGhvZCdzIHJldHVybiB2YWx1ZSBpcyB0eXBlZCBhcyBQcm9taXNlPC4uPiBhbmQgaGFzIG5lc3RlZCBgTnVjbGlkZVVyaWAsIGFwcGVuZFxuICAvLyBtYW5pcHVsYXRpb24gY29kZSBpbiBgcmV0dXJuVmFsdWUudGhlbiguLi4pYCBibG9jay5cbiAgdmFyIG1ldGhvZFJldHVyblR5cGUgPSBtZXRob2REZWZpbml0aW9uLnZhbHVlLnJldHVyblR5cGU7XG4gIGlmIChtZXRob2RSZXR1cm5UeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGlzR2VuZXJpY0Zsb3dUeXBlQW5ub3RhdGlvbihtZXRob2RSZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uLCAnUHJvbWlzZScpKSB7XG5cbiAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSBtZXRob2RSZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uLnR5cGVQYXJhbWV0ZXJzO1xuXG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzICYmIHR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggPT09IDEpICB7XG4gICAgICBycGNDYWxsRXhwcmVzc2lvbiA9IGNyZWF0ZUdldFVyaUZyb21QYXRoUHJvbWlzZUV4cHJlc3Npb24oXG4gICAgICAgICAgcnBjQ2FsbEV4cHJlc3Npb24sIHR5cGVQYXJhbWV0ZXJzLnBhcmFtc1swXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbW90ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHQuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIC8qIGlkICovIG51bGwsXG4gICAgLyogcGFyYW1zICovIG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zLFxuICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChcbiAgICAgIHBhcmFtZXRlcnNNYW5pcHVsYXRpb25FeHByZXNzaW9ucy5jb25jYXQoXG4gICAgICAgIFt0LnJldHVyblN0YXRlbWVudChcbiAgICAgICAgICBycGNDYWxsRXhwcmVzc2lvbixcbiAgICAgICAgKV0sXG4gICAgICApXG4gICAgKSxcbiAgKTtcblxuICAvLyBDcmVhdGUgdGhlIG1ldGhvZCBkZWZpbnRpb24gQVNUIG5vZGUuXG4gIHZhciByZW1vdGVNZXRob2REZWZpbml0aW9uID0gdC5tZXRob2REZWZpbml0aW9uKFxuICAgIC8qIGtleSAqLyB0LmlkZW50aWZpZXIobWV0aG9kRGVmaW5pdGlvbi5rZXkubmFtZSksXG4gICAgLyogdmFsdWUgKi8gcmVtb3RlRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgIC8qIGtpbmQgKi8gJ21ldGhvZCdcbiAgKTtcblxuICAvLyBBbm5vdGF0ZSB0aGlzIG5vZGUgd2l0aCB0aGUgYW5hbHl0aWNzLnRyYWNrVGltaW5nIGRlY29yYXRvci5cbiAgcmVtb3RlTWV0aG9kRGVmaW5pdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgIHQuZGVjb3JhdG9yKFxuICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIHQuaWRlbnRpZmllcignYW5hbHl0aWNzJyksXG4gICAgICAgICAgdC5pZGVudGlmaWVyKCd0cmFja1RpbWluZycpXG4gICAgICAgICksXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICBdO1xuXG4gIHJldHVybiByZW1vdGVNZXRob2REZWZpbml0aW9uO1xufVxuXG4vKipcbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbidzIHBhcmFtZXRlciBpcyB0eXBlZCBhcyBgTnVjbGlkZVVyaWAgb3IgaGFzIG5lc3RlZCB0eXBlIG9mIGBOdWNsaWRlVXJpYCxcbiAqIGNyZWF0ZSBhIG5ldyBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm0gdGhlIHBhcmFtdGVyJ3MgTnVjbGlkZVVyaSBmaXJzdCB0aGVuIGNhbGwgdG8gdGhlXG4gKiBvcmlnaW5hbCBjYWxsYmFjay5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gY2FsbGJhY2sgYGNhbGxiYWNrOiAocGF5bG9hZDogTnVjbGlkZVVyaSkgPT4gdm9pZGAsIGl0IHJldHVybnMgYSBuZXcgYXJyb3dcbiAqIGZ1bmN0aW9uOlxuICogYGBgXG4gKiBwYXlsb2FkID0+IHtcbiAqICAgcGF5bG9hZCA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0VXJpT2ZSZW1vdGVQYXRoKHBheWxvYWQpO1xuICogICByZXR1cm4gY2FsbGJhY2socGF5bG9hZCk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFuaXB1bGF0ZWRDYWxsYmFja0Fycm93RnVuY3Rpb24oY2FsbGJhY2tBc3ROb2RlOiBhbnkpOiA/YW55IHtcbiAgaWYgKCFjYWxsYmFja0FzdE5vZGUudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24ucGFyYW1zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1ldGVyTWFuaXB1bGF0ZUV4cHJlc3Npb25zID0gW107XG5cbiAgY2FsbGJhY2tBc3ROb2RlLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLnBhcmFtcy5mb3JFYWNoKGNhbGxiYWNrUGFyYW1ldGVyRmxvd3R5cGVOb2RlID0+IHtcbiAgICB2YXIgaWRlbnRpZmllciA9IGNhbGxiYWNrUGFyYW1ldGVyRmxvd3R5cGVOb2RlLm5hbWU7XG4gICAgdmFyIG1hbmlwdWxhdGVDYWxsYmFja1BhcmFtZXRlckFzc2lnbm1lbnRFeHByZXNzaW9uID0gY3JlYXRlR2V0VXJpT2ZSZW1vdGVQYXRoQXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgIGNhbGxiYWNrUGFyYW1ldGVyRmxvd3R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uLCBpZGVudGlmaWVyKTtcbiAgICBpZiAobWFuaXB1bGF0ZUNhbGxiYWNrUGFyYW1ldGVyQXNzaWdubWVudEV4cHJlc3Npb24pIHtcbiAgICAgIHBhcmFtZXRlck1hbmlwdWxhdGVFeHByZXNzaW9ucy5wdXNoKG1hbmlwdWxhdGVDYWxsYmFja1BhcmFtZXRlckFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChwYXJhbWV0ZXJNYW5pcHVsYXRlRXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1ldGVySWRlbnRpZmllcnMgPSBjYWxsYmFja0FzdE5vZGUudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24ucGFyYW1zLm1hcChcbiAgICAgIG5vZGUgPT4gbm9kZS5uYW1lKTtcblxuICByZXR1cm4gdC5hcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAvKiBwYXJhbXMgKi8gcGFyYW1ldGVySWRlbnRpZmllcnMsXG4gICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgcGFyYW1ldGVyTWFuaXB1bGF0ZUV4cHJlc3Npb25zLmNvbmNhdChcbiAgICAgICAgW1xuICAgICAgICAgIHQucmV0dXJuU3RhdGVtZW50KFxuICAgICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKGNhbGxiYWNrQXN0Tm9kZS5uYW1lKSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVySWRlbnRpZmllcnMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICksXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgKVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVFdmVudE1ldGhvZERlZmluaXRpb24oY2xhc3NEZWNsYXJhdGlvbjogYW55LCBtZXRob2REZWZpbml0aW9uOiBhbnkpOiBhbnkge1xuICB2YXIgcmVtb3RlRXZlbnRNZXRob2RCb2R5ID0gW107XG4gIHZhciBjYWxsYmFja1BhcmFtZXRlciA9IG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zWzBdO1xuXG4gIHZhciBtYW5pcHVsYXRlZENhbGxiYWNrXG4gICAgICA9IGNyZWF0ZU1hbmlwdWxhdGVkQ2FsbGJhY2tBcnJvd0Z1bmN0aW9uKG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zWzBdKTtcblxuICBpZiAobWFuaXB1bGF0ZWRDYWxsYmFjaykge1xuICAgIHZhciBjYWxsYmFja1BhcmFtZXRlciA9IHQuaWRlbnRpZmllcignXycgKyBjYWxsYmFja1BhcmFtZXRlci5uYW1lKTtcblxuICAgIHJlbW90ZUV2ZW50TWV0aG9kQm9keS5wdXNoKHQudmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgIC8qIGtpbmQgKi8gJ3ZhcicsXG4gICAgICAvKiBkZWNsYXJhdGlvbnMgKi8gW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgICAvKiBpZCAqLyBjYWxsYmFja1BhcmFtZXRlcixcbiAgICAgICAgICAvKiBpbml0ICovIG1hbmlwdWxhdGVkQ2FsbGJhY2tcbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICApKTtcbiAgfVxuXG4gIHJlbW90ZUV2ZW50TWV0aG9kQm9keS5wdXNoKFxuICAgIC8vIEFTVCBub2RlIG9mXG4gICAgLy8gYHJldHVybiB0aGlzLl9jb25uZWN0aW9uLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihcbiAgICAvLyAgICckY2xhc3NOYW1lLyRtZXRob2ROYW1lJyxcbiAgICAvLyAgIGNhbGxiYWNrLFxuICAgIC8vICAgdGhpcy5fb3B0aW9ucyxcbiAgICAvLyApO2BcbiAgICB0LnJldHVyblN0YXRlbWVudChcbiAgICAgIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdfY29ubmVjdGlvbicpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0LmlkZW50aWZpZXIoJ3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcicpXG4gICAgICAgICksXG4gICAgICAgIC8qIGFyZ3VtZW50cyAqLyBbXG4gICAgICAgICAgdC5saXRlcmFsKGNsYXNzRGVjbGFyYXRpb24uaWQubmFtZSArICcvJyArIG1ldGhvZERlZmluaXRpb24ua2V5Lm5hbWUpLFxuICAgICAgICAgIGNhbGxiYWNrUGFyYW1ldGVyLFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LnRoaXNFeHByZXNzaW9uKCksIHQuaWRlbnRpZmllcignX29wdGlvbnMnKSksXG4gICAgICAgIF1cbiAgICAgIClcbiAgICApXG4gICk7XG5cbiAgdmFyIHJlbW90ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHQuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIC8qIGlkICovIG51bGwsXG4gICAgLyogcGFyYW1zICovIG1ldGhvZERlZmluaXRpb24udmFsdWUucGFyYW1zLFxuICAgIC8qIGJvZHkgKi8gdC5ibG9ja1N0YXRlbWVudChyZW1vdGVFdmVudE1ldGhvZEJvZHkpLFxuICApO1xuXG4gIHJldHVybiB0Lm1ldGhvZERlZmluaXRpb24oXG4gICAgLyoga2V5ICovIHQuaWRlbnRpZmllcihtZXRob2REZWZpbml0aW9uLmtleS5uYW1lKSxcbiAgICAvKiB2YWx1ZSAqLyByZW1vdGVGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgLyoga2luZCAqLyAnbWV0aG9kJ1xuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVTZXJ2aWNlVHJhbnNmb3JtZXIoYmFzZUNsYXNzRmlsZVBhdGg6IHN0cmluZyk6IGFueSB7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtZXIoJ3JlbW90ZS1zZXJ2aWNlJywge1xuICAgIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgIC8vIFNraXAgY2xhc3NlcyB3aXRoIGBSZW1vdGVgIHByZWZpeCBhcyBpdCdzIGdlbmVyYXRlZC5cbiAgICAgIGlmIChub2RlLmlkLm5hbWUubGFzdEluZGV4T2YoR0VORVJBVEVEX0NMQVNTX1BSRUZJWCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgYmxvY2sgY29tbWVudCBgLyogZmxvdyAqL2AgZ2VuZXJhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUuXG4gICAgICAvLyBUaGUgd2F5IGJhYmVsIGRlYWwgd2l0aCBjb21tZW50cyBpcyBidWdneSwgaWYgd2Ugc3dpdGNoIGZvbGxvd2luZyB0d28gbGluZXM6XG4gICAgICAvLyBgYGBcbiAgICAgIC8vICAgdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlQmFzZUNsYXNzUmVxdWlyZUV4cHJlc3Npb24oLi4uKSk7XG4gICAgICAvLyAgIHJldHVybiBjcmVhdGVSZW1vdGVDbGFzc0RlY2xhcmF0aW9uKC4uLik7XG4gICAgICAvLyBgYGBcbiAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgY29kZSB3aWxsIGxvb2sgbGlrZTpcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gICAndXNlIGJhYmVsJztcbiAgICAgIC8vICAgdmFyIFRlc3RTZXJ2aWNlID0gcmVxdWlyZSgnLi4uJyk7XG4gICAgICAvLyAgIC8qIGZsb3cgKi9cbiAgICAgIC8vICAgY2xhc3MgUmVtb3RlVGVzdFNlcnZpY2UgZXh0ZW5kcyBUZXN0U2VydmljZSB7XG4gICAgICAvLyAgIC4uLlxuICAgICAgLy8gYGBgXG4gICAgICAvLyB3aGljaCBpcyBub3Qgd2hhdCB3ZSBleHBlY3QuXG4gICAgICB0aGlzLmluc2VydEFmdGVyKGNyZWF0ZVJlbW90ZUNsYXNzRGVjbGFyYXRpb24obm9kZSkpO1xuXG4gICAgICAvLyBSZXF1aXJlIHRoZSBhbmFseXRpY3MgcGFja2FnZS5cbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIoY3JlYXRlQW5hbHl0aWNzUmVxdWlyZUV4cHJlc3Npb24oKSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVCYXNlQ2xhc3NSZXF1aXJlRXhwcmVzc2lvbihub2RlLmlkLm5hbWUsIGJhc2VDbGFzc0ZpbGVQYXRoKTtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGBtb2R1bGUuZXhwb3J0c2AgdG8gZXhwb3J0IGdlbmVyYXRlZCByZW1vdGUgY2xhc3MuXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudDogKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgLy8gSWdub3JlIGV4cHJlc3Npb24gbm90IGluIGZvcm0gb2YgYG1vZHVsZS5leHBvcnRzID0gLi4uYC5cbiAgICAgIGlmICghdC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbikgfHxcbiAgICAgICAgICBub2RlLmV4cHJlc3Npb24ub3BlcmF0b3IgIT09ICc9JyB8fFxuICAgICAgICAgICF0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24ubGVmdCkgfHxcbiAgICAgICAgICAhdC5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uLmxlZnQub2JqZWN0KSB8fFxuICAgICAgICAgICF0LmlzSWRlbnRpZmllcihub2RlLmV4cHJlc3Npb24ubGVmdC5wcm9wZXJ0eSkgfHxcbiAgICAgICAgICBub2RlLmV4cHJlc3Npb24ubGVmdC5vYmplY3QubmFtZSAhPT0gJ21vZHVsZScgfHxcbiAgICAgICAgICBub2RlLmV4cHJlc3Npb24ubGVmdC5wcm9wZXJ0eS5uYW1lICE9PSAnZXhwb3J0cycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJpZ2h0ID0gbm9kZS5leHByZXNzaW9uLnJpZ2h0O1xuXG4gICAgICAvLyBJZiBleHByZXNzaW9uIHRha2VzIGZvcm0gYG1vZHVsZS5leHBvcnRzID0gJGlkZW50aWZpZXJgLCB0aGVuIHdlIGFyZSBleHBvcnRpbmdcbiAgICAgIC8vIG9ubHkgb25lIGNsYXNzLlxuICAgICAgaWYgKHQuaXNJZGVudGlmaWVyKHJpZ2h0KSkge1xuICAgICAgICBub2RlLmV4cHJlc3Npb24ucmlnaHQgPSB0LmlkZW50aWZpZXIoXG4gICAgICAgICAgR0VORVJBVEVEX0NMQVNTX1BSRUZJWCArIG5vZGUuZXhwcmVzc2lvbi5yaWdodC5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBleHByZXNzaW9uIHRha2VzIGZvcm0gYG1vZHVsZS5leHBvcnRzID0geyAkaWRlbnRpZmllciwgLi4uLCAkaWRlbnRpZmVyIH1gLCB0aGVuXG4gICAgICAvLyB3ZSBhcmUgZXhwb3J0aW5nIG11bHRpcGxlIGNsYXNzZXMuXG4gICAgICBpZiAodC5pc09iamVjdEV4cHJlc3Npb24ocmlnaHQpKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBhcmUgYWxsIGlkZW50aWZpZXIgOiBpZGVudGlmaWVyIG1hcHBpbnMuXG4gICAgICAgIHZhciBpZGVudGlmaWVycyA9IHJpZ2h0LnByb3BlcnRpZXMuZXZlcnkocHJvcCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHQuaXNJZGVudGlmaWVyKHByb3Aua2V5KSAmJiB0LmlzSWRlbnRpZmllcihwcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaWRlbnRpZmllcnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGVuZCBHRU5FUkFURURfQ0xBU1NfUFJFRklYIHRvIGV2ZXJ5IGtleSBhbmQgdmFsdWUuXG4gICAgICAgIHJpZ2h0LnByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICBwcm9wLnZhbHVlID0gdC5pZGVudGlmaWVyKEdFTkVSQVRFRF9DTEFTU19QUkVGSVggKyBwcm9wLnZhbHVlLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZW1vdGVTZXJ2aWNlVHJhbnNmb3JtZXI7XG4iXX0=
