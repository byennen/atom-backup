
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

module.exports = {

  /**
   * Returns a value derived asynchronously from an element in the items array.
   * The test function is applied sequentially to each element in items until
   * one returns a Promise that resolves to a non-null value. When this happens,
   * the Promise returned by this method will resolve to that non-null value. If
   * no such Promise is produced, then the Promise returned by this function
   * will resolve to null.
   *
   * @param items Array of elements that will be passed to test, one at a time.
   * @param test Will be called with each item and must return either:
   *     (1) A "thenable" (i.e, a Promise or promise-like object) that resolves
   *         to a derived value (that will be returned) or null.
   *     (2) null.
   *     In both cases where null is returned, test will be applied to the next
   *     item in the array.
   * @param thisArg Receiver that will be used when test is called.
   * @return Promise that resolves to an asynchronously derived value or null.
   */
  asyncFind: function asyncFind(items, test, thisArg) {
    return new Promise(function (resolve, reject) {
      // Create a local copy of items to defend against the caller modifying the
      // array before this Promise is resolved.
      items = items.slice();
      var numItems = items.length;

      var next = _asyncToGenerator(function* (index) {
        if (index === numItems) {
          resolve(null);
          return;
        }

        var item = items[index];
        var result = yield test.call(thisArg, item);
        if (result !== null) {
          resolve(result);
        } else {
          next(index + 1);
        }
      });

      next(0);
    });
  },

  denodeify: function denodeify(f) {
    return function () {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        function callback(error, result) {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        }
        f.apply(_this, args.concat([callback]));
      });
    };
  }

};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL3Byb21pc2VzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7O0FBVVosTUFBTSxDQUFDLE9BQU8sR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQmYsV0FBUyxFQUFBLG1CQUFDLEtBQVksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFXO0FBQzlDLFdBQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLOzs7QUFHdEMsV0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUN0QixVQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDOztBQUU1QixVQUFJLElBQUkscUJBQUcsV0FBZSxLQUFLLEVBQUU7QUFDL0IsWUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFO0FBQ3RCLGlCQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDZCxpQkFBTztTQUNSOztBQUVELFlBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4QixZQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzVDLFlBQUksTUFBTSxLQUFLLElBQUksRUFBRTtBQUNuQixpQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pCLE1BQU07QUFDTCxjQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pCO09BQ0YsQ0FBQSxDQUFDOztBQUVGLFVBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNULENBQUMsQ0FBQztHQUNKOztBQUVELFdBQVMsRUFBQSxtQkFBQyxDQUErQixFQUF5QztBQUNoRixXQUFPLFlBQThCOzs7d0NBQWxCLElBQUk7QUFBSixZQUFJOzs7QUFDckIsYUFBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDdEMsaUJBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDL0IsY0FBSSxLQUFLLEVBQUU7QUFDVCxrQkFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1dBQ2YsTUFBTTtBQUNMLG1CQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7V0FDakI7U0FDRjtBQUNELFNBQUMsQ0FBQyxLQUFLLFFBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUN4QyxDQUFDLENBQUM7S0FDSixDQUFDO0dBQ0g7O0NBRUYsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wZW1tMkh1cHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1jb21tb25zL2xpYi9wcm9taXNlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIGRlcml2ZWQgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBlbGVtZW50IGluIHRoZSBpdGVtcyBhcnJheS5cbiAgICogVGhlIHRlc3QgZnVuY3Rpb24gaXMgYXBwbGllZCBzZXF1ZW50aWFsbHkgdG8gZWFjaCBlbGVtZW50IGluIGl0ZW1zIHVudGlsXG4gICAqIG9uZSByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbm9uLW51bGwgdmFsdWUuIFdoZW4gdGhpcyBoYXBwZW5zLFxuICAgKiB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCB3aWxsIHJlc29sdmUgdG8gdGhhdCBub24tbnVsbCB2YWx1ZS4gSWZcbiAgICogbm8gc3VjaCBQcm9taXNlIGlzIHByb2R1Y2VkLCB0aGVuIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAgICogd2lsbCByZXNvbHZlIHRvIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyBBcnJheSBvZiBlbGVtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRlc3QsIG9uZSBhdCBhIHRpbWUuXG4gICAqIEBwYXJhbSB0ZXN0IFdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCBpdGVtIGFuZCBtdXN0IHJldHVybiBlaXRoZXI6XG4gICAqICAgICAoMSkgQSBcInRoZW5hYmxlXCIgKGkuZSwgYSBQcm9taXNlIG9yIHByb21pc2UtbGlrZSBvYmplY3QpIHRoYXQgcmVzb2x2ZXNcbiAgICogICAgICAgICB0byBhIGRlcml2ZWQgdmFsdWUgKHRoYXQgd2lsbCBiZSByZXR1cm5lZCkgb3IgbnVsbC5cbiAgICogICAgICgyKSBudWxsLlxuICAgKiAgICAgSW4gYm90aCBjYXNlcyB3aGVyZSBudWxsIGlzIHJldHVybmVkLCB0ZXN0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbmV4dFxuICAgKiAgICAgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB0aGlzQXJnIFJlY2VpdmVyIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gdGVzdCBpcyBjYWxsZWQuXG4gICAqIEByZXR1cm4gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFzeW5jaHJvbm91c2x5IGRlcml2ZWQgdmFsdWUgb3IgbnVsbC5cbiAgICovXG4gIGFzeW5jRmluZChpdGVtczogYXJyYXksIHRlc3QsIHRoaXNBcmcpOiBQcm9taXNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgbG9jYWwgY29weSBvZiBpdGVtcyB0byBkZWZlbmQgYWdhaW5zdCB0aGUgY2FsbGVyIG1vZGlmeWluZyB0aGVcbiAgICAgIC8vIGFycmF5IGJlZm9yZSB0aGlzIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKCk7XG4gICAgICB2YXIgbnVtSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgIHZhciBuZXh0ID0gYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBudW1JdGVtcykge1xuICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgICAgIHZhciByZXN1bHQgPSBhd2FpdCB0ZXN0LmNhbGwodGhpc0FyZywgaXRlbSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dChpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuZXh0KDApO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlbm9kZWlmeShmOiAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55KTogKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IEFycmF5PGFueT4pIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG59O1xuIl19
