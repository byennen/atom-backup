
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var path = require('path');

var _require = require('atom');

var Disposable = _require.Disposable;
var Emitter = _require.Emitter;

var logger = require('nuclide-logging').getLogger();
var remoteUri = require('nuclide-remote-uri');

var MARKER_PROPERTY_FOR_REMOTE_DIRECTORY = '__nuclide_remote_directory__';

/* Mostly implements https://atom.io/docs/api/latest/Directory */

var RemoteDirectory = (function () {
  _createClass(RemoteDirectory, null, [{
    key: 'isRemoteDirectory',
    value: function isRemoteDirectory(directory) {
      return directory[MARKER_PROPERTY_FOR_REMOTE_DIRECTORY] === true;
    }
  }]);

  /**
   * @param uri should be of the form "nuclide://example.com:9090/path/to/directory".
   */

  function RemoteDirectory(remote, uri, options) {
    _classCallCheck(this, RemoteDirectory);

    Object.defineProperty(this, MARKER_PROPERTY_FOR_REMOTE_DIRECTORY, { value: true });
    this._remote = remote;
    this._uri = uri;
    this._emitter = new Emitter();
    this._subscriptionCount = 0;

    var _remoteUri$parse = remoteUri.parse(uri);

    var directoryPath = _remoteUri$parse.path;
    var protocol = _remoteUri$parse.protocol;
    var host = _remoteUri$parse.host;

    /** In the example, this would be "nuclide://example.com:9090". */
    this._host = protocol + '//' + host;
    /** In the example, this would be "/path/to/directory". */
    this._localPath = directoryPath;
    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.
    this._hgRepositoryDescription = options ? options.hgRepositoryDescription : null;
  }

  _createClass(RemoteDirectory, [{
    key: 'onDidChange',
    value: function onDidChange(callback) {
      this._willAddSubscription();
      return this._trackUnsubscription(this._emitter.on('did-change', callback));
    }
  }, {
    key: '_willAddSubscription',
    value: _asyncToGenerator(function* () {
      this._subscriptionCount++;
      if (this._pendingSubscription) {
        return;
      }
      this._pendingSubscription = true;
      try {
        yield this._subscribeToNativeChangeEvents();
      } catch (err) {
        logger.error('Failed to subscribe RemoteDirectory:', this._localPath, err);
      } finally {
        this._pendingSubscription = false;
      }
    })
  }, {
    key: '_subscribeToNativeChangeEvents',
    value: _asyncToGenerator(function* () {
      var _this = this;

      if (this._watchSubscription) {
        return;
      }
      this._watchSubscription = yield this._remote.getClient().watchDirectory(this._localPath);
      this._watchSubscription.on('change', function (change) {
        return _this._handleNativeChangeEvent(change);
      });
    })
  }, {
    key: '_handleNativeChangeEvent',
    value: function _handleNativeChangeEvent(changes) {
      this._emitter.emit('did-change', changes);
    }
  }, {
    key: '_trackUnsubscription',
    value: function _trackUnsubscription(subscription) {
      var _this2 = this;

      return new Disposable(function () {
        subscription.dispose();
        _this2._didRemoveSubscription();
      });
    }
  }, {
    key: '_didRemoveSubscription',
    value: function _didRemoveSubscription() {
      this._subscriptionCount--;
      if (this._subscriptionCount === 0) {
        return this._unsubscribeFromNativeChangeEvents();
      }
    }
  }, {
    key: '_unsubscribeFromNativeChangeEvents',
    value: _asyncToGenerator(function* () {
      if (this._watchSubscription) {
        yield this._remote.getClient().unwatchDirectory(this._localPath);
        this._watchSubscription = null;
      }
    })
  }, {
    key: 'isFile',
    value: function isFile() {
      return false;
    }
  }, {
    key: 'isDirectory',
    value: function isDirectory() {
      return true;
    }
  }, {
    key: 'isRoot',
    value: function isRoot() {
      return this._isRoot(this._localPath);
    }
  }, {
    key: '_isRoot',
    value: function _isRoot(filePath) {
      filePath = path.normalize(filePath);
      var parts = path.parse(filePath);
      return parts.root === filePath;
    }
  }, {
    key: 'getPath',
    value: function getPath() {
      return this._uri;
    }
  }, {
    key: 'getLocalPath',
    value: function getLocalPath() {
      return this._localPath;
    }
  }, {
    key: 'getHost',
    value: function getHost() {
      return this._host;
    }
  }, {
    key: 'getRealPathSync',
    value: function getRealPathSync() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getBaseName',
    value: function getBaseName() {
      return path.basename(this._localPath);
    }
  }, {
    key: 'relativize',
    value: function relativize(uri) {
      if (!uri) {
        return uri;
      }
      // Note: host of uri must match this._host.
      var subpath = remoteUri.parse(uri).path;
      return path.relative(this._localPath, subpath);
    }
  }, {
    key: 'getParent',
    value: function getParent() {
      if (this.isRoot()) {
        return this;
      } else {
        var uri = this._host + path.normalize(path.join(this._localPath, '..'));
        return this._remote.createDirectory(uri);
      }
    }
  }, {
    key: 'getFile',
    value: function getFile(filename) {
      var uri = this._host + path.join(this._localPath, filename);
      return this._remote.createFile(uri);
    }
  }, {
    key: 'getSubdirectory',
    value: function getSubdirectory(dirname) {
      var uri = this._host + path.join(this._localPath, dirname);
      return this._remote.createDirectory(uri);
    }
  }, {
    key: 'create',
    value: _asyncToGenerator(function* () {
      yield this._remote.getClient().mkdirp(this._localPath);
      if (this._subscriptionCount > 0) {
        this._subscribeToNativeChangeEvents();
      }
    })
  }, {
    key: 'delete',
    value: _asyncToGenerator(function* () {
      yield this._remote.getClient().rmdir(this._localPath);
      this._unsubscribeFromNativeChangeEvents();
    })

    /**
     * Renames this directory to the given absolute path.
     */
  }, {
    key: 'rename',
    value: _asyncToGenerator(function* (newPath) {
      yield this._remote.getClient().rename(this._localPath, newPath);

      // Unsubscribe from the old `this._localPath`. This must be done before
      // setting the new `this._localPath`.
      yield this._unsubscribeFromNativeChangeEvents();

      var _remoteUri$parse2 = remoteUri.parse(this._uri);

      var protocol = _remoteUri$parse2.protocol;
      var host = _remoteUri$parse2.host;

      this._localPath = newPath;
      this._uri = protocol + '//' + host + this._localPath;

      // Subscribe to changes for the new `this._localPath`. This must be done
      // after setting the new `this._localPath`.
      if (this._subscriptionCount > 0) {
        yield this._subscribeToNativeChangeEvents();
      }
    })
  }, {
    key: 'getEntriesSync',
    value: function getEntriesSync() {
      throw new Error('not implemented');
    }
  }, {
    key: 'getEntries',
    value: _asyncToGenerator(function* (callback) {
      var _this3 = this;

      var entries = yield this._remote.getClient().readdir(this._localPath);
      var directories = [];
      var files = [];
      entries.sort(function (a, b) {
        return a.file.toLowerCase().localeCompare(b.file.toLowerCase());
      }).forEach(function (entry) {
        var uri = _this3._host + path.join(_this3._localPath, entry.file);
        if (entry.stats.isFile()) {
          files.push(_this3._remote.createFile(uri));
        } else {
          directories.push(_this3._remote.createDirectory(uri));
        }
      });
      callback(null, directories.concat(files));
    })
  }, {
    key: 'contains',
    value: function contains(pathToCheck) {
      // Ideally, the type of pathToCheck would be `string` rather than `?string`;
      // however, as shown by https://github.com/atom/git-diff/pull/53,
      // `editor.getPath()` unexpectedly returns `?string` rather than `string`,
      // and its return value is often used with this method, so it is important
      // to tolerate null as an input.
      if (pathToCheck) {
        return pathToCheck.startsWith(this.getPath());
      } else {
        return false;
      }
    }
  }, {
    key: 'off',
    value: function off() {}
    // This method is part of the EmitterMixin used by Atom's local Directory, but not documented
    // as part of the API - https://atom.io/docs/api/latest/Directory,
    // However, it appears to be called in project.coffee by Atom.

    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.

  }, {
    key: 'getHgRepositoryDescription',
    value: function getHgRepositoryDescription() {
      return this._hgRepositoryDescription;
    }
  }]);

  return RemoteDirectory;
})();

module.exports = RemoteDirectory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9SZW1vdGVEaXJlY3RvcnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBV1osSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztlQUNDLE9BQU8sQ0FBQyxNQUFNLENBQUM7O0lBQXRDLFVBQVUsWUFBVixVQUFVO0lBQUUsT0FBTyxZQUFQLE9BQU87O0FBQ3hCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ3BELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOztBQUU5QyxJQUFJLG9DQUFvQyxHQUFHLDhCQUE4QixDQUFDOzs7O0lBR3BFLGVBQWU7ZUFBZixlQUFlOztXQUNLLDJCQUFDLFNBQXNDLEVBQVc7QUFDeEUsYUFBTyxTQUFTLENBQUMsb0NBQW9DLENBQUMsS0FBSyxJQUFJLENBQUM7S0FDakU7Ozs7Ozs7QUFPVSxXQVZQLGVBQWUsQ0FVUCxNQUF3QixFQUFFLEdBQVcsRUFBRSxPQUFhLEVBQUU7MEJBVjlELGVBQWU7O0FBV2pCLFVBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLG9DQUFvQyxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7QUFDakYsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdEIsUUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDaEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO0FBQzlCLFFBQUksQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUM7OzJCQUNnQixTQUFTLENBQUMsS0FB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QyxPQUFLLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNyRDtPQUNGLENBQUMsQ0FBQztBQUNILGNBQVEsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQzNDOzs7V0FFTyxrQkFBQyxXQUFvQixFQUFXOzs7Ozs7QUFNdEMsVUFBSSxXQUFXLEVBQUU7QUFDZixlQUFPLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7T0FDL0MsTUFBTTtBQUNMLGVBQU8sS0FBSyxDQUFDO09BQ2Q7S0FDRjs7O1dBRUUsZUFBRyxFQUlMOzs7Ozs7QUFBQTs7O1dBR3lCLHNDQUFHO0FBQzNCLGFBQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDO0tBQ3RDOzs7U0E1TkcsZUFBZTs7O0FBK05yQixNQUFNLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wZW1tMkh1cHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1yZW1vdGUtY29ubmVjdGlvbi9saWIvUmVtb3RlRGlyZWN0b3J5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIge0Rpc3Bvc2FibGUsIEVtaXR0ZXJ9ID0gcmVxdWlyZSgnYXRvbScpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xudmFyIHJlbW90ZVVyaSA9IHJlcXVpcmUoJ251Y2xpZGUtcmVtb3RlLXVyaScpO1xuXG52YXIgTUFSS0VSX1BST1BFUlRZX0ZPUl9SRU1PVEVfRElSRUNUT1JZID0gJ19fbnVjbGlkZV9yZW1vdGVfZGlyZWN0b3J5X18nO1xuXG4vKiBNb3N0bHkgaW1wbGVtZW50cyBodHRwczovL2F0b20uaW8vZG9jcy9hcGkvbGF0ZXN0L0RpcmVjdG9yeSAqL1xuY2xhc3MgUmVtb3RlRGlyZWN0b3J5IHtcbiAgc3RhdGljIGlzUmVtb3RlRGlyZWN0b3J5KGRpcmVjdG9yeTogRGlyZWN0b3J5IHwgUmVtb3RlRGlyZWN0b3J5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRpcmVjdG9yeVtNQVJLRVJfUFJPUEVSVFlfRk9SX1JFTU9URV9ESVJFQ1RPUlldID09PSB0cnVlO1xuICB9XG5cbiAgX3dhdGNoU3Vic2NyaXB0aW9uOiA/RnNXYXRjaGVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdXJpIHNob3VsZCBiZSBvZiB0aGUgZm9ybSBcIm51Y2xpZGU6Ly9leGFtcGxlLmNvbTo5MDkwL3BhdGgvdG8vZGlyZWN0b3J5XCIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW1vdGU6IFJlbW90ZUNvbm5lY3Rpb24sIHVyaTogc3RyaW5nLCBvcHRpb25zOiA/YW55KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE1BUktFUl9QUk9QRVJUWV9GT1JfUkVNT1RFX0RJUkVDVE9SWSwge3ZhbHVlOiB0cnVlfSk7XG4gICAgdGhpcy5fcmVtb3RlID0gcmVtb3RlO1xuICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25Db3VudCA9IDA7XG4gICAgdmFyIHtwYXRoOiBkaXJlY3RvcnlQYXRoLCBwcm90b2NvbCwgaG9zdH0gPSByZW1vdGVVcmkucGFyc2UodXJpKTtcbiAgICAvKiogSW4gdGhlIGV4YW1wbGUsIHRoaXMgd291bGQgYmUgXCJudWNsaWRlOi8vZXhhbXBsZS5jb206OTA5MFwiLiAqL1xuICAgIHRoaXMuX2hvc3QgPSBwcm90b2NvbCArICcvLycgKyBob3N0O1xuICAgIC8qKiBJbiB0aGUgZXhhbXBsZSwgdGhpcyB3b3VsZCBiZSBcIi9wYXRoL3RvL2RpcmVjdG9yeVwiLiAqL1xuICAgIHRoaXMuX2xvY2FsUGF0aCA9IGRpcmVjdG9yeVBhdGg7XG4gICAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogc2VlIDo6Z2V0SGdSZXBvSW5mbyBvZiBtYWluLmpzLlxuICAgIHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uID0gb3B0aW9ucyA/IG9wdGlvbnMuaGdSZXBvc2l0b3J5RGVzY3JpcHRpb24gOiBudWxsO1xuICB9XG5cbiAgb25EaWRDaGFuZ2UoY2FsbGJhY2spOiBEaXNwb3NhYmxlIHtcbiAgICB0aGlzLl93aWxsQWRkU3Vic2NyaXB0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrVW5zdWJzY3JpcHRpb24odGhpcy5fZW1pdHRlci5vbignZGlkLWNoYW5nZScsIGNhbGxiYWNrKSk7XG4gIH1cblxuICBhc3luYyBfd2lsbEFkZFN1YnNjcmlwdGlvbigpOiBQcm9taXNlIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25Db3VudCsrO1xuICAgIGlmICh0aGlzLl9wZW5kaW5nU3Vic2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmdTdWJzY3JpcHRpb24gPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9zdWJzY3JpYmVUb05hdGl2ZUNoYW5nZUV2ZW50cygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIFJlbW90ZURpcmVjdG9yeTonLCB0aGlzLl9sb2NhbFBhdGgsIGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BlbmRpbmdTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfc3Vic2NyaWJlVG9OYXRpdmVDaGFuZ2VFdmVudHMoKTogUHJvbWlzZSB7XG4gICAgaWYgKHRoaXMuX3dhdGNoU3Vic2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3dhdGNoU3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5fcmVtb3RlLmdldENsaWVudCgpLndhdGNoRGlyZWN0b3J5KHRoaXMuX2xvY2FsUGF0aCk7XG4gICAgdGhpcy5fd2F0Y2hTdWJzY3JpcHRpb24ub24oJ2NoYW5nZScsIChjaGFuZ2UpID0+IHRoaXMuX2hhbmRsZU5hdGl2ZUNoYW5nZUV2ZW50KGNoYW5nZSkpO1xuICB9XG5cbiAgX2hhbmRsZU5hdGl2ZUNoYW5nZUV2ZW50KGNoYW5nZXM6IEFycmF5PEZpbGVDaGFuZ2U+KSB7XG4gICAgdGhpcy5fZW1pdHRlci5lbWl0KCdkaWQtY2hhbmdlJywgY2hhbmdlcyk7XG4gIH1cblxuICBfdHJhY2tVbnN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pOiBEaXNwb3NhYmxlIHtcbiAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2RpZFJlbW92ZVN1YnNjcmlwdGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgX2RpZFJlbW92ZVN1YnNjcmlwdGlvbigpOiBQcm9taXNlIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25Db3VudC0tO1xuICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25Db3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Vuc3Vic2NyaWJlRnJvbU5hdGl2ZUNoYW5nZUV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91bnN1YnNjcmliZUZyb21OYXRpdmVDaGFuZ2VFdmVudHMoKTogUHJvbWlzZSB7XG4gICAgaWYgKHRoaXMuX3dhdGNoU3Vic2NyaXB0aW9uKSB7XG4gICAgICBhd2FpdCB0aGlzLl9yZW1vdGUuZ2V0Q2xpZW50KCkudW53YXRjaERpcmVjdG9yeSh0aGlzLl9sb2NhbFBhdGgpO1xuICAgICAgdGhpcy5fd2F0Y2hTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlzRmlsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0RpcmVjdG9yeSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzUm9vdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXNSb290KHRoaXMuX2xvY2FsUGF0aCk7XG4gIH1cblxuICBfaXNSb290KGZpbGVQYXRoKSB7XG4gICAgZmlsZVBhdGggPSBwYXRoLm5vcm1hbGl6ZShmaWxlUGF0aCk7XG4gICAgdmFyIHBhcnRzID0gcGF0aC5wYXJzZShmaWxlUGF0aCk7XG4gICAgcmV0dXJuIHBhcnRzLnJvb3QgPT09IGZpbGVQYXRoO1xuICB9XG5cbiAgZ2V0UGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl91cmk7XG4gIH1cblxuICBnZXRMb2NhbFBhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxQYXRoO1xuICB9XG5cbiAgZ2V0SG9zdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9ob3N0O1xuICB9XG5cbiAgZ2V0UmVhbFBhdGhTeW5jKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEJhc2VOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGguYmFzZW5hbWUodGhpcy5fbG9jYWxQYXRoKTtcbiAgfVxuXG4gIHJlbGF0aXZpemUodXJpOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdXJpKSB7XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICAvLyBOb3RlOiBob3N0IG9mIHVyaSBtdXN0IG1hdGNoIHRoaXMuX2hvc3QuXG4gICAgdmFyIHN1YnBhdGggPSByZW1vdGVVcmkucGFyc2UodXJpKS5wYXRoO1xuICAgIHJldHVybiBwYXRoLnJlbGF0aXZlKHRoaXMuX2xvY2FsUGF0aCwgc3VicGF0aCk7XG4gIH1cblxuICBnZXRQYXJlbnQoKTogUmVtb3RlRGlyZWN0b3J5IHtcbiAgICBpZiAodGhpcy5pc1Jvb3QoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5ub3JtYWxpemUocGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgJy4uJykpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZS5jcmVhdGVEaXJlY3RvcnkodXJpKTtcbiAgICB9XG4gIH1cblxuICBnZXRGaWxlKGZpbGVuYW1lOiBzdHJpbmcpOiBSZW1vdGVGaWxlIHtcbiAgICB2YXIgdXJpID0gdGhpcy5faG9zdCArIHBhdGguam9pbih0aGlzLl9sb2NhbFBhdGgsIGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fcmVtb3RlLmNyZWF0ZUZpbGUodXJpKTtcbiAgfVxuXG4gIGdldFN1YmRpcmVjdG9yeShkaXJuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHZhciB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgZGlybmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZS5jcmVhdGVEaXJlY3RvcnkodXJpKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBhd2FpdCB0aGlzLl9yZW1vdGUuZ2V0Q2xpZW50KCkubWtkaXJwKHRoaXMuX2xvY2FsUGF0aCk7XG4gICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbkNvdW50ID4gMCkge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9OYXRpdmVDaGFuZ2VFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWxldGUoKTogUHJvbWlzZSB7XG4gICAgYXdhaXQgdGhpcy5fcmVtb3RlLmdldENsaWVudCgpLnJtZGlyKHRoaXMuX2xvY2FsUGF0aCk7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmVGcm9tTmF0aXZlQ2hhbmdlRXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuYW1lcyB0aGlzIGRpcmVjdG9yeSB0byB0aGUgZ2l2ZW4gYWJzb2x1dGUgcGF0aC5cbiAgICovXG4gIGFzeW5jIHJlbmFtZShuZXdQYXRoOiBzdHJpbmcpOiBQcm9taXNlIHtcbiAgICBhd2FpdCB0aGlzLl9yZW1vdGUuZ2V0Q2xpZW50KCkucmVuYW1lKHRoaXMuX2xvY2FsUGF0aCwgbmV3UGF0aCk7XG5cbiAgICAvLyBVbnN1YnNjcmliZSBmcm9tIHRoZSBvbGQgYHRoaXMuX2xvY2FsUGF0aGAuIFRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZVxuICAgIC8vIHNldHRpbmcgdGhlIG5ldyBgdGhpcy5fbG9jYWxQYXRoYC5cbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUZyb21OYXRpdmVDaGFuZ2VFdmVudHMoKTtcblxuICAgIHZhciB7cHJvdG9jb2wsIGhvc3R9ID0gcmVtb3RlVXJpLnBhcnNlKHRoaXMuX3VyaSk7XG4gICAgdGhpcy5fbG9jYWxQYXRoID0gbmV3UGF0aDtcbiAgICB0aGlzLl91cmkgPSBwcm90b2NvbCArICcvLycgKyBob3N0ICsgdGhpcy5fbG9jYWxQYXRoO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgZm9yIHRoZSBuZXcgYHRoaXMuX2xvY2FsUGF0aGAuIFRoaXMgbXVzdCBiZSBkb25lXG4gICAgLy8gYWZ0ZXIgc2V0dGluZyB0aGUgbmV3IGB0aGlzLl9sb2NhbFBhdGhgLlxuICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25Db3VudCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmliZVRvTmF0aXZlQ2hhbmdlRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RW50cmllc1N5bmMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGFzeW5jIGdldEVudHJpZXMoY2FsbGJhY2spIHtcbiAgICB2YXIgZW50cmllcyA9IGF3YWl0IHRoaXMuX3JlbW90ZS5nZXRDbGllbnQoKS5yZWFkZGlyKHRoaXMuX2xvY2FsUGF0aCk7XG4gICAgdmFyIGRpcmVjdG9yaWVzID0gW107XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYS5maWxlLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShiLmZpbGUudG9Mb3dlckNhc2UoKSk7XG4gICAgfSkuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIHZhciB1cmkgPSB0aGlzLl9ob3N0ICsgcGF0aC5qb2luKHRoaXMuX2xvY2FsUGF0aCwgZW50cnkuZmlsZSk7XG4gICAgICBpZiAoZW50cnkuc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgZmlsZXMucHVzaCh0aGlzLl9yZW1vdGUuY3JlYXRlRmlsZSh1cmkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdG9yaWVzLnB1c2godGhpcy5fcmVtb3RlLmNyZWF0ZURpcmVjdG9yeSh1cmkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjYWxsYmFjayhudWxsLCBkaXJlY3Rvcmllcy5jb25jYXQoZmlsZXMpKTtcbiAgfVxuXG4gIGNvbnRhaW5zKHBhdGhUb0NoZWNrOiA/c3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gSWRlYWxseSwgdGhlIHR5cGUgb2YgcGF0aFRvQ2hlY2sgd291bGQgYmUgYHN0cmluZ2AgcmF0aGVyIHRoYW4gYD9zdHJpbmdgO1xuICAgIC8vIGhvd2V2ZXIsIGFzIHNob3duIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2dpdC1kaWZmL3B1bGwvNTMsXG4gICAgLy8gYGVkaXRvci5nZXRQYXRoKClgIHVuZXhwZWN0ZWRseSByZXR1cm5zIGA/c3RyaW5nYCByYXRoZXIgdGhhbiBgc3RyaW5nYCxcbiAgICAvLyBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyBvZnRlbiB1c2VkIHdpdGggdGhpcyBtZXRob2QsIHNvIGl0IGlzIGltcG9ydGFudFxuICAgIC8vIHRvIHRvbGVyYXRlIG51bGwgYXMgYW4gaW5wdXQuXG4gICAgaWYgKHBhdGhUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gcGF0aFRvQ2hlY2suc3RhcnRzV2l0aCh0aGlzLmdldFBhdGgoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBvZmYoKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgRW1pdHRlck1peGluIHVzZWQgYnkgQXRvbSdzIGxvY2FsIERpcmVjdG9yeSwgYnV0IG5vdCBkb2N1bWVudGVkXG4gICAgLy8gYXMgcGFydCBvZiB0aGUgQVBJIC0gaHR0cHM6Ly9hdG9tLmlvL2RvY3MvYXBpL2xhdGVzdC9EaXJlY3RvcnksXG4gICAgLy8gSG93ZXZlciwgaXQgYXBwZWFycyB0byBiZSBjYWxsZWQgaW4gcHJvamVjdC5jb2ZmZWUgYnkgQXRvbS5cbiAgfVxuXG4gIC8vIEEgd29ya2Fyb3VuZCBiZWZvcmUgQXRvbSAyLjA6IHNlZSA6OmdldEhnUmVwb0luZm8gb2YgbWFpbi5qcy5cbiAgZ2V0SGdSZXBvc2l0b3J5RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRGlyZWN0b3J5O1xuIl19
