
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

// Section: Revision Sets

/**
 * @param revision The revision expression of a revision of interest.
 * @param workingDirectory The working directory of the Hg repository.
 * @return An expression for the common ancestor of the revision of interest and
 * the current Hg head.
 */

var fetchCommonAncestorOfHeadAndRevision = _asyncToGenerator(function* (revision, workingDirectory) {
  var _require = require('nuclide-commons');

  var asyncExecute = _require.asyncExecute;

  var ancestorExpression = 'ancestor(' + revision + ', ' + HG_CURRENT_WORKING_DIRECTORY_PARENT + ')';
  // shell-escape does not wrap ancestorExpression in quotes without this toString conversion.
  ancestorExpression = ancestorExpression.toString();

  // shell-escape does not wrap '{rev}' in quotes unless it is double-quoted.
  var args = ['log', '--template', "{rev}", '--rev', ancestorExpression];
  var options = {
    cwd: workingDirectory
  };

  try {
    var _ref = yield asyncExecute('hg', args, options);

    var ancestorRevisionNumber = _ref.stdout;

    return ancestorRevisionNumber;
  } catch (e) {
    logger.warn('Failed to get hg common ancestor: ', e.stderr, e.command);
    throw new Error('Could not fetch common ancestor of head and revision: ' + revision);
  }
}

/**
 * @param revisionFrom The revision expression of the "start" (older) revision.
 * @param revisionTo The revision expression of the "end" (newer) revision.
 * @param workingDirectory The working directory of the Hg repository.
 * @return An array of revision numbers that are between revisionFrom and
 *   revisionTo, plus revisionFrom and revisionTo; and the values
 *   are all 'true'. "Between" means that revisionFrom is an ancestor of, and
 *   revisionTo is a descendant of.
 */
);

var fetchRevisionNumbersBetweenRevisions = _asyncToGenerator(function* (revisionFrom, revisionTo, workingDirectory) {
  var _require2 = require('nuclide-commons');

  var asyncExecute = _require2.asyncExecute;

  var revisionExpression = revisionFrom + '::' + revisionTo;
  // shell-escape does not wrap revisionExpression in quotes without this toString conversion.
  revisionExpression = revisionExpression.toString();

  // shell-escape does not wrap '{rev}' in quotes unless it is double-quoted.
  var args = ['log', '--template', "{rev}\n", "--rev", revisionExpression];
  var options = {
    cwd: workingDirectory
  };

  try {
    var _ref2 = yield asyncExecute('hg', args, options);

    var revisionNumbersString = _ref2.stdout;

    return parseRevisionNumbersOutput(revisionNumbersString);
  } catch (e) {
    logger.warn('Failed to get revision numbers between two revisions: ', e.stderr, e.command);
    throw new Error('Could not fetch revision numbers between the revisions: ' + revisionFrom + ', ' + revisionTo);
  }
}

/**
 * Helper function to `fetchRevisionsNumbersBetweenRevisions`.
 */
);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

var logger = require('nuclide-logging').getLogger();

/**
 * This file contains utilities for getting an expression to specify a certain
 * revision in Hg (i.e. something that can be passed to the '--rev' option of
 * an Hg command).
 * Note: "Head" in this set of helper functions refers to the "current working
 * directory parent" in Hg terms.
 */

// Section: Expression Formation

var HG_CURRENT_WORKING_DIRECTORY_PARENT = ".";

/**
 * @param revisionExpression An expression that can be passed to hg as an argument
 * to the '--rev' option.
 * @param numberOfRevsBefore The number of revisions before the current revision
 * that you want a revision expression for. Passing 0 here will simply return 'revisionExpression'.
 * @return An expression for the 'numberOfRevsBefore'th revision before the given revision.
 */
function expressionForRevisionsBefore(revisionExpression, numberOfRevsBefore) {
  if (numberOfRevsBefore === 0) {
    return revisionExpression;
  } else {
    return revisionExpression + '~' + numberOfRevsBefore.toString();
  }
}

function expressionForRevisionsBeforeHead(numberOfRevsBefore) {
  if (numberOfRevsBefore < 0) {
    numberOfRevsBefore = 0;
  }
  return expressionForRevisionsBefore(HG_CURRENT_WORKING_DIRECTORY_PARENT, numberOfRevsBefore);
}function parseRevisionNumbersOutput(revisionNumbersOutput) {
  var numbers = revisionNumbersOutput.split('\n');
  var result = [];
  numbers.forEach(function (numberString) {
    var trimmedNumber = numberString.trim();
    if (trimmedNumber.length) {
      result.push(trimmedNumber);
    }
  });
  return result;
}

module.exports = {
  fetchCommonAncestorOfHeadAndRevision: fetchCommonAncestorOfHeadAndRevision,
  fetchRevisionNumbersBetweenRevisions: fetchRevisionNumbersBetweenRevisions,
  expressionForRevisionsBeforeHead: expressionForRevisionsBeforeHead
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvaGctcmV2aXNpb24tZXhwcmVzc2lvbi1oZWxwZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdERyxvQ0FBb0MscUJBQW5ELFdBQW9ELFFBQWdCLEVBQUUsZ0JBQXdCLEVBQW1CO2lCQUMxRixPQUFPLENBQUMsaUJBQWlCLENBQUM7O01BQTFDLFlBQVksWUFBWixZQUFZOztBQUVqQixNQUFJLGtCQUFrQixpQkFBZSxRQUFRLFVBQUssbUNBQW1DLE1BQUcsQ0FBQzs7QUFFekYsb0JBQWtCLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLENBQUM7OztBQUduRCxNQUFJLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3ZFLE1BQUksT0FBTyxHQUFHO0FBQ1osT0FBRyxFQUFFLGdCQUFnQjtHQUN0QixDQUFDOztBQUVGLE1BQUk7ZUFDcUMsTUFBTSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7O1FBQWpFLHNCQUFzQixRQUE5QixNQUFNOztBQUNYLFdBQU8sc0JBQXNCLENBQUM7R0FDL0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUNWLFVBQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkUsVUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsR0FBRyxRQUFRLENBQUMsQ0FBQztHQUN0RjtDQUNGOzs7Ozs7Ozs7Ozs7O0lBV2Msb0NBQW9DLHFCQUFuRCxXQUNJLFlBQW9CLEVBQUUsVUFBa0IsRUFBRSxnQkFBd0IsRUFBMEI7a0JBQ3pFLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQzs7TUFBMUMsWUFBWSxhQUFaLFlBQVk7O0FBRWpCLE1BQUksa0JBQWtCLEdBQU0sWUFBWSxVQUFLLFVBQVUsQUFBRSxDQUFDOztBQUUxRCxvQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQzs7O0FBR25ELE1BQUksSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFDekUsTUFBSSxPQUFPLEdBQUc7QUFDWixPQUFHLEVBQUUsZ0JBQWdCO0dBQ3RCLENBQUM7O0FBRUYsTUFBSTtnQkFDb0MsTUFBTSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7O1FBQWhFLHFCQUFxQixTQUE3QixNQUFNOztBQUNYLFdBQU8sMEJBQTBCLENBQUMscUJBQXFCLENBQUMsQ0FBQztHQUMxRCxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ1YsVUFBTSxDQUFDLElBQUksQ0FBQyx3REFBd0QsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzRixVQUFNLElBQUksS0FBSyw4REFBNEQsWUFBWSxVQUFLLFVBQVUsQ0FBRyxDQUFDO0dBQzNHO0NBQ0Y7Ozs7Ozs7OztBQWpHRCxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWXBELElBQUksbUNBQW1DLEdBQUcsR0FBRyxDQUFDOzs7Ozs7Ozs7QUFTOUMsU0FBUyw0QkFBNEIsQ0FBQyxrQkFBMEIsRUFBRSxrQkFBMEIsRUFBVTtBQUNwRyxNQUFJLGtCQUFrQixLQUFLLENBQUMsRUFBRTtBQUM1QixXQUFPLGtCQUFrQixDQUFDO0dBQzNCLE1BQU07QUFDTCxXQUFPLGtCQUFrQixHQUFHLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztHQUNqRTtDQUNGOztBQUVELFNBQVMsZ0NBQWdDLENBQUMsa0JBQTBCLEVBQVU7QUFDNUUsTUFBSSxrQkFBa0IsR0FBRyxDQUFDLEVBQUU7QUFDMUIsc0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0dBQ3hCO0FBQ0QsU0FBTyw0QkFBNEIsQ0FBQyxtQ0FBbUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0NBQzlGLEFBb0VELFNBQVMsMEJBQTBCLENBQUMscUJBQXFCLEVBQWlCO0FBQ3hFLE1BQUksT0FBTyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoRCxNQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsU0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFBLFlBQVksRUFBSTtBQUM5QixRQUFJLGFBQWEsR0FBRyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDeEMsUUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFO0FBQ3hCLFlBQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDNUI7R0FDRixDQUFDLENBQUM7QUFDSCxTQUFPLE1BQU0sQ0FBQztDQUNmOztBQUdELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixzQ0FBb0MsRUFBcEMsb0NBQW9DO0FBQ3BDLHNDQUFvQyxFQUFwQyxvQ0FBb0M7QUFDcEMsa0NBQWdDLEVBQWhDLGdDQUFnQztDQUNqQyxDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvaGctcmV2aXNpb24tZXhwcmVzc2lvbi1oZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgZm9yIGdldHRpbmcgYW4gZXhwcmVzc2lvbiB0byBzcGVjaWZ5IGEgY2VydGFpblxuICogcmV2aXNpb24gaW4gSGcgKGkuZS4gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgJy0tcmV2JyBvcHRpb24gb2ZcbiAqIGFuIEhnIGNvbW1hbmQpLlxuICogTm90ZTogXCJIZWFkXCIgaW4gdGhpcyBzZXQgb2YgaGVscGVyIGZ1bmN0aW9ucyByZWZlcnMgdG8gdGhlIFwiY3VycmVudCB3b3JraW5nXG4gKiBkaXJlY3RvcnkgcGFyZW50XCIgaW4gSGcgdGVybXMuXG4gKi9cblxuLy8gU2VjdGlvbjogRXhwcmVzc2lvbiBGb3JtYXRpb25cblxudmFyIEhHX0NVUlJFTlRfV09SS0lOR19ESVJFQ1RPUllfUEFSRU5UID0gXCIuXCI7XG5cbi8qKlxuICogQHBhcmFtIHJldmlzaW9uRXhwcmVzc2lvbiBBbiBleHByZXNzaW9uIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBoZyBhcyBhbiBhcmd1bWVudFxuICogdG8gdGhlICctLXJldicgb3B0aW9uLlxuICogQHBhcmFtIG51bWJlck9mUmV2c0JlZm9yZSBUaGUgbnVtYmVyIG9mIHJldmlzaW9ucyBiZWZvcmUgdGhlIGN1cnJlbnQgcmV2aXNpb25cbiAqIHRoYXQgeW91IHdhbnQgYSByZXZpc2lvbiBleHByZXNzaW9uIGZvci4gUGFzc2luZyAwIGhlcmUgd2lsbCBzaW1wbHkgcmV0dXJuICdyZXZpc2lvbkV4cHJlc3Npb24nLlxuICogQHJldHVybiBBbiBleHByZXNzaW9uIGZvciB0aGUgJ251bWJlck9mUmV2c0JlZm9yZSd0aCByZXZpc2lvbiBiZWZvcmUgdGhlIGdpdmVuIHJldmlzaW9uLlxuICovXG5mdW5jdGlvbiBleHByZXNzaW9uRm9yUmV2aXNpb25zQmVmb3JlKHJldmlzaW9uRXhwcmVzc2lvbjogc3RyaW5nLCBudW1iZXJPZlJldnNCZWZvcmU6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChudW1iZXJPZlJldnNCZWZvcmUgPT09IDApIHtcbiAgICByZXR1cm4gcmV2aXNpb25FeHByZXNzaW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXZpc2lvbkV4cHJlc3Npb24gKyAnficgKyBudW1iZXJPZlJldnNCZWZvcmUudG9TdHJpbmcoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uRm9yUmV2aXNpb25zQmVmb3JlSGVhZChudW1iZXJPZlJldnNCZWZvcmU6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChudW1iZXJPZlJldnNCZWZvcmUgPCAwKSB7XG4gICAgbnVtYmVyT2ZSZXZzQmVmb3JlID0gMDtcbiAgfVxuICByZXR1cm4gZXhwcmVzc2lvbkZvclJldmlzaW9uc0JlZm9yZShIR19DVVJSRU5UX1dPUktJTkdfRElSRUNUT1JZX1BBUkVOVCwgbnVtYmVyT2ZSZXZzQmVmb3JlKTtcbn1cblxuXG4vLyBTZWN0aW9uOiBSZXZpc2lvbiBTZXRzXG5cbi8qKlxuICogQHBhcmFtIHJldmlzaW9uIFRoZSByZXZpc2lvbiBleHByZXNzaW9uIG9mIGEgcmV2aXNpb24gb2YgaW50ZXJlc3QuXG4gKiBAcGFyYW0gd29ya2luZ0RpcmVjdG9yeSBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhlIEhnIHJlcG9zaXRvcnkuXG4gKiBAcmV0dXJuIEFuIGV4cHJlc3Npb24gZm9yIHRoZSBjb21tb24gYW5jZXN0b3Igb2YgdGhlIHJldmlzaW9uIG9mIGludGVyZXN0IGFuZFxuICogdGhlIGN1cnJlbnQgSGcgaGVhZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uKHJldmlzaW9uOiBzdHJpbmcsIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHZhciB7YXN5bmNFeGVjdXRlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xuXG4gIHZhciBhbmNlc3RvckV4cHJlc3Npb24gPSBgYW5jZXN0b3IoJHtyZXZpc2lvbn0sICR7SEdfQ1VSUkVOVF9XT1JLSU5HX0RJUkVDVE9SWV9QQVJFTlR9KWA7XG4gIC8vIHNoZWxsLWVzY2FwZSBkb2VzIG5vdCB3cmFwIGFuY2VzdG9yRXhwcmVzc2lvbiBpbiBxdW90ZXMgd2l0aG91dCB0aGlzIHRvU3RyaW5nIGNvbnZlcnNpb24uXG4gIGFuY2VzdG9yRXhwcmVzc2lvbiA9IGFuY2VzdG9yRXhwcmVzc2lvbi50b1N0cmluZygpO1xuXG4gIC8vIHNoZWxsLWVzY2FwZSBkb2VzIG5vdCB3cmFwICd7cmV2fScgaW4gcXVvdGVzIHVubGVzcyBpdCBpcyBkb3VibGUtcXVvdGVkLlxuICB2YXIgYXJncyA9IFsnbG9nJywgJy0tdGVtcGxhdGUnLCBcIntyZXZ9XCIsICctLXJldicsIGFuY2VzdG9yRXhwcmVzc2lvbl07XG4gIHZhciBvcHRpb25zID0ge1xuICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgfTtcblxuICB0cnkge1xuICAgIHZhciB7c3Rkb3V0OiBhbmNlc3RvclJldmlzaW9uTnVtYmVyfSA9IGF3YWl0IGFzeW5jRXhlY3V0ZSgnaGcnLCBhcmdzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYW5jZXN0b3JSZXZpc2lvbk51bWJlcjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gZ2V0IGhnIGNvbW1vbiBhbmNlc3RvcjogJywgZS5zdGRlcnIsIGUuY29tbWFuZCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmV0Y2ggY29tbW9uIGFuY2VzdG9yIG9mIGhlYWQgYW5kIHJldmlzaW9uOiAnICsgcmV2aXNpb24pO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHJldmlzaW9uRnJvbSBUaGUgcmV2aXNpb24gZXhwcmVzc2lvbiBvZiB0aGUgXCJzdGFydFwiIChvbGRlcikgcmV2aXNpb24uXG4gKiBAcGFyYW0gcmV2aXNpb25UbyBUaGUgcmV2aXNpb24gZXhwcmVzc2lvbiBvZiB0aGUgXCJlbmRcIiAobmV3ZXIpIHJldmlzaW9uLlxuICogQHBhcmFtIHdvcmtpbmdEaXJlY3RvcnkgVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoZSBIZyByZXBvc2l0b3J5LlxuICogQHJldHVybiBBbiBhcnJheSBvZiByZXZpc2lvbiBudW1iZXJzIHRoYXQgYXJlIGJldHdlZW4gcmV2aXNpb25Gcm9tIGFuZFxuICogICByZXZpc2lvblRvLCBwbHVzIHJldmlzaW9uRnJvbSBhbmQgcmV2aXNpb25UbzsgYW5kIHRoZSB2YWx1ZXNcbiAqICAgYXJlIGFsbCAndHJ1ZScuIFwiQmV0d2VlblwiIG1lYW5zIHRoYXQgcmV2aXNpb25Gcm9tIGlzIGFuIGFuY2VzdG9yIG9mLCBhbmRcbiAqICAgcmV2aXNpb25UbyBpcyBhIGRlc2NlbmRhbnQgb2YuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmV2aXNpb25OdW1iZXJzQmV0d2VlblJldmlzaW9ucyhcbiAgICByZXZpc2lvbkZyb206IHN0cmluZywgcmV2aXNpb25Ubzogc3RyaW5nLCB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHN0cmluZz4+IHtcbiAgdmFyIHthc3luY0V4ZWN1dGV9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG5cbiAgdmFyIHJldmlzaW9uRXhwcmVzc2lvbiA9IGAke3JldmlzaW9uRnJvbX06OiR7cmV2aXNpb25Ub31gO1xuICAvLyBzaGVsbC1lc2NhcGUgZG9lcyBub3Qgd3JhcCByZXZpc2lvbkV4cHJlc3Npb24gaW4gcXVvdGVzIHdpdGhvdXQgdGhpcyB0b1N0cmluZyBjb252ZXJzaW9uLlxuICByZXZpc2lvbkV4cHJlc3Npb24gPSByZXZpc2lvbkV4cHJlc3Npb24udG9TdHJpbmcoKTtcblxuICAvLyBzaGVsbC1lc2NhcGUgZG9lcyBub3Qgd3JhcCAne3Jldn0nIGluIHF1b3RlcyB1bmxlc3MgaXQgaXMgZG91YmxlLXF1b3RlZC5cbiAgdmFyIGFyZ3MgPSBbJ2xvZycsICctLXRlbXBsYXRlJywgXCJ7cmV2fVxcblwiLCBcIi0tcmV2XCIsIHJldmlzaW9uRXhwcmVzc2lvbl07XG4gIHZhciBvcHRpb25zID0ge1xuICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgfTtcblxuICB0cnkge1xuICAgIHZhciB7c3Rkb3V0OiByZXZpc2lvbk51bWJlcnNTdHJpbmd9ID0gYXdhaXQgYXN5bmNFeGVjdXRlKCdoZycsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZVJldmlzaW9uTnVtYmVyc091dHB1dChyZXZpc2lvbk51bWJlcnNTdHJpbmcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0ZhaWxlZCB0byBnZXQgcmV2aXNpb24gbnVtYmVycyBiZXR3ZWVuIHR3byByZXZpc2lvbnM6ICcsIGUuc3RkZXJyLCBlLmNvbW1hbmQpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZldGNoIHJldmlzaW9uIG51bWJlcnMgYmV0d2VlbiB0aGUgcmV2aXNpb25zOiAke3JldmlzaW9uRnJvbX0sICR7cmV2aXNpb25Ub31gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBgZmV0Y2hSZXZpc2lvbnNOdW1iZXJzQmV0d2VlblJldmlzaW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmV2aXNpb25OdW1iZXJzT3V0cHV0KHJldmlzaW9uTnVtYmVyc091dHB1dCk6IEFycmF5PHN0cmluZz4ge1xuICB2YXIgbnVtYmVycyA9IHJldmlzaW9uTnVtYmVyc091dHB1dC5zcGxpdCgnXFxuJyk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbnVtYmVycy5mb3JFYWNoKG51bWJlclN0cmluZyA9PiB7XG4gICAgdmFyIHRyaW1tZWROdW1iZXIgPSBudW1iZXJTdHJpbmcudHJpbSgpO1xuICAgIGlmICh0cmltbWVkTnVtYmVyLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2godHJpbW1lZE51bWJlcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2hDb21tb25BbmNlc3Rvck9mSGVhZEFuZFJldmlzaW9uLFxuICBmZXRjaFJldmlzaW9uTnVtYmVyc0JldHdlZW5SZXZpc2lvbnMsXG4gIGV4cHJlc3Npb25Gb3JSZXZpc2lvbnNCZWZvcmVIZWFkLFxufTtcbiJdfQ==
