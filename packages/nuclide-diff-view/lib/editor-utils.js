
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/*
 * @param screenLines The original screen lines before adding offsets.
 * @param lineOffsets The offset map from buffer line numbers to the number of lines of offset requested there.
 * @param startBufferRow The buffer row at which the next range of screen lines is started.
 * @param endBufferRow The buffer row at which the next range of screen lines is ended.
 * @param emptyLineFactory A custom function to create a new empty line, representing an offset screen line.
 */
function buildLineRangesWithOffsets(screenLines, lineOffsets, startBufferRow, endBufferRow, emptyLineFactory) {

  var offsetLineNumbers = Object.keys(lineOffsets).sort().map(function (lineNumber) {
    return parseInt(lineNumber, 10);
  });

  var priorScreenLine = startBufferRow;
  var newRegions = [];
  var newScreenLines = [];

  var captureScreenLinesRegion = function captureScreenLinesRegion(toScreenLine) {
    if (toScreenLine < priorScreenLine) {
      return;
    }
    var numberOfRows = toScreenLine - priorScreenLine;
    if (numberOfRows > 0) {
      // Add the portion of the original screenLines until toScreenLine.
      newScreenLines.push.apply(newScreenLines, screenLines.slice(priorScreenLine - startBufferRow, toScreenLine - startBufferRow));
      // This is normal 1 to 1 buffer to screen row region.
      newRegions.push({ bufferRows: numberOfRows, screenRows: numberOfRows });
    }
    priorScreenLine = toScreenLine + 1;
  };

  // Construct the new screen lines and regions, by adding empty lines at the offset lines
  // and returning ranges with screenRows = bufferRows + offsetLines.
  for (var offsetLineNumber of offsetLineNumbers) {
    if (offsetLineNumber < priorScreenLine || offsetLineNumber >= endBufferRow) {
      continue;
    }
    var offsetLines = lineOffsets[offsetLineNumber];
    captureScreenLinesRegion(offsetLineNumber - 1);
    // Add empty screen lines to represent offsets.
    for (var i = 0; i < offsetLines; i++) {
      newScreenLines.push(emptyLineFactory());
    }
    var startOffsetBufferLineNumber = offsetLineNumber - startBufferRow - 1;
    // TODO: fix when we have more control on the buffer to screen line mapping
    // Currently, if we have offsets at the begining of the file, the gutter numbering would be confusing
    // because it considers the first offset line is the line to be numbered.
    if (startOffsetBufferLineNumber >= 0) {
      // The buffer line should be inserted above the empty offset lines added.
      newScreenLines.splice(newScreenLines.length - offsetLines, 0, screenLines[startOffsetBufferLineNumber]);
    } else {
      // startOffsetBufferLineNumber = -1 in case the offsets are in the begining of the file.
      newScreenLines.push(screenLines[0]);
      priorScreenLine++;
    }
    newRegions.push({ bufferRows: 1, screenRows: offsetLines + 1 });
  }

  // Capture a single region to the end of the screen lines.
  captureScreenLinesRegion(endBufferRow);

  return { regions: newRegions, screenLines: newScreenLines };
}

module.exports = {
  buildLineRangesWithOffsets: buildLineRangesWithOffsets
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL2FwbS9udWNsaWRlLWRpZmYtdmlldy9saWIvZWRpdG9yLXV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QlosU0FBUywwQkFBMEIsQ0FDL0IsV0FBdUIsRUFDdkIsV0FBZ0IsRUFDaEIsY0FBc0IsRUFDdEIsWUFBb0IsRUFDcEIsZ0JBQTJCLEVBQ0Y7O0FBRTNCLE1BQUksaUJBQWlCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBQSxVQUFVO1dBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUM7R0FBQSxDQUFDLENBQUM7O0FBRXBHLE1BQUksZUFBZSxHQUFHLGNBQWMsQ0FBQztBQUNyQyxNQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDcEIsTUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDOztBQUV4QixNQUFJLHdCQUF3QixHQUFHLFNBQTNCLHdCQUF3QixDQUFJLFlBQVksRUFBYTtBQUN2RCxRQUFJLFlBQVksR0FBRyxlQUFlLEVBQUU7QUFDbEMsYUFBTztLQUNSO0FBQ0QsUUFBSSxZQUFZLEdBQUcsWUFBWSxHQUFHLGVBQWUsQ0FBQztBQUNsRCxRQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7O0FBRXBCLG9CQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsY0FBYyxFQUFFLFlBQVksR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDOztBQUU5SCxnQkFBVSxDQUFDLElBQUksQ0FBQyxFQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBQyxDQUFDLENBQUM7S0FDdkU7QUFDRCxtQkFBZSxHQUFHLFlBQVksR0FBRyxDQUFDLENBQUM7R0FDcEMsQ0FBQzs7OztBQUlGLE9BQUssSUFBSSxnQkFBZ0IsSUFBSSxpQkFBaUIsRUFBRTtBQUM5QyxRQUFJLGdCQUFnQixHQUFHLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSSxZQUFZLEVBQUU7QUFDMUUsZUFBUztLQUNWO0FBQ0QsUUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDaEQsNEJBQXdCLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRS9DLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDcEMsb0JBQWMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0tBQ3pDO0FBQ0QsUUFBSSwyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsQ0FBQyxDQUFDOzs7O0FBSXhFLFFBQUksMkJBQTJCLElBQUksQ0FBQyxFQUFFOztBQUVwQyxvQkFBYyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFHLFdBQVcsRUFBRSxDQUFDLEVBQUUsV0FBVyxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQztLQUN6RyxNQUFNOztBQUVMLG9CQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLHFCQUFlLEVBQUUsQ0FBQztLQUNuQjtBQUNELGNBQVUsQ0FBQyxJQUFJLENBQUMsRUFBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxXQUFXLEdBQUcsQ0FBQyxFQUFDLENBQUMsQ0FBQztHQUMvRDs7O0FBR0QsMEJBQXdCLENBQUMsWUFBWSxDQUFDLENBQUM7O0FBRXZDLFNBQU8sRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUMsQ0FBQztDQUMzRDs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHO0FBQ2YsNEJBQTBCLEVBQTFCLDBCQUEwQjtDQUMzQixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL2FwbS9udWNsaWRlLWRpZmYtdmlldy9saWIvZWRpdG9yLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIHR5cGUgTGluZVJhbmdlc1dpdGhPZmZzZXRzID0ge1xuICByZWdpb25zOiBBcnJheTx7YnVmZmVyUm93czogbnVtYmVyOyBzY3JlZW5Sb3dzOiBudW1iZXJ9PjtcbiAgc2NyZWVuTGluZXM6IEFycmF5PGFueT47XG4gfTtcblxuLypcbiAqIEBwYXJhbSBzY3JlZW5MaW5lcyBUaGUgb3JpZ2luYWwgc2NyZWVuIGxpbmVzIGJlZm9yZSBhZGRpbmcgb2Zmc2V0cy5cbiAqIEBwYXJhbSBsaW5lT2Zmc2V0cyBUaGUgb2Zmc2V0IG1hcCBmcm9tIGJ1ZmZlciBsaW5lIG51bWJlcnMgdG8gdGhlIG51bWJlciBvZiBsaW5lcyBvZiBvZmZzZXQgcmVxdWVzdGVkIHRoZXJlLlxuICogQHBhcmFtIHN0YXJ0QnVmZmVyUm93IFRoZSBidWZmZXIgcm93IGF0IHdoaWNoIHRoZSBuZXh0IHJhbmdlIG9mIHNjcmVlbiBsaW5lcyBpcyBzdGFydGVkLlxuICogQHBhcmFtIGVuZEJ1ZmZlclJvdyBUaGUgYnVmZmVyIHJvdyBhdCB3aGljaCB0aGUgbmV4dCByYW5nZSBvZiBzY3JlZW4gbGluZXMgaXMgZW5kZWQuXG4gKiBAcGFyYW0gZW1wdHlMaW5lRmFjdG9yeSBBIGN1c3RvbSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgZW1wdHkgbGluZSwgcmVwcmVzZW50aW5nIGFuIG9mZnNldCBzY3JlZW4gbGluZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMaW5lUmFuZ2VzV2l0aE9mZnNldHMoXG4gICAgc2NyZWVuTGluZXM6IEFycmF5PGFueT4sXG4gICAgbGluZU9mZnNldHM6IGFueSxcbiAgICBzdGFydEJ1ZmZlclJvdzogbnVtYmVyLFxuICAgIGVuZEJ1ZmZlclJvdzogbnVtYmVyLFxuICAgIGVtcHR5TGluZUZhY3Rvcnk6ICgpID0+IGFueVxuICAgICk6IExpbmVSYW5nZXNXaXRoT2Zmc2V0cyB7XG5cbiAgdmFyIG9mZnNldExpbmVOdW1iZXJzID0gT2JqZWN0LmtleXMobGluZU9mZnNldHMpLnNvcnQoKS5tYXAobGluZU51bWJlciA9PiBwYXJzZUludChsaW5lTnVtYmVyLCAxMCkpO1xuXG4gIHZhciBwcmlvclNjcmVlbkxpbmUgPSBzdGFydEJ1ZmZlclJvdztcbiAgdmFyIG5ld1JlZ2lvbnMgPSBbXTtcbiAgdmFyIG5ld1NjcmVlbkxpbmVzID0gW107XG5cbiAgdmFyIGNhcHR1cmVTY3JlZW5MaW5lc1JlZ2lvbiA9ICh0b1NjcmVlbkxpbmU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0b1NjcmVlbkxpbmUgPCBwcmlvclNjcmVlbkxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG51bWJlck9mUm93cyA9IHRvU2NyZWVuTGluZSAtIHByaW9yU2NyZWVuTGluZTtcbiAgICBpZiAobnVtYmVyT2ZSb3dzID4gMCkge1xuICAgICAgLy8gQWRkIHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCBzY3JlZW5MaW5lcyB1bnRpbCB0b1NjcmVlbkxpbmUuXG4gICAgICBuZXdTY3JlZW5MaW5lcy5wdXNoLmFwcGx5KG5ld1NjcmVlbkxpbmVzLCBzY3JlZW5MaW5lcy5zbGljZShwcmlvclNjcmVlbkxpbmUgLSBzdGFydEJ1ZmZlclJvdywgdG9TY3JlZW5MaW5lIC0gc3RhcnRCdWZmZXJSb3cpKTtcbiAgICAgIC8vIFRoaXMgaXMgbm9ybWFsIDEgdG8gMSBidWZmZXIgdG8gc2NyZWVuIHJvdyByZWdpb24uXG4gICAgICBuZXdSZWdpb25zLnB1c2goe2J1ZmZlclJvd3M6IG51bWJlck9mUm93cywgc2NyZWVuUm93czogbnVtYmVyT2ZSb3dzfSk7XG4gICAgfVxuICAgIHByaW9yU2NyZWVuTGluZSA9IHRvU2NyZWVuTGluZSArIDE7XG4gIH07XG5cbiAgLy8gQ29uc3RydWN0IHRoZSBuZXcgc2NyZWVuIGxpbmVzIGFuZCByZWdpb25zLCBieSBhZGRpbmcgZW1wdHkgbGluZXMgYXQgdGhlIG9mZnNldCBsaW5lc1xuICAvLyBhbmQgcmV0dXJuaW5nIHJhbmdlcyB3aXRoIHNjcmVlblJvd3MgPSBidWZmZXJSb3dzICsgb2Zmc2V0TGluZXMuXG4gIGZvciAodmFyIG9mZnNldExpbmVOdW1iZXIgb2Ygb2Zmc2V0TGluZU51bWJlcnMpIHtcbiAgICBpZiAob2Zmc2V0TGluZU51bWJlciA8IHByaW9yU2NyZWVuTGluZSB8fCBvZmZzZXRMaW5lTnVtYmVyID49IGVuZEJ1ZmZlclJvdykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBvZmZzZXRMaW5lcyA9IGxpbmVPZmZzZXRzW29mZnNldExpbmVOdW1iZXJdO1xuICAgIGNhcHR1cmVTY3JlZW5MaW5lc1JlZ2lvbihvZmZzZXRMaW5lTnVtYmVyIC0gMSk7XG4gICAgLy8gQWRkIGVtcHR5IHNjcmVlbiBsaW5lcyB0byByZXByZXNlbnQgb2Zmc2V0cy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldExpbmVzOyBpKyspIHtcbiAgICAgIG5ld1NjcmVlbkxpbmVzLnB1c2goZW1wdHlMaW5lRmFjdG9yeSgpKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0T2Zmc2V0QnVmZmVyTGluZU51bWJlciA9IG9mZnNldExpbmVOdW1iZXIgLSBzdGFydEJ1ZmZlclJvdyAtIDE7XG4gICAgLy8gVE9ETzogZml4IHdoZW4gd2UgaGF2ZSBtb3JlIGNvbnRyb2wgb24gdGhlIGJ1ZmZlciB0byBzY3JlZW4gbGluZSBtYXBwaW5nXG4gICAgLy8gQ3VycmVudGx5LCBpZiB3ZSBoYXZlIG9mZnNldHMgYXQgdGhlIGJlZ2luaW5nIG9mIHRoZSBmaWxlLCB0aGUgZ3V0dGVyIG51bWJlcmluZyB3b3VsZCBiZSBjb25mdXNpbmdcbiAgICAvLyBiZWNhdXNlIGl0IGNvbnNpZGVycyB0aGUgZmlyc3Qgb2Zmc2V0IGxpbmUgaXMgdGhlIGxpbmUgdG8gYmUgbnVtYmVyZWQuXG4gICAgaWYgKHN0YXJ0T2Zmc2V0QnVmZmVyTGluZU51bWJlciA+PSAwKSB7XG4gICAgICAvLyBUaGUgYnVmZmVyIGxpbmUgc2hvdWxkIGJlIGluc2VydGVkIGFib3ZlIHRoZSBlbXB0eSBvZmZzZXQgbGluZXMgYWRkZWQuXG4gICAgICBuZXdTY3JlZW5MaW5lcy5zcGxpY2UobmV3U2NyZWVuTGluZXMubGVuZ3RoIC0gb2Zmc2V0TGluZXMsIDAsIHNjcmVlbkxpbmVzW3N0YXJ0T2Zmc2V0QnVmZmVyTGluZU51bWJlcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGFydE9mZnNldEJ1ZmZlckxpbmVOdW1iZXIgPSAtMSBpbiBjYXNlIHRoZSBvZmZzZXRzIGFyZSBpbiB0aGUgYmVnaW5pbmcgb2YgdGhlIGZpbGUuXG4gICAgICBuZXdTY3JlZW5MaW5lcy5wdXNoKHNjcmVlbkxpbmVzWzBdKTtcbiAgICAgIHByaW9yU2NyZWVuTGluZSsrO1xuICAgIH1cbiAgICBuZXdSZWdpb25zLnB1c2goe2J1ZmZlclJvd3M6IDEsIHNjcmVlblJvd3M6IG9mZnNldExpbmVzICsgMX0pO1xuICB9XG5cbiAgLy8gQ2FwdHVyZSBhIHNpbmdsZSByZWdpb24gdG8gdGhlIGVuZCBvZiB0aGUgc2NyZWVuIGxpbmVzLlxuICBjYXB0dXJlU2NyZWVuTGluZXNSZWdpb24oZW5kQnVmZmVyUm93KTtcblxuICByZXR1cm4ge3JlZ2lvbnM6IG5ld1JlZ2lvbnMsIHNjcmVlbkxpbmVzOiBuZXdTY3JlZW5MaW5lc307XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZExpbmVSYW5nZXNXaXRoT2Zmc2V0cyxcbn07XG4iXX0=
