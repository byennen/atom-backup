
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function isAlphanumeric(character) {
  return (/[\w]/.test(character)
  );
}

var DEFAULT_PATH_SEPARATOR = require('path').sep;

var QueryItem = (function () {
  function QueryItem(string) {
    var pathSeparator = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_PATH_SEPARATOR : arguments[1];

    _classCallCheck(this, QueryItem);

    // If the thing we're querying is a path, assume the filename from the path is more important.
    this._lastPathSeparatorIndex = pathSeparator == null ? -1 : string.lastIndexOf(pathSeparator);
    this._string = string;
    this._uppercaseString = string.toUpperCase();

    /*
     * Caches locations in the string that should yield higher scores if a match overlaps with them.
     *
     * Specifically:
     *   1. Uppercase characters
     *   2. Characters following a non-alphanumeric character (path separators/dashes/spaces)
     */
    this._skipLocations = [];
    for (var i = this._lastPathSeparatorIndex + 1; i < string.length; i++) {
      var char = string.charAt(i);
      var isUppercase = char === this._uppercaseString.charAt(i);
      if (isUppercase || isAlphanumeric(char) && !isAlphanumeric(string.charAt(i - 1))) {
        this._skipLocations.push(i);
      }
    }
  }

  /**
   * Scores this object's string against the query given.
   *
   * Essentally a quick interpretation of:
   * https://github.com/makoConstruct/CleverMatcher
   *
   * The main (minor) changes are adjustments preferring clustered letters,
   * preferring characters appearing in filenames, and making the code less insane to read.
   *
   * No attempt was made to move away from cargo-culting Sublime's
   * nonsense score values or be smarter about recovering in skipMatch.
   *
   * Returns `null` on no match.
   */

  _createClass(QueryItem, [{
    key: 'score',
    value: function score(query) {
      var uppercaseQuery = query.toUpperCase();
      var matches = this._findSkipMatches(uppercaseQuery) || this._findSubstringMatches(uppercaseQuery);

      if (matches == null || matches[matches.length - 1] < this._lastPathSeparatorIndex) {
        return null;
      }

      var score = 1;
      var lastMatch = -1;
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];

        var matchScore = 0;
        var skipLocation = this._skipLocations.indexOf(match);
        if (skipLocation !== -1) {
          if (skipLocation === 0) {
            matchScore += 22;
          } else {
            matchScore += 15;
          }
        } else {
          matchScore = 1;
        }

        // Apply a bonus based on how close this match was to the last match.
        matchScore += 15 / (match - lastMatch);

        if (match > this._lastPathSeparatorIndex) {
          matchScore *= 2;
        }

        score += matchScore;
        lastMatch = match;
      }

      return { score: score, value: this._string, matchIndexes: matches };
    }

    /**
     * Attempts to match using _skipLocations as a shortcut to quickly
     * match locations in the string that should score well.
     *
     * Currently fails if it ever doesn't find a match after skipping and makes no attempt to recover.
     *
     * Returns the indexes of each charater matched in the string.
     */
  }, {
    key: '_findSkipMatches',
    value: function _findSkipMatches(query) {
      var matches = [];
      var lastHit = -1;

      /*
       * This seems like an ideal place for a for..of loop.  -It is not-, because
       * V8 will bail on optimizing this code, making its performace excruciating.
       */
      for (var i = 0; i < query.length; i++) {
        var queryChar = query.charAt(i);
        var foundSkip = false;
        for (var j = 0; j < this._skipLocations.length; j++) {
          var skipLocation = this._skipLocations[j];
          if (skipLocation > lastHit && this._uppercaseString.charAt(skipLocation) == queryChar) {
            matches.push(skipLocation);
            lastHit = skipLocation;
            foundSkip = true;
            break;
          }
        }

        if (foundSkip === false) {
          var startIndex = Math.max(lastHit + 1, this._lastPathSeparatorIndex);
          lastHit = this._uppercaseString.indexOf(queryChar, startIndex);
          if (lastHit === -1) {
            return null;
          }
          matches.push(lastHit);
        }
      }

      return matches;
    }

    /**
     * Dumb matching that just checks that all characters are present in the string.
     *
     * Goes in reverse to attempt to get as many characters in the filename as possible.
     *
     * Returns the indexes of each charater matched in the string.
     */
  }, {
    key: '_findSubstringMatches',
    value: function _findSubstringMatches(query) {
      var matches = new Array(query.length);
      var lastHit = this._uppercaseString.length;

      /*
       * This seems like an ideal place for a for..of loop.  -It is not-, because
       * V8 will bail on optimizing this code, making its performace excruciating.
       */
      for (var i = query.length - 1; i >= 0; i--) {
        var queryChar = query.charAt(i);
        lastHit = this._uppercaseString.lastIndexOf(queryChar, lastHit - 1);
        if (lastHit === -1) {
          return null;
        }
        matches[i] = lastHit;
      }

      return matches;
    }
  }]);

  return QueryItem;
})();

module.exports = QueryItem;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXBhdGgtc2VhcmNoL2xpYi9RdWVyeUl0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQVdaLFNBQVMsY0FBYyxDQUFDLFNBQVMsRUFBVztBQUMxQyxTQUFPLE9BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQUM7Q0FDL0I7O0FBUUQsSUFBSSxzQkFBc0IsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDOztJQUUzQyxTQUFTO0FBTUYsV0FOUCxTQUFTLENBTUQsTUFBYyxFQUFtRDtRQUFqRCxhQUFhLHlEQUFHLHNCQUFzQjs7MEJBTjlELFNBQVM7OztBQVFYLFFBQUksQ0FBQyx1QkFBdUIsR0FBRyxhQUFhLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDOUYsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7Ozs7Ozs7O0FBUzdDLFFBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLFNBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNyRSxVQUFJLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLFVBQUksV0FBVyxHQUFJLElBQUksS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxBQUFDLENBQUM7QUFDN0QsVUFBSSxXQUFXLElBQUssY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEFBQUMsRUFBRTtBQUNsRixZQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUM3QjtLQUNGO0dBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBM0JHLFNBQVM7O1dBMkNSLGVBQUMsS0FBYSxFQUFlO0FBQ2hDLFVBQUksY0FBYyxHQUFHLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN6QyxVQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFDOztBQUVsRyxVQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixFQUFFO0FBQ2pGLGVBQU8sSUFBSSxDQUFDO09BQ2I7O0FBRUQsVUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsVUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkIsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsWUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV2QixZQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDbkIsWUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEQsWUFBSSxZQUFZLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDdkIsY0FBSSxZQUFZLEtBQUssQ0FBQyxFQUFFO0FBQ3RCLHNCQUFVLElBQUksRUFBRSxDQUFDO1dBQ2xCLE1BQU07QUFDTCxzQkFBVSxJQUFJLEVBQUUsQ0FBQztXQUNsQjtTQUNGLE1BQU07QUFDTCxvQkFBVSxHQUFHLENBQUMsQ0FBQztTQUNoQjs7O0FBR0Qsa0JBQVUsSUFBSSxFQUFFLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQSxBQUFDLENBQUM7O0FBRXZDLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtBQUN4QyxvQkFBVSxJQUFJLENBQUMsQ0FBQztTQUNqQjs7QUFFRCxhQUFLLElBQUksVUFBVSxDQUFDO0FBQ3BCLGlCQUFTLEdBQUcsS0FBSyxDQUFDO09BQ25COztBQUVELGFBQU8sRUFBQyxLQUFLLEVBQUwsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUMsQ0FBQztLQUM1RDs7Ozs7Ozs7Ozs7O1dBVWdCLDBCQUFDLEtBQWEsRUFBa0I7QUFDL0MsVUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLFVBQUksT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDOzs7Ozs7QUFNakIsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckMsWUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxZQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdEIsYUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ25ELGNBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUMsY0FBSSxZQUFZLEdBQUcsT0FBTyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxFQUFFO0FBQ3JGLG1CQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzNCLG1CQUFPLEdBQUcsWUFBWSxDQUFDO0FBQ3ZCLHFCQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLGtCQUFNO1dBQ1A7U0FDRjs7QUFFRCxZQUFJLFNBQVMsS0FBSyxLQUFLLEVBQUU7QUFDdkIsY0FBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3JFLGlCQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDL0QsY0FBSSxPQUFPLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDbEIsbUJBQU8sSUFBSSxDQUFDO1dBQ2I7QUFDRCxpQkFBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN2QjtPQUNGOztBQUVELGFBQU8sT0FBTyxDQUFDO0tBQ2hCOzs7Ozs7Ozs7OztXQVNvQiwrQkFBQyxLQUFhLEVBQWtCO0FBQ25ELFVBQUksT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QyxVQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDOzs7Ozs7QUFNM0MsV0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFDLFlBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsZUFBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNwRSxZQUFJLE9BQU8sS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNsQixpQkFBTyxJQUFJLENBQUM7U0FDYjtBQUNELGVBQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7T0FDdEI7O0FBRUQsYUFBTyxPQUFPLENBQUM7S0FDaEI7OztTQXJKRyxTQUFTOzs7QUF3SmYsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtcGF0aC1zZWFyY2gvbGliL1F1ZXJ5SXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmZ1bmN0aW9uIGlzQWxwaGFudW1lcmljKGNoYXJhY3Rlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gL1tcXHddLy50ZXN0KGNoYXJhY3Rlcik7XG59XG5cbnR5cGUgUXVlcnlTY29yZSA9IHtcbiAgdmFsdWU6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgbWF0Y2hJbmRleGVzOiBBcnJheTxudW1iZXI+O1xufVxuXG52YXIgREVGQVVMVF9QQVRIX1NFUEFSQVRPUiA9IHJlcXVpcmUoJ3BhdGgnKS5zZXA7XG5cbmNsYXNzIFF1ZXJ5SXRlbSB7XG4gIF9sYXN0UGF0aFNlcGFyYXRvckluZGV4OiBudW1iZXI7XG4gIF9za2lwTG9jYXRpb25zOiBBcnJheTxudW1iZXI+O1xuICBfc3RyaW5nOiBzdHJpbmc7XG4gIF91cHBlcmNhc2VTdHJpbmc6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzdHJpbmc6IHN0cmluZywgcGF0aFNlcGFyYXRvciA9IERFRkFVTFRfUEFUSF9TRVBBUkFUT1I6ID9zdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgdGhpbmcgd2UncmUgcXVlcnlpbmcgaXMgYSBwYXRoLCBhc3N1bWUgdGhlIGZpbGVuYW1lIGZyb20gdGhlIHBhdGggaXMgbW9yZSBpbXBvcnRhbnQuXG4gICAgdGhpcy5fbGFzdFBhdGhTZXBhcmF0b3JJbmRleCA9IHBhdGhTZXBhcmF0b3IgPT0gbnVsbCA/IC0xIDogc3RyaW5nLmxhc3RJbmRleE9mKHBhdGhTZXBhcmF0b3IpO1xuICAgIHRoaXMuX3N0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLl91cHBlcmNhc2VTdHJpbmcgPSBzdHJpbmcudG9VcHBlckNhc2UoKTtcblxuICAgIC8qXG4gICAgICogQ2FjaGVzIGxvY2F0aW9ucyBpbiB0aGUgc3RyaW5nIHRoYXQgc2hvdWxkIHlpZWxkIGhpZ2hlciBzY29yZXMgaWYgYSBtYXRjaCBvdmVybGFwcyB3aXRoIHRoZW0uXG4gICAgICpcbiAgICAgKiBTcGVjaWZpY2FsbHk6XG4gICAgICogICAxLiBVcHBlcmNhc2UgY2hhcmFjdGVyc1xuICAgICAqICAgMi4gQ2hhcmFjdGVycyBmb2xsb3dpbmcgYSBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlciAocGF0aCBzZXBhcmF0b3JzL2Rhc2hlcy9zcGFjZXMpXG4gICAgICovXG4gICAgdGhpcy5fc2tpcExvY2F0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9sYXN0UGF0aFNlcGFyYXRvckluZGV4ICsgMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYXIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgdmFyIGlzVXBwZXJjYXNlID0gKGNoYXIgPT09IHRoaXMuX3VwcGVyY2FzZVN0cmluZy5jaGFyQXQoaSkpO1xuICAgICAgaWYgKGlzVXBwZXJjYXNlIHx8IChpc0FscGhhbnVtZXJpYyhjaGFyKSAmJiAhaXNBbHBoYW51bWVyaWMoc3RyaW5nLmNoYXJBdChpIC0gMSkpKSkge1xuICAgICAgICB0aGlzLl9za2lwTG9jYXRpb25zLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjb3JlcyB0aGlzIG9iamVjdCdzIHN0cmluZyBhZ2FpbnN0IHRoZSBxdWVyeSBnaXZlbi5cbiAgICpcbiAgICogRXNzZW50YWxseSBhIHF1aWNrIGludGVycHJldGF0aW9uIG9mOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWFrb0NvbnN0cnVjdC9DbGV2ZXJNYXRjaGVyXG4gICAqXG4gICAqIFRoZSBtYWluIChtaW5vcikgY2hhbmdlcyBhcmUgYWRqdXN0bWVudHMgcHJlZmVycmluZyBjbHVzdGVyZWQgbGV0dGVycyxcbiAgICogcHJlZmVycmluZyBjaGFyYWN0ZXJzIGFwcGVhcmluZyBpbiBmaWxlbmFtZXMsIGFuZCBtYWtpbmcgdGhlIGNvZGUgbGVzcyBpbnNhbmUgdG8gcmVhZC5cbiAgICpcbiAgICogTm8gYXR0ZW1wdCB3YXMgbWFkZSB0byBtb3ZlIGF3YXkgZnJvbSBjYXJnby1jdWx0aW5nIFN1YmxpbWUnc1xuICAgKiBub25zZW5zZSBzY29yZSB2YWx1ZXMgb3IgYmUgc21hcnRlciBhYm91dCByZWNvdmVyaW5nIGluIHNraXBNYXRjaC5cbiAgICpcbiAgICogUmV0dXJucyBgbnVsbGAgb24gbm8gbWF0Y2guXG4gICAqL1xuICBzY29yZShxdWVyeTogc3RyaW5nKTogP1F1ZXJ5U2NvcmUge1xuICAgIHZhciB1cHBlcmNhc2VRdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIG1hdGNoZXMgPSB0aGlzLl9maW5kU2tpcE1hdGNoZXModXBwZXJjYXNlUXVlcnkpIHx8IHRoaXMuX2ZpbmRTdWJzdHJpbmdNYXRjaGVzKHVwcGVyY2FzZVF1ZXJ5KTtcblxuICAgIGlmIChtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIDwgdGhpcy5fbGFzdFBhdGhTZXBhcmF0b3JJbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNjb3JlID0gMTtcbiAgICB2YXIgbGFzdE1hdGNoID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuXG4gICAgICB2YXIgbWF0Y2hTY29yZSA9IDA7XG4gICAgICB2YXIgc2tpcExvY2F0aW9uID0gdGhpcy5fc2tpcExvY2F0aW9ucy5pbmRleE9mKG1hdGNoKTtcbiAgICAgIGlmIChza2lwTG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgIGlmIChza2lwTG9jYXRpb24gPT09IDApIHtcbiAgICAgICAgICBtYXRjaFNjb3JlICs9IDIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoU2NvcmUgKz0gMTU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoU2NvcmUgPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBhIGJvbnVzIGJhc2VkIG9uIGhvdyBjbG9zZSB0aGlzIG1hdGNoIHdhcyB0byB0aGUgbGFzdCBtYXRjaC5cbiAgICAgIG1hdGNoU2NvcmUgKz0gMTUgLyAobWF0Y2ggLSBsYXN0TWF0Y2gpO1xuXG4gICAgICBpZiAobWF0Y2ggPiB0aGlzLl9sYXN0UGF0aFNlcGFyYXRvckluZGV4KSB7XG4gICAgICAgIG1hdGNoU2NvcmUgKj0gMjtcbiAgICAgIH1cblxuICAgICAgc2NvcmUgKz0gbWF0Y2hTY29yZTtcbiAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xuICAgIH1cblxuICAgIHJldHVybiB7c2NvcmUsIHZhbHVlOiB0aGlzLl9zdHJpbmcsIG1hdGNoSW5kZXhlczogbWF0Y2hlc307XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbWF0Y2ggdXNpbmcgX3NraXBMb2NhdGlvbnMgYXMgYSBzaG9ydGN1dCB0byBxdWlja2x5XG4gICAqIG1hdGNoIGxvY2F0aW9ucyBpbiB0aGUgc3RyaW5nIHRoYXQgc2hvdWxkIHNjb3JlIHdlbGwuXG4gICAqXG4gICAqIEN1cnJlbnRseSBmYWlscyBpZiBpdCBldmVyIGRvZXNuJ3QgZmluZCBhIG1hdGNoIGFmdGVyIHNraXBwaW5nIGFuZCBtYWtlcyBubyBhdHRlbXB0IHRvIHJlY292ZXIuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGluZGV4ZXMgb2YgZWFjaCBjaGFyYXRlciBtYXRjaGVkIGluIHRoZSBzdHJpbmcuXG4gICAqL1xuICAgX2ZpbmRTa2lwTWF0Y2hlcyhxdWVyeTogc3RyaW5nKTogP0FycmF5PG51bWJlcj4ge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGxhc3RIaXQgPSAtMTtcblxuICAgIC8qXG4gICAgICogVGhpcyBzZWVtcyBsaWtlIGFuIGlkZWFsIHBsYWNlIGZvciBhIGZvci4ub2YgbG9vcC4gIC1JdCBpcyBub3QtLCBiZWNhdXNlXG4gICAgICogVjggd2lsbCBiYWlsIG9uIG9wdGltaXppbmcgdGhpcyBjb2RlLCBtYWtpbmcgaXRzIHBlcmZvcm1hY2UgZXhjcnVjaWF0aW5nLlxuICAgICAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWVyeUNoYXIgPSBxdWVyeS5jaGFyQXQoaSk7XG4gICAgICB2YXIgZm91bmRTa2lwID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NraXBMb2NhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHNraXBMb2NhdGlvbiA9IHRoaXMuX3NraXBMb2NhdGlvbnNbal07XG4gICAgICAgIGlmIChza2lwTG9jYXRpb24gPiBsYXN0SGl0ICYmIHRoaXMuX3VwcGVyY2FzZVN0cmluZy5jaGFyQXQoc2tpcExvY2F0aW9uKSA9PSBxdWVyeUNoYXIpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goc2tpcExvY2F0aW9uKTtcbiAgICAgICAgICBsYXN0SGl0ID0gc2tpcExvY2F0aW9uO1xuICAgICAgICAgIGZvdW5kU2tpcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kU2tpcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBNYXRoLm1heChsYXN0SGl0ICsgMSwgdGhpcy5fbGFzdFBhdGhTZXBhcmF0b3JJbmRleCk7XG4gICAgICAgIGxhc3RIaXQgPSB0aGlzLl91cHBlcmNhc2VTdHJpbmcuaW5kZXhPZihxdWVyeUNoYXIsIHN0YXJ0SW5kZXgpO1xuICAgICAgICBpZiAobGFzdEhpdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVzLnB1c2gobGFzdEhpdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICAvKipcbiAgICogRHVtYiBtYXRjaGluZyB0aGF0IGp1c3QgY2hlY2tzIHRoYXQgYWxsIGNoYXJhY3RlcnMgYXJlIHByZXNlbnQgaW4gdGhlIHN0cmluZy5cbiAgICpcbiAgICogR29lcyBpbiByZXZlcnNlIHRvIGF0dGVtcHQgdG8gZ2V0IGFzIG1hbnkgY2hhcmFjdGVycyBpbiB0aGUgZmlsZW5hbWUgYXMgcG9zc2libGUuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGluZGV4ZXMgb2YgZWFjaCBjaGFyYXRlciBtYXRjaGVkIGluIHRoZSBzdHJpbmcuXG4gICAqL1xuICBfZmluZFN1YnN0cmluZ01hdGNoZXMocXVlcnk6IHN0cmluZyk6ID9BcnJheTxudW1iZXI+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheShxdWVyeS5sZW5ndGgpO1xuICAgIHZhciBsYXN0SGl0ID0gdGhpcy5fdXBwZXJjYXNlU3RyaW5nLmxlbmd0aDtcblxuICAgIC8qXG4gICAgICogVGhpcyBzZWVtcyBsaWtlIGFuIGlkZWFsIHBsYWNlIGZvciBhIGZvci4ub2YgbG9vcC4gIC1JdCBpcyBub3QtLCBiZWNhdXNlXG4gICAgICogVjggd2lsbCBiYWlsIG9uIG9wdGltaXppbmcgdGhpcyBjb2RlLCBtYWtpbmcgaXRzIHBlcmZvcm1hY2UgZXhjcnVjaWF0aW5nLlxuICAgICAqL1xuICAgIGZvciAodmFyIGkgPSBxdWVyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHF1ZXJ5Q2hhciA9IHF1ZXJ5LmNoYXJBdChpKTtcbiAgICAgIGxhc3RIaXQgPSB0aGlzLl91cHBlcmNhc2VTdHJpbmcubGFzdEluZGV4T2YocXVlcnlDaGFyLCBsYXN0SGl0IC0gMSk7XG4gICAgICBpZiAobGFzdEhpdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtYXRjaGVzW2ldID0gbGFzdEhpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5SXRlbTtcbiJdfQ==
