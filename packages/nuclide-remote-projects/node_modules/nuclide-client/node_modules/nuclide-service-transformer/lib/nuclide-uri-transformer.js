
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = require('./flow-annotation');

var isNuclideUriFlowTypeAnnotation = _require.isNuclideUriFlowTypeAnnotation;

var t = require('babel-core').types;

/**
 * Given the identifier, create following assignment expression:
 * `$identifier  = this._connection.getPathOfUri($identifier);`
 */
function _createGetPathOfUriAssignmentExpression(identifier) {
  var callExpression = t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('getPathOfUri')),
  /* arguments */[identifier]);

  return t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */identifier,
  /* right */callExpression));
}

/**
 * Given the identifier, create following assignment expression:
 * `$identifier  = this._connection.getUriOfRemotePath($identifier);`
 */
function _createGetUriOfRemotePathAssignmentExpression(identifier) {
  var callExpression = t.callExpression(
  /* callee */t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('_connection')), t.identifier('getUriOfRemotePath')),
  /* arguments */[identifier]);

  return t.expressionStatement(t.assignmentExpression(
  /* operator */'=',
  /* left */identifier,
  /* right */callExpression));
}

/**
 * It creates a manipulation assigment expression for an identifier node, by comparing it's flow
 * type with typeNodeValidator.
 *
 * The key feature is that if the node is an Object or an Array, and the object's property or
 * the array's item matches given flow type according to node's flow type definition, the
 * creator could handle it and create correct assignment expression. As long as the flow type of
 * the node is a valid json object, this creator could create the expected assignment
 * expression.
 *
 * For example, say we are intersted in flow type `fooType` and we want to manipulate the
 * object with `fooType` by `object = bar(object)`. Following the expected result of created
 * assignmentExpression:
 *
 * `object: fooType` => `object = bar(object)`.
 *
 * `object: {a: fooType, b: number}` => `object.a = bar(object.a)`.
 *
 * `object: Array<fooType>` => 'object = object.map((arg) => {return bar(arg)})`.
 *
 */

var ManipulationAssignmentExpressionCreator = (function () {
  /**
   * Initialize the creator.
   * @param typeNodeValidator A function who take a FlowTypeNode as argument and return true
   *    if it is the type we want to manipulate.
   * @param identifierToAssignmentExpression A function who take an idnentifier as argument and
   *    create an manipulation assignment expression.
   */

  function ManipulationAssignmentExpressionCreator(typeNodeValidator, identifierToAssignmentExpression) {
    _classCallCheck(this, ManipulationAssignmentExpressionCreator);

    this._typeNodeValidator = typeNodeValidator;
    this._identifierToAssignmentExpression = identifierToAssignmentExpression;
  }

  /**
   * Create the manipulation assignment expression for the identifier if the flowTypeNode or the
   * flowTypeNode's nested node matches the typeNodeValidator. If nothing matches, just return
   * null.
   */

  _createClass(ManipulationAssignmentExpressionCreator, [{
    key: 'create',
    value: function create(flowTypeNode, identifier) {
      return this._visit(flowTypeNode, identifier);
    }
  }, {
    key: '_visit',
    value: function _visit(flowTypeNode, identifier) {
      if (this._typeNodeValidator(flowTypeNode)) {
        return this._identifierToAssignmentExpression(identifier);
      }

      if (flowTypeNode.type === 'GenericTypeAnnotation') {
        return this._visitGenericTypeAnnotationNode(flowTypeNode, identifier);
      } else if (flowTypeNode.type === 'ObjectTypeAnnotation') {
        return this._visitObjectTypeAnnotationNode(flowTypeNode, identifier);
      } else if (flowTypeNode.type === 'NullableTypeAnnotation') {
        return this._visitNullableTypeAnnotationNode(flowTypeNode, identifier);
      } else {
        return null;
      }
    }
  }, {
    key: '_visitGenericTypeAnnotationNode',
    value: function _visitGenericTypeAnnotationNode(flowTypeNode, identifier) {
      if (flowTypeNode.id && flowTypeNode.id.type === 'Identifier' && flowTypeNode.id.name === 'Array') {
        return this._visitArrayTypeAnnotationNode(flowTypeNode, identifier);
      } else {
        return null;
      }
    }

    /**
     * Visit the node typed as `Array<$nestedFlowType>` and create the manipulation
     * expression if nestedFlowType should be manipulate.
     *
     * For example, if the nestedFlowType should be manipuated,  the generated expression will be
     * in following form:
     * ```
     * identifier = identifier.map(arg0 => {
     *   arg0 = manipulation(arg0);
     *   return arg0;
     * });
     * ```
     */
  }, {
    key: '_visitArrayTypeAnnotationNode',
    value: function _visitArrayTypeAnnotationNode(flowTypeNode, identifier) {
      // Skip if there is either no nested flow type or more than one.
      if (!flowTypeNode.typeParameters || flowTypeNode.typeParameters.params.length !== 1) {
        return null;
      }

      var nestedFlowType = flowTypeNode.typeParameters.params[0];
      var arrowFunctionParam = t.identifier('item');
      var assignmentExpression = this._visit(nestedFlowType, arrowFunctionParam);

      if (!assignmentExpression) {
        return null;
      }

      var arrowFunction = t.arrowFunctionExpression(
      /* params */[arrowFunctionParam],
      /* body */t.blockStatement([assignmentExpression, t.returnStatement(arrowFunctionParam)]));

      var callArrayMapExpression = t.callExpression(
      /* callee */t.memberExpression(identifier, t.identifier('map')),
      /* arguments */[arrowFunction]);

      return t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */identifier,
      /* right */callArrayMapExpression));
    }

    /**
     * Visit the node typed as `{property0: flowType0, property1: flowtype1... }` and create the
     * manipulation expression if any of its properties should be manipulated.
     *
     * For example, if `identifier.property0` should be manipuated,  the generated expression will be
     * in following form:
     * ```
     * identifier = ((obj) => {
     *  obj = require('nuclide-commons').object.assign({}, obj);
     *  obj.property0 = manipulation(obj.property0);
     * }) (identifier);
     *
     * ```
     */
  }, {
    key: '_visitObjectTypeAnnotationNode',
    value: function _visitObjectTypeAnnotationNode(flowTypeNode, identifier) {
      var _this = this;

      var objectIdentifier = t.identifier('obj');
      var assignmentExpressions = [];

      flowTypeNode.properties.forEach(function (property) {
        var key = property.key;
        if (key.type !== 'Identifier') {
          return;
        }

        var propertyExpression = t.memberExpression(objectIdentifier, t.identifier(key.name));
        var assignmentExpression = _this._visit(property.value, propertyExpression);

        if (assignmentExpression) {
          assignmentExpressions.push(assignmentExpression);
        }
      });

      // Skip if the the properties don't need to be manipuated.
      if (assignmentExpressions.length === 0) {
        return null;
      }

      // Create expression of `obj = require('nuclide-commons').object.assign({}, obj);`.
      var shallowCopyExpression = t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */objectIdentifier,
      /* right */t.callExpression(
      /* callee */t.memberExpression(t.memberExpression(t.callExpression(
      /* callee */t.identifier('require'),
      /* arguments */[t.literal('nuclide-commons')]), t.identifier('object')), t.identifier('assign')),
      /* arguments */[t.objectExpression([]), objectIdentifier])));

      var arrowFunction = t.arrowFunctionExpression(
      /* params */[objectIdentifier],
      /* body */t.blockStatement([shallowCopyExpression].concat(assignmentExpressions, t.returnStatement(objectIdentifier))));

      var callArrowFunctionExpression = t.callExpression(
      /* callee */arrowFunction,
      /* arguments */[identifier]);

      return t.expressionStatement(t.assignmentExpression(
      /* operator */'=',
      /* left */identifier,
      /* right */callArrowFunctionExpression));
    }

    /**
     * Visit the node typed as `?$nestedFlowType` (nullable) and create the if statement
     * manipulation expression if the nested flow type should be manipulated.
     *
     * For example, if `identifier: ?$nestedFlowType` should be manipuated,  the generated expression will be
     * in following form:
     * ```
     * if (identifier !== null) {
     *   identifier = manipulation(identifier);
     * }
     * ```
     */
  }, {
    key: '_visitNullableTypeAnnotationNode',
    value: function _visitNullableTypeAnnotationNode(flowTypeNode, identifier) {
      if (!flowTypeNode.typeAnnotation) {
        return null;
      }

      var assignmentExpression = this._visit(flowTypeNode.typeAnnotation, identifier);

      if (!assignmentExpression) {
        return null;
      }

      return t.ifStatement(
      /* test */t.binaryExpression('!==', identifier, t.literal(null)),
      /* consequent */t.blockStatement([assignmentExpression]));
    }
  }]);

  return ManipulationAssignmentExpressionCreator;
})();

module.exports = {
  ManipulationAssignmentExpressionCreator: ManipulationAssignmentExpressionCreator,

  createGetPathOfUriAssignmentExpression: function createGetPathOfUriAssignmentExpression(flowTypeNode, identifier) {
    var creator = new ManipulationAssignmentExpressionCreator(isNuclideUriFlowTypeAnnotation, _createGetPathOfUriAssignmentExpression);
    return creator.create(flowTypeNode, identifier);
  },

  createGetUriOfRemotePathAssignmentExpression: function createGetUriOfRemotePathAssignmentExpression(flowTypeNode, identifier) {
    var creator = new ManipulationAssignmentExpressionCreator(isNuclideUriFlowTypeAnnotation, _createGetUriOfRemotePathAssignmentExpression);
    return creator.create(flowTypeNode, identifier);
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL251Y2xpZGUtdXJpLXRyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7ZUFXMkIsT0FBTyxDQUFDLG1CQUFtQixDQUFDOztJQUE5RCw4QkFBOEIsWUFBOUIsOEJBQThCOztBQUNuQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDOzs7Ozs7QUFVcEMsU0FBUyx1Q0FBc0MsQ0FBQyxVQUFzQixFQUF3QjtBQUM1RixNQUFJLGNBQWMsR0FBRyxDQUFDLENBQUMsY0FBYztjQUN0QixDQUFDLENBQUMsZ0JBQWdCLENBQzdCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDaEIsQ0FBQyxDQUFDLGNBQWMsRUFBRSxFQUNsQixDQUFDLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUM1QixFQUNELENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQzdCO2lCQUNlLENBQUMsVUFBVSxDQUFDLENBQzdCLENBQUM7O0FBRUYsU0FBTyxDQUFDLENBQUMsbUJBQW1CLENBQzFCLENBQUMsQ0FBQyxvQkFBb0I7Z0JBQ0wsR0FBRztZQUNQLFVBQVU7YUFDVCxjQUFjLENBQzNCLENBQ0YsQ0FBQztDQUNIOzs7Ozs7QUFNRCxTQUFTLDZDQUE0QyxDQUFDLFVBQXNCLEVBQXdCO0FBQ2xHLE1BQUksY0FBYyxHQUFHLENBQUMsQ0FBQyxjQUFjO2NBQ3RCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDN0IsQ0FBQyxDQUFDLGdCQUFnQixDQUNoQixDQUFDLENBQUMsY0FBYyxFQUFFLEVBQ2xCLENBQUMsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQzVCLEVBQ0QsQ0FBQyxDQUFDLFVB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OztBQUVELFVBQUksb0JBQW9CLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFDOztBQUVoRixVQUFJLENBQUMsb0JBQW9CLEVBQUU7QUFDekIsZUFBTyxJQUFJLENBQUM7T0FDYjs7QUFFRCxhQUFPLENBQUMsQ0FBQyxXQUFXO2dCQUNQLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7c0JBQ2hELENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQzFELENBQUM7S0FDSDs7O1NBeE5HLHVDQUF1Qzs7O0FBMk43QyxNQUFNLENBQUMsT0FBTyxHQUFHO0FBQ2YseUNBQXVDLEVBQXZDLHVDQUF1Qzs7QUFFdkMsd0NBQXNDLEVBQUEsZ0RBQ3BDLFlBQTBCLEVBQzFCLFVBQXNCLEVBQ0M7QUFDdkIsUUFBSSxPQUFPLEdBQUcsSUFBSSx1Q0FBdUMsQ0FDckQsOEJBQThCLEVBQzlCLHVDQUFzQyxDQUFDLENBQUM7QUFDNUMsV0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztHQUNqRDs7QUFFRCw4Q0FBNEMsRUFBQSxzREFDMUMsWUFBMEIsRUFDMUIsVUFBc0IsRUFDQztBQUN2QixRQUFJLE9BQU8sR0FBRyxJQUFJLHVDQUF1QyxDQUNyRCw4QkFBOEIsRUFDOUIsNkNBQTRDLENBQUMsQ0FBQztBQUNsRCxXQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0dBQ2pEO0NBQ0YsQ0FBQSIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wZW1tMkh1cHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1zZXJ2aWNlLXRyYW5zZm9ybWVyL2xpYi9udWNsaWRlLXVyaS10cmFuc2Zvcm1lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciB7aXNOdWNsaWRlVXJpRmxvd1R5cGVBbm5vdGF0aW9ufSA9IHJlcXVpcmUoJy4vZmxvdy1hbm5vdGF0aW9uJyk7XG52YXIgdCA9IHJlcXVpcmUoJ2JhYmVsLWNvcmUnKS50eXBlcztcblxudHlwZSBJZGVudGlmaWVyID0gYW55O1xudHlwZSBBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFueTtcbnR5cGUgRmxvd1R5cGVOb2RlID0gYW55O1xuXG4vKipcbiAqIEdpdmVuIHRoZSBpZGVudGlmaWVyLCBjcmVhdGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgZXhwcmVzc2lvbjpcbiAqIGAkaWRlbnRpZmllciAgPSB0aGlzLl9jb25uZWN0aW9uLmdldFBhdGhPZlVyaSgkaWRlbnRpZmllcik7YFxuICovXG5mdW5jdGlvbiBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbihpZGVudGlmaWVyOiBJZGVudGlmaWVyKTogQXNzaWdubWVudEV4cHJlc3Npb24ge1xuICB2YXIgY2FsbEV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgdC5pZGVudGlmaWVyKCdfY29ubmVjdGlvbicpXG4gICAgICApLFxuICAgICAgdC5pZGVudGlmaWVyKCdnZXRQYXRoT2ZVcmknKVxuICAgICksXG4gICAgLyogYXJndW1lbnRzICovIFtpZGVudGlmaWVyXSxcbiAgKTtcblxuICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAvKiBvcGVyYXRvciAqLyAnPScsXG4gICAgICAvKiBsZWZ0ICovIGlkZW50aWZpZXIsXG4gICAgICAvKiByaWdodCAqLyBjYWxsRXhwcmVzc2lvbixcbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGlkZW50aWZpZXIsIGNyZWF0ZSBmb2xsb3dpbmcgYXNzaWdubWVudCBleHByZXNzaW9uOlxuICogYCRpZGVudGlmaWVyICA9IHRoaXMuX2Nvbm5lY3Rpb24uZ2V0VXJpT2ZSZW1vdGVQYXRoKCRpZGVudGlmaWVyKTtgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdldFVyaU9mUmVtb3RlUGF0aEFzc2lnbm1lbnRFeHByZXNzaW9uKGlkZW50aWZpZXI6IElkZW50aWZpZXIpOiBBc3NpZ25tZW50RXhwcmVzc2lvbiB7XG4gIHZhciBjYWxsRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgLyogY2FsbGVlICovIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICB0LmlkZW50aWZpZXIoJ19jb25uZWN0aW9uJylcbiAgICAgICksXG4gICAgICB0LmlkZW50aWZpZXIoJ2dldFVyaU9mUmVtb3RlUGF0aCcpXG4gICAgKSxcbiAgICAvKiBhcmd1bWVudHMgKi8gW2lkZW50aWZpZXJdLFxuICApO1xuXG4gIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgIC8qIGxlZnQgKi8gaWRlbnRpZmllcixcbiAgICAgIC8qIHJpZ2h0ICovIGNhbGxFeHByZXNzaW9uLFxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBJdCBjcmVhdGVzIGEgbWFuaXB1bGF0aW9uIGFzc2lnbWVudCBleHByZXNzaW9uIGZvciBhbiBpZGVudGlmaWVyIG5vZGUsIGJ5IGNvbXBhcmluZyBpdCdzIGZsb3dcbiAqIHR5cGUgd2l0aCB0eXBlTm9kZVZhbGlkYXRvci5cbiAqXG4gKiBUaGUga2V5IGZlYXR1cmUgaXMgdGhhdCBpZiB0aGUgbm9kZSBpcyBhbiBPYmplY3Qgb3IgYW4gQXJyYXksIGFuZCB0aGUgb2JqZWN0J3MgcHJvcGVydHkgb3JcbiAqIHRoZSBhcnJheSdzIGl0ZW0gbWF0Y2hlcyBnaXZlbiBmbG93IHR5cGUgYWNjb3JkaW5nIHRvIG5vZGUncyBmbG93IHR5cGUgZGVmaW5pdGlvbiwgdGhlXG4gKiBjcmVhdG9yIGNvdWxkIGhhbmRsZSBpdCBhbmQgY3JlYXRlIGNvcnJlY3QgYXNzaWdubWVudCBleHByZXNzaW9uLiBBcyBsb25nIGFzIHRoZSBmbG93IHR5cGUgb2ZcbiAqIHRoZSBub2RlIGlzIGEgdmFsaWQganNvbiBvYmplY3QsIHRoaXMgY3JlYXRvciBjb3VsZCBjcmVhdGUgdGhlIGV4cGVjdGVkIGFzc2lnbm1lbnRcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogRm9yIGV4YW1wbGUsIHNheSB3ZSBhcmUgaW50ZXJzdGVkIGluIGZsb3cgdHlwZSBgZm9vVHlwZWAgYW5kIHdlIHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGVcbiAqIG9iamVjdCB3aXRoIGBmb29UeXBlYCBieSBgb2JqZWN0ID0gYmFyKG9iamVjdClgLiBGb2xsb3dpbmcgdGhlIGV4cGVjdGVkIHJlc3VsdCBvZiBjcmVhdGVkXG4gKiBhc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAqXG4gKiBgb2JqZWN0OiBmb29UeXBlYCA9PiBgb2JqZWN0ID0gYmFyKG9iamVjdClgLlxuICpcbiAqIGBvYmplY3Q6IHthOiBmb29UeXBlLCBiOiBudW1iZXJ9YCA9PiBgb2JqZWN0LmEgPSBiYXIob2JqZWN0LmEpYC5cbiAqXG4gKiBgb2JqZWN0OiBBcnJheTxmb29UeXBlPmAgPT4gJ29iamVjdCA9IG9iamVjdC5tYXAoKGFyZykgPT4ge3JldHVybiBiYXIoYXJnKX0pYC5cbiAqXG4gKi9cbmNsYXNzIE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvciB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBjcmVhdG9yLlxuICAgKiBAcGFyYW0gdHlwZU5vZGVWYWxpZGF0b3IgQSBmdW5jdGlvbiB3aG8gdGFrZSBhIEZsb3dUeXBlTm9kZSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuIHRydWVcbiAgICogICAgaWYgaXQgaXMgdGhlIHR5cGUgd2Ugd2FudCB0byBtYW5pcHVsYXRlLlxuICAgKiBAcGFyYW0gaWRlbnRpZmllclRvQXNzaWdubWVudEV4cHJlc3Npb24gQSBmdW5jdGlvbiB3aG8gdGFrZSBhbiBpZG5lbnRpZmllciBhcyBhcmd1bWVudCBhbmRcbiAgICogICAgY3JlYXRlIGFuIG1hbmlwdWxhdGlvbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlTm9kZVZhbGlkYXRvcjogKHR5cGVOb2RlOiBGbG93VHlwZU5vZGUpID0+IGJvb2xlYW4sXG4gICAgICBpZGVudGlmaWVyVG9Bc3NpZ25tZW50RXhwcmVzc2lvbjogKGlkZW50aWZpZXI6IElkZW50aWZpZXIpID0+IEFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5fdHlwZU5vZGVWYWxpZGF0b3IgPSB0eXBlTm9kZVZhbGlkYXRvcjtcbiAgICB0aGlzLl9pZGVudGlmaWVyVG9Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGlkZW50aWZpZXJUb0Fzc2lnbm1lbnRFeHByZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWFuaXB1bGF0aW9uIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGlkZW50aWZpZXIgaWYgdGhlIGZsb3dUeXBlTm9kZSBvciB0aGVcbiAgICogZmxvd1R5cGVOb2RlJ3MgbmVzdGVkIG5vZGUgbWF0Y2hlcyB0aGUgdHlwZU5vZGVWYWxpZGF0b3IuIElmIG5vdGhpbmcgbWF0Y2hlcywganVzdCByZXR1cm5cbiAgICogbnVsbC5cbiAgICovXG4gIGNyZWF0ZShmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2l0KGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gIH1cblxuICBfdmlzaXQoZmxvd1R5cGVOb2RlOiBGbG93VHlwZU5vZGUsIGlkZW50aWZpZXI6IElkZW50aWZpZXIpOiA/QXNzaWdubWVudEV4cHJlc3Npb24ge1xuICAgIGlmICh0aGlzLl90eXBlTm9kZVZhbGlkYXRvcihmbG93VHlwZU5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWRlbnRpZmllclRvQXNzaWdubWVudEV4cHJlc3Npb24oaWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgaWYgKGZsb3dUeXBlTm9kZS50eXBlID09PSAnR2VuZXJpY1R5cGVBbm5vdGF0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0R2VuZXJpY1R5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGUsIGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoZmxvd1R5cGVOb2RlLnR5cGUgPT09ICdPYmplY3RUeXBlQW5ub3RhdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXNpdE9iamVjdFR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGUsIGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoZmxvd1R5cGVOb2RlLnR5cGUgPT09ICdOdWxsYWJsZVR5cGVBbm5vdGF0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0TnVsbGFibGVUeXBlQW5ub3RhdGlvbk5vZGUoZmxvd1R5cGVOb2RlLCBpZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgX3Zpc2l0R2VuZXJpY1R5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbntcbiAgICBpZiAoZmxvd1R5cGVOb2RlLmlkICYmXG4gICAgICAgIGZsb3dUeXBlTm9kZS5pZC50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgZmxvd1R5cGVOb2RlLmlkLm5hbWUgPT09ICdBcnJheScpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXNpdEFycmF5VHlwZUFubm90YXRpb25Ob2RlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWaXNpdCB0aGUgbm9kZSB0eXBlZCBhcyBgQXJyYXk8JG5lc3RlZEZsb3dUeXBlPmAgYW5kIGNyZWF0ZSB0aGUgbWFuaXB1bGF0aW9uXG4gICAqIGV4cHJlc3Npb24gaWYgbmVzdGVkRmxvd1R5cGUgc2hvdWxkIGJlIG1hbmlwdWxhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgbmVzdGVkRmxvd1R5cGUgc2hvdWxkIGJlIG1hbmlwdWF0ZWQsICB0aGUgZ2VuZXJhdGVkIGV4cHJlc3Npb24gd2lsbCBiZVxuICAgKiBpbiBmb2xsb3dpbmcgZm9ybTpcbiAgICogYGBgXG4gICAqIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyLm1hcChhcmcwID0+IHtcbiAgICogICBhcmcwID0gbWFuaXB1bGF0aW9uKGFyZzApO1xuICAgKiAgIHJldHVybiBhcmcwO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfdmlzaXRBcnJheVR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9Bc3NpZ25tZW50RXhwcmVzc2lvbntcbiAgICAvLyBTa2lwIGlmIHRoZXJlIGlzIGVpdGhlciBubyBuZXN0ZWQgZmxvdyB0eXBlIG9yIG1vcmUgdGhhbiBvbmUuXG4gICAgaWYgKCFmbG93VHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgfHxcbiAgICAgICAgZmxvd1R5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBuZXN0ZWRGbG93VHlwZSA9IGZsb3dUeXBlTm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXNbMF07XG4gICAgdmFyIGFycm93RnVuY3Rpb25QYXJhbSA9IHQuaWRlbnRpZmllcignaXRlbScpO1xuICAgIHZhciBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IHRoaXMuX3Zpc2l0KG5lc3RlZEZsb3dUeXBlLCBhcnJvd0Z1bmN0aW9uUGFyYW0pO1xuXG4gICAgaWYgKCFhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFycm93RnVuY3Rpb24gPSB0LmFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgLyogcGFyYW1zICovIFthcnJvd0Z1bmN0aW9uUGFyYW1dLFxuICAgICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgICBbXG4gICAgICAgICAgYXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgICAgdC5yZXR1cm5TdGF0ZW1lbnQoYXJyb3dGdW5jdGlvblBhcmFtKSxcbiAgICAgICAgXVxuICAgICAgKVxuICAgICk7XG5cbiAgICB2YXIgY2FsbEFycmF5TWFwRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAvKiBjYWxsZWUgKi8gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICB0LmlkZW50aWZpZXIoJ21hcCcpLFxuICAgICAgKSxcbiAgICAgIC8qIGFyZ3VtZW50cyAqLyBbYXJyb3dGdW5jdGlvbl0sXG4gICAgKTtcblxuICAgIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICAvKiBvcGVyYXRvciAqLyAnPScsXG4gICAgICAgIC8qIGxlZnQgKi8gaWRlbnRpZmllcixcbiAgICAgICAgLyogcmlnaHQgKi8gY2FsbEFycmF5TWFwRXhwcmVzc2lvbixcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZpc2l0IHRoZSBub2RlIHR5cGVkIGFzIGB7cHJvcGVydHkwOiBmbG93VHlwZTAsIHByb3BlcnR5MTogZmxvd3R5cGUxLi4uIH1gIGFuZCBjcmVhdGUgdGhlXG4gICAqIG1hbmlwdWxhdGlvbiBleHByZXNzaW9uIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBzaG91bGQgYmUgbWFuaXB1bGF0ZWQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiBgaWRlbnRpZmllci5wcm9wZXJ0eTBgIHNob3VsZCBiZSBtYW5pcHVhdGVkLCAgdGhlIGdlbmVyYXRlZCBleHByZXNzaW9uIHdpbGwgYmVcbiAgICogaW4gZm9sbG93aW5nIGZvcm06XG4gICAqIGBgYFxuICAgKiBpZGVudGlmaWVyID0gKChvYmopID0+IHtcbiAgICogIG9iaiA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpLm9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAqICBvYmoucHJvcGVydHkwID0gbWFuaXB1bGF0aW9uKG9iai5wcm9wZXJ0eTApO1xuICAgKiB9KSAoaWRlbnRpZmllcik7XG4gICAqXG4gICAqIGBgYFxuICAgKi9cbiAgX3Zpc2l0T2JqZWN0VHlwZUFubm90YXRpb25Ob2RlKGZsb3dUeXBlTm9kZTogRmxvd1R5cGVOb2RlLCBpZGVudGlmaWVyOiBJZGVudGlmaWVyKTogP0Fzc2lnbm1lbnRFeHByZXNzaW9uIHtcbiAgICB2YXIgb2JqZWN0SWRlbnRpZmllciA9IHQuaWRlbnRpZmllcignb2JqJyk7XG4gICAgdmFyIGFzc2lnbm1lbnRFeHByZXNzaW9ucyA9IFtdO1xuXG4gICAgZmxvd1R5cGVOb2RlLnByb3BlcnRpZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICB2YXIga2V5ID0gcHJvcGVydHkua2V5O1xuICAgICAgaWYgKGtleS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHlFeHByZXNzaW9uID0gdC5tZW1iZXJFeHByZXNzaW9uKG9iamVjdElkZW50aWZpZXIsIHQuaWRlbnRpZmllcihrZXkubmFtZSkpO1xuICAgICAgdmFyIGFzc2lnbm1lbnRFeHByZXNzaW9uID0gdGhpcy5fdmlzaXQocHJvcGVydHkudmFsdWUsIHByb3BlcnR5RXhwcmVzc2lvbik7XG5cbiAgICAgIGlmIChhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICBhc3NpZ25tZW50RXhwcmVzc2lvbnMucHVzaChhc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIGlmIHRoZSB0aGUgcHJvcGVydGllcyBkb24ndCBuZWVkIHRvIGJlIG1hbmlwdWF0ZWQuXG4gICAgaWYgKGFzc2lnbm1lbnRFeHByZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBleHByZXNzaW9uIG9mIGBvYmogPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKS5vYmplY3QuYXNzaWduKHt9LCBvYmopO2AuXG4gICAgdmFyIHNoYWxsb3dDb3B5RXhwcmVzc2lvbiA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgICAgLyogbGVmdCAqLyBvYmplY3RJZGVudGlmaWVyLFxuICAgICAgICAvKiByaWdodCAqLyB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIC8qIGNhbGxlZSAqLyB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgLyogY2FsbGVlICovIHQuaWRlbnRpZmllcigncmVxdWlyZScpLFxuICAgICAgICAgICAgICAgIC8qIGFyZ3VtZW50cyAqLyBbdC5saXRlcmFsKCdudWNsaWRlLWNvbW1vbnMnKV1cbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKCdvYmplY3QnKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcignYXNzaWduJylcbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIGFyZ3VtZW50cyAqLyBbXG4gICAgICAgICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW10pLFxuICAgICAgICAgICAgb2JqZWN0SWRlbnRpZmllcixcbiAgICAgICAgICBdLFxuICAgICAgICApLFxuICAgICAgKVxuICAgICk7XG5cbiAgICB2YXIgYXJyb3dGdW5jdGlvbiA9IHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAvKiBwYXJhbXMgKi8gW29iamVjdElkZW50aWZpZXJdLFxuICAgICAgLyogYm9keSAqLyB0LmJsb2NrU3RhdGVtZW50KFxuICAgICAgICBbc2hhbGxvd0NvcHlFeHByZXNzaW9uXS5jb25jYXQoXG4gICAgICAgICAgYXNzaWdubWVudEV4cHJlc3Npb25zLFxuICAgICAgICAgIHQucmV0dXJuU3RhdGVtZW50KG9iamVjdElkZW50aWZpZXIpLFxuICAgICAgICApLFxuICAgICAgKVxuICAgICk7XG5cbiAgICB2YXIgY2FsbEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIC8qIGNhbGxlZSAqLyBhcnJvd0Z1bmN0aW9uLFxuICAgICAgLyogYXJndW1lbnRzICovIFtpZGVudGlmaWVyXSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgICAgIC8qIG9wZXJhdG9yICovICc9JyxcbiAgICAgICAgLyogbGVmdCAqLyBpZGVudGlmaWVyLFxuICAgICAgICAvKiByaWdodCAqLyBjYWxsQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWaXNpdCB0aGUgbm9kZSB0eXBlZCBhcyBgPyRuZXN0ZWRGbG93VHlwZWAgKG51bGxhYmxlKSBhbmQgY3JlYXRlIHRoZSBpZiBzdGF0ZW1lbnRcbiAgICogbWFuaXB1bGF0aW9uIGV4cHJlc3Npb24gaWYgdGhlIG5lc3RlZCBmbG93IHR5cGUgc2hvdWxkIGJlIG1hbmlwdWxhdGVkLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYGlkZW50aWZpZXI6ID8kbmVzdGVkRmxvd1R5cGVgIHNob3VsZCBiZSBtYW5pcHVhdGVkLCAgdGhlIGdlbmVyYXRlZCBleHByZXNzaW9uIHdpbGwgYmVcbiAgICogaW4gZm9sbG93aW5nIGZvcm06XG4gICAqIGBgYFxuICAgKiBpZiAoaWRlbnRpZmllciAhPT0gbnVsbCkge1xuICAgKiAgIGlkZW50aWZpZXIgPSBtYW5pcHVsYXRpb24oaWRlbnRpZmllcik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfdmlzaXROdWxsYWJsZVR5cGVBbm5vdGF0aW9uTm9kZShmbG93VHlwZU5vZGU6IEZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcjogSWRlbnRpZmllcik6ID9hbnkge1xuICAgIGlmICghZmxvd1R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzaWdubWVudEV4cHJlc3Npb24gPSB0aGlzLl92aXNpdChmbG93VHlwZU5vZGUudHlwZUFubm90YXRpb24sIGlkZW50aWZpZXIpO1xuXG4gICAgaWYgKCFhc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQuaWZTdGF0ZW1lbnQoXG4gICAgICAvKiB0ZXN0ICovIHQuYmluYXJ5RXhwcmVzc2lvbignIT09JywgaWRlbnRpZmllciwgdC5saXRlcmFsKG51bGwpKSxcbiAgICAgIC8qIGNvbnNlcXVlbnQgKi8gdC5ibG9ja1N0YXRlbWVudChbYXNzaWdubWVudEV4cHJlc3Npb25dKSxcbiAgICApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNYW5pcHVsYXRpb25Bc3NpZ25tZW50RXhwcmVzc2lvbkNyZWF0b3IsXG5cbiAgY3JlYXRlR2V0UGF0aE9mVXJpQXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgZmxvd1R5cGVOb2RlOiBGbG93VHlwZU5vZGUsXG4gICAgaWRlbnRpZmllcjogSWRlbnRpZmllclxuICApOiA/QXNzaWdubWVudEV4cHJlc3Npb24ge1xuICAgIHZhciBjcmVhdG9yID0gbmV3IE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvcihcbiAgICAgICAgaXNOdWNsaWRlVXJpRmxvd1R5cGVBbm5vdGF0aW9uLFxuICAgICAgICBjcmVhdGVHZXRQYXRoT2ZVcmlBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIGNyZWF0b3IuY3JlYXRlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gIH0sXG5cbiAgY3JlYXRlR2V0VXJpT2ZSZW1vdGVQYXRoQXNzaWdubWVudEV4cHJlc3Npb24oXG4gICAgZmxvd1R5cGVOb2RlOiBGbG93VHlwZU5vZGUsXG4gICAgaWRlbnRpZmllcjogSWRlbnRpZmllclxuICApOiA/QXNzaWdubWVudEV4cHJlc3Npb24ge1xuICAgIHZhciBjcmVhdG9yID0gbmV3IE1hbmlwdWxhdGlvbkFzc2lnbm1lbnRFeHByZXNzaW9uQ3JlYXRvcihcbiAgICAgICAgaXNOdWNsaWRlVXJpRmxvd1R5cGVBbm5vdGF0aW9uLFxuICAgICAgICBjcmVhdGVHZXRVcmlPZlJlbW90ZVBhdGhBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIGNyZWF0b3IuY3JlYXRlKGZsb3dUeXBlTm9kZSwgaWRlbnRpZmllcik7XG4gIH0sXG59XG4iXX0=
