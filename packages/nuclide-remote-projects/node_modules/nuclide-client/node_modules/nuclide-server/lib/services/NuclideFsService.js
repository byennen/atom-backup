var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

/**
 * If no file (or directory) at the specified path exists, creates the parent
 * directories (if necessary) and then writes an empty file at the specified
 * path.
 *
 * @return A boolean indicating whether the file was created.
 */

var newFile = _asyncToGenerator(function* (filePath) {
  var isExistingFile = yield fsPromise.exists(filePath);
  if (isExistingFile) {
    return false;
  }
  yield fsPromise.mkdirp(pathUtil.dirname(filePath));
  yield fsPromise.writeFile(filePath, '');
  return true;
}

/**
 * The readdir endpoint accepts the following query parameters:
 *
 *   path: path to the folder to list entries inside.
 *
 * Body contains a JSON encoded array of objects with file: and stats: entries.
 * file: has the file or directory name, stats: has the stats of the file/dir,
 * isSymbolicLink: true if the entry is a symlink to another filesystem location.
 */
);

var readdir = _asyncToGenerator(function* (path) {
  var files = yield fsPromise.readdir(path);
  var entries = yield Promise.all(files.map(_asyncToGenerator(function* (file) {
    var fullpath = pathUtil.join(path, file);
    var lstats = yield fsPromise.lstat(fullpath);
    if (!lstats.isSymbolicLink()) {
      return { file: file, stats: lstats, isSymbolicLink: false };
    } else {
      try {
        var stats = yield fsPromise.stat(fullpath);
        return { file: file, stats: stats, isSymbolicLink: true };
      } catch (error) {
        return { file: file, stats: undefined, isSymbolicLink: true, error: error };
      }
    }
  })));
  // TODO: Return entries directly and change client to handle error.
  return entries.filter(function (entry) {
    return entry.error === undefined;
  });
}

/**
 * Gets the real path of a file path.
 * It could be different than the given path if the file is a symlink
 * or exists in a symlinked directory.
 */
);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

// TODO: Add ServerResponse type to flow

///////////////////
//
// Services
//
//////////////////

/**
 * Checks a certain path for existence and returns 'true'/'false' accordingly
 */
'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * This code implements the NuclideFs service.  It exports the FS on http via
 * the endpoint: http://your.server:your_port/fs/method where method is one of
 * readFile, writeFile, etc.
 */

var fs = require('fs');
var pathUtil = require('path');
var mv = require('mv');
var temp = require('temp');

var _require = require('nuclide-commons');

var fsPromise = _require.fsPromise;

var _require2 = require('../utils');

var deserializeArgs = _require2.deserializeArgs;
function exists(path) {
  return fsPromise.exists(path);
}

function findNearestFile(fileName, pathToDirectory) {
  return fsPromise.findNearestFile(fileName, pathToDirectory);
}

/**
 * The lstat endpoint is the same as the stat endpoint except it will return
 * the stat of a link instead of the file the link points to.
 */
function lstat(path) {
  return fsPromise.lstat(path);
}

/**
 * Creates a new directory with the given path.
 * Throws EEXIST error if the directory already exists.
 * Throws ENOENT if the path given is nested in a non-existing directory.
 */
function mkdir(path) {
  return fsPromise.mkdir(path);
}

/**
 * Runs the equivalent of `mkdir -p` with the given path.
 *
 * Like most implementations of mkdirp, if it fails, it is possible that
 * directories were created for some prefix of the given path.
 * @return true if the path was created; false if it already existed.
 */
function mkdirp(path) {
  return fsPromise.mkdirp(path);
}function realpath(path) {
  return fsPromise.realpath(path);
}

/**
 * Runs the equivalent of `mv sourcePath destinationPath`.
 */
function rename(sourcePath, destinationPath) {
  return new Promise(function (resolve, reject) {
    var fsPlus = require('fs-plus');
    fsPlus.move(sourcePath, destinationPath, function (error) {
      error ? reject(error) : resolve();
    });
  });
}

/**
 * Removes directories even if they are non-empty. Does not fail if the directory doesn't exist.
 */
function rmdir(path) {
  return fsPromise.rmdir(path);
}

/**
 * The stat endpoint accepts the following query parameters:
 *
 *   path: path to the file to read (that is it must be quoted)
 *
 * It returns a JSON encoded stats object that looks something like this:
 *
 * { dev: 2114,
 *  ino: 48064969,
 *  mode: 33188,
 *  nlink: 1,
 *  uid: 85,
 *  gid: 100,
 *  rdev: 0,
 *  size: 527,
 *  blksize: 4096,
 *  blocks: 8,
 *  atime: 'Mon, 10 Oct 2011 23:24:11 GMT',
 *  mtime: 'Mon, 10 Oct 2011 23:24:11 GMT',
 *  ctime: 'Mon, 10 Oct 2011 23:24:11 GMT',
 *  birthtime: 'Mon, 10 Oct 2011 23:24:11 GMT'
 * }
 *
 */
function stat(path) {
  return fsPromise.stat(path);
}

/**
 * Removes files. Does not fail if the file doesn't exist.
 */
function unlink(path) {
  return fsPromise.unlink(path)['catch'](function (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  });
}

///////////////////
//
// URL Handlers
//
//////////////////

/**
 * The readFile endpoint accepts the following query parameters:
 *
 *   path: the path to the file to read (it must be url encoded)
 *   options: JSON encoded + url encoded set of options that are passed to
 *            fs.createReadStream.
 *
 * It returns the contents of the file as binary in the body and sets
 * Content-Type to application/octet-stream.
 *
 * The readFile function takes a request and response  It has no return value.
 */
function readFile(request, response, next) {
  var _deserializeArgs = deserializeArgs(request.url);

  var _deserializeArgs2 = _slicedToArray(_deserializeArgs, 2);

  var path = _deserializeArgs2[0];
  var options = _deserializeArgs2[1];

  try {
    var fileStream = fs.createReadStream(path, options);

    fileStream.on('open', function (fd) {
      response.setHeader('Content-Type', 'application/octet-stream');
      fileStream.pipe(response);
    });

    fileStream.on('error', next);
  } catch (e) {
    next(new Error('NuclideFs.readFile for path ' + path + ' error: ' + e));
  }
}

/**
 * The writeFile endpoint accepts the following query parameters:
 *
 *   path: path to the file to read (it must be url encoded).
 *   options: JSON encoded + url encoded set of options that are passed to
 *            fs.createWriteStream.
 *
 * It expects the body of the request to be the binary contents you want written
 * to the file specified by the path query parameter.
 *
 * The writeFile function takes a request and response. It has no return value.
 */
function writeFile(request, response, next) {
  var _deserializeArgs3 = deserializeArgs(request.url);

  var _deserializeArgs32 = _slicedToArray(_deserializeArgs3, 2);

  var path = _deserializeArgs32[0];
  var options = _deserializeArgs32[1];

  temp.open('nuclide', function (error, info) {
    if (error) {
      next(error);
      return;
    }
    options = options || {};
    options.fd = info.fd;

    var failed = false;

    // While writing something goes wrong.
    var tempStream = request.pipe(fs.createWriteStream(path, options));

    var onError = function onError(streamError) {
      failed = true;
      tempStream.end();
      next(streamError);
    };

    request.on('error', onError);
    tempStream.on('error', onError);
    tempStream.on('close', _asyncToGenerator(function* () {
      if (failed) {
        // TODO(mikeo): Clean up temp file if failed.
        // next(streamError) has already been called, so nothing to do here.
        return;
      }

      // Ensure file still has original permissions:
      // https://github.com/facebook/nuclide/issues/157
      // We update the mode of the temp file rather than the destination file because
      // if we did the mv() then the chmod(), there would be a brief period between
      // those two operations where the destination file might have the wrong permissions.
      var permissions;
      try {
        var _ref = yield fsPromise.stat(path);

        var permissions = _ref.mode;
      } catch (e) {
        // If the file does not exist, then ENOENT will be thrown.
        if (e.code !== 'ENOENT') {
          throw error;
        }
      }
      var tempFilePath = info.path;
      if (permissions != null) {
        yield fsPromise.chmod(tempFilePath, permissions);
      }

      // TODO(mikeo): put renames into a queue so we don't write older save over new save.
      // Use mv as fs.rename doesn't work across partitions.
      mv(tempFilePath, path, { mkdirp: false }, _asyncToGenerator(function* (renameError) {
        if (renameError) {
          next(renameError);
        } else {
          response.end();
        }
      }));
    }));
  });
}

module.exports = {
  services: {
    '/fs/exists': { handler: exists },
    '/fs/findNearestFile': { handler: findNearestFile },
    '/fs/lstat': { handler: lstat },
    '/fs/mkdir': { handler: mkdir, method: 'post' },
    '/fs/mkdirp': { handler: mkdirp, method: 'post' },
    '/fs/newFile': { handler: newFile, method: 'post' },
    '/fs/readdir': { handler: readdir },
    '/fs/realpath': { handler: realpath, method: 'get', text: true },
    '/fs/rename': { handler: rename, method: 'post' },
    '/fs/rmdir': { handler: rmdir, method: 'post' },
    '/fs/stat': { handler: stat },
    '/fs/unlink': { handler: unlink, method: 'post' }
  },
  urlHandlers: {
    '/fs/readFile': { handler: readFile },
    '/fs/writeFile': { handler: writeFile, method: 'post' }
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvc2VydmljZXMvTnVjbGlkZUZzU2VydmljZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBaUZlLE9BQU8scUJBQXRCLFdBQXVCLFFBQWdCLEVBQW9CO0FBQ3pELE1BQUksY0FBYyxHQUFHLE1BQU0sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN0RCxNQUFJLGNBQWMsRUFBRTtBQUNsQixXQUFPLEtBQUssQ0FBQztHQUNkO0FBQ0QsUUFBTSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNuRCxRQUFNLFNBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7Ozs7Ozs7SUFXYyxPQUFPLHFCQUF0QixXQUF1QixJQUFZLEVBQWlDO0FBQ2xFLE1BQUksS0FBSyxHQUFHLE1BQU0sU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQyxNQUFJLE9BQU8sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsbUJBQUMsV0FBTyxJQUFJLEVBQUs7QUFDeEQsUUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDekMsUUFBSSxNQUFNLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdDLFFBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDNUIsYUFBTyxFQUFDLElBQUksRUFBSixJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxjQUFj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RSxFQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUM7QUFDM0IsZ0JBQVksRUFBRSxFQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBQztHQUNoRDtBQUNELGFBQVcsRUFBRTtBQUNYLGtCQUFjLEVBQUUsRUFBQyxPQUFPLEVBQUUsUUFBUSxFQUFDO0FBQ25DLG1CQUFlLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUM7R0FDdEQ7Q0FDRixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvc2VydmljZXMvTnVjbGlkZUZzU2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogVGhpcyBjb2RlIGltcGxlbWVudHMgdGhlIE51Y2xpZGVGcyBzZXJ2aWNlLiAgSXQgZXhwb3J0cyB0aGUgRlMgb24gaHR0cCB2aWFcbiAqIHRoZSBlbmRwb2ludDogaHR0cDovL3lvdXIuc2VydmVyOnlvdXJfcG9ydC9mcy9tZXRob2Qgd2hlcmUgbWV0aG9kIGlzIG9uZSBvZlxuICogcmVhZEZpbGUsIHdyaXRlRmlsZSwgZXRjLlxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aFV0aWwgPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgbXYgPSByZXF1aXJlKCdtdicpO1xudmFyIHRlbXAgPSByZXF1aXJlKCd0ZW1wJyk7XG52YXIge2ZzUHJvbWlzZX0gPSByZXF1aXJlKCdudWNsaWRlLWNvbW1vbnMnKTtcbnZhciB7ZGVzZXJpYWxpemVBcmdzfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnR5cGUgRmlsZVdpdGhTdGF0cyA9IHtmaWxlOiBzdHJpbmc7IHN0YXRzOiBmcy5TdGF0cywgZXJyb3I6ID9FcnJvcn07XG4vLyBUT0RPOiBBZGQgU2VydmVyUmVzcG9uc2UgdHlwZSB0byBmbG93XG5pbXBvcnQgdHlwZSB7SW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZX0gZnJvbSAnaHR0cCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFNlcnZpY2VzXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ2hlY2tzIGEgY2VydGFpbiBwYXRoIGZvciBleGlzdGVuY2UgYW5kIHJldHVybnMgJ3RydWUnLydmYWxzZScgYWNjb3JkaW5nbHlcbiAqL1xuZnVuY3Rpb24gZXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gZnNQcm9taXNlLmV4aXN0cyhwYXRoKTtcbn1cblxuZnVuY3Rpb24gZmluZE5lYXJlc3RGaWxlKGZpbGVOYW1lOiBzdHJpbmcsIHBhdGhUb0RpcmVjdG9yeTogc3RyaW5nKTogUHJvbWlzZTw/c3RyaW5nPiB7XG4gIHJldHVybiBmc1Byb21pc2UuZmluZE5lYXJlc3RGaWxlKGZpbGVOYW1lLCBwYXRoVG9EaXJlY3RvcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsc3RhdCBlbmRwb2ludCBpcyB0aGUgc2FtZSBhcyB0aGUgc3RhdCBlbmRwb2ludCBleGNlcHQgaXQgd2lsbCByZXR1cm5cbiAqIHRoZSBzdGF0IG9mIGEgbGluayBpbnN0ZWFkIG9mIHRoZSBmaWxlIHRoZSBsaW5rIHBvaW50cyB0by5cbiAqL1xuZnVuY3Rpb24gbHN0YXQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxmcy5TdGF0cz4ge1xuICByZXR1cm4gZnNQcm9taXNlLmxzdGF0KHBhdGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZGlyZWN0b3J5IHdpdGggdGhlIGdpdmVuIHBhdGguXG4gKiBUaHJvd3MgRUVYSVNUIGVycm9yIGlmIHRoZSBkaXJlY3RvcnkgYWxyZWFkeSBleGlzdHMuXG4gKiBUaHJvd3MgRU5PRU5UIGlmIHRoZSBwYXRoIGdpdmVuIGlzIG5lc3RlZCBpbiBhIG5vbi1leGlzdGluZyBkaXJlY3RvcnkuXG4gKi9cbmZ1bmN0aW9uIG1rZGlyKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBmc1Byb21pc2UubWtkaXIocGF0aCk7XG59XG5cbi8qKlxuICogUnVucyB0aGUgZXF1aXZhbGVudCBvZiBgbWtkaXIgLXBgIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gKlxuICogTGlrZSBtb3N0IGltcGxlbWVudGF0aW9ucyBvZiBta2RpcnAsIGlmIGl0IGZhaWxzLCBpdCBpcyBwb3NzaWJsZSB0aGF0XG4gKiBkaXJlY3RvcmllcyB3ZXJlIGNyZWF0ZWQgZm9yIHNvbWUgcHJlZml4IG9mIHRoZSBnaXZlbiBwYXRoLlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBwYXRoIHdhcyBjcmVhdGVkOyBmYWxzZSBpZiBpdCBhbHJlYWR5IGV4aXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIG1rZGlycChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIGZzUHJvbWlzZS5ta2RpcnAocGF0aCk7XG59XG5cbi8qKlxuICogSWYgbm8gZmlsZSAob3IgZGlyZWN0b3J5KSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggZXhpc3RzLCBjcmVhdGVzIHRoZSBwYXJlbnRcbiAqIGRpcmVjdG9yaWVzIChpZiBuZWNlc3NhcnkpIGFuZCB0aGVuIHdyaXRlcyBhbiBlbXB0eSBmaWxlIGF0IHRoZSBzcGVjaWZpZWRcbiAqIHBhdGguXG4gKlxuICogQHJldHVybiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmaWxlIHdhcyBjcmVhdGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBuZXdGaWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdmFyIGlzRXhpc3RpbmdGaWxlID0gYXdhaXQgZnNQcm9taXNlLmV4aXN0cyhmaWxlUGF0aCk7XG4gIGlmIChpc0V4aXN0aW5nRmlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhd2FpdCBmc1Byb21pc2UubWtkaXJwKHBhdGhVdGlsLmRpcm5hbWUoZmlsZVBhdGgpKTtcbiAgYXdhaXQgZnNQcm9taXNlLndyaXRlRmlsZShmaWxlUGF0aCwgJycpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgcmVhZGRpciBlbmRwb2ludCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgcXVlcnkgcGFyYW1ldGVyczpcbiAqXG4gKiAgIHBhdGg6IHBhdGggdG8gdGhlIGZvbGRlciB0byBsaXN0IGVudHJpZXMgaW5zaWRlLlxuICpcbiAqIEJvZHkgY29udGFpbnMgYSBKU09OIGVuY29kZWQgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGZpbGU6IGFuZCBzdGF0czogZW50cmllcy5cbiAqIGZpbGU6IGhhcyB0aGUgZmlsZSBvciBkaXJlY3RvcnkgbmFtZSwgc3RhdHM6IGhhcyB0aGUgc3RhdHMgb2YgdGhlIGZpbGUvZGlyLFxuICogaXNTeW1ib2xpY0xpbms6IHRydWUgaWYgdGhlIGVudHJ5IGlzIGEgc3ltbGluayB0byBhbm90aGVyIGZpbGVzeXN0ZW0gbG9jYXRpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRkaXIocGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxGaWxlV2l0aFN0YXRzPj4ge1xuICB2YXIgZmlsZXMgPSBhd2FpdCBmc1Byb21pc2UucmVhZGRpcihwYXRoKTtcbiAgdmFyIGVudHJpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChmaWxlcy5tYXAoYXN5bmMgKGZpbGUpID0+IHtcbiAgICB2YXIgZnVsbHBhdGggPSBwYXRoVXRpbC5qb2luKHBhdGgsIGZpbGUpO1xuICAgIHZhciBsc3RhdHMgPSBhd2FpdCBmc1Byb21pc2UubHN0YXQoZnVsbHBhdGgpO1xuICAgIGlmICghbHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIHJldHVybiB7ZmlsZSwgc3RhdHM6IGxzdGF0cywgaXNTeW1ib2xpY0xpbms6IGZhbHNlfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0YXRzID0gYXdhaXQgZnNQcm9taXNlLnN0YXQoZnVsbHBhdGgpO1xuICAgICAgICByZXR1cm4ge2ZpbGUsIHN0YXRzLCBpc1N5bWJvbGljTGluazogdHJ1ZX07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge2ZpbGUsIHN0YXRzOiB1bmRlZmluZWQsIGlzU3ltYm9saWNMaW5rOiB0cnVlLCBlcnJvcn07XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG4gIC8vIFRPRE86IFJldHVybiBlbnRyaWVzIGRpcmVjdGx5IGFuZCBjaGFuZ2UgY2xpZW50IHRvIGhhbmRsZSBlcnJvci5cbiAgcmV0dXJuIGVudHJpZXMuZmlsdGVyKChlbnRyeSkgPT4ge3JldHVybiBlbnRyeS5lcnJvciA9PT0gdW5kZWZpbmVkfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcmVhbCBwYXRoIG9mIGEgZmlsZSBwYXRoLlxuICogSXQgY291bGQgYmUgZGlmZmVyZW50IHRoYW4gdGhlIGdpdmVuIHBhdGggaWYgdGhlIGZpbGUgaXMgYSBzeW1saW5rXG4gKiBvciBleGlzdHMgaW4gYSBzeW1saW5rZWQgZGlyZWN0b3J5LlxuICovXG5mdW5jdGlvbiByZWFscGF0aChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gZnNQcm9taXNlLnJlYWxwYXRoKHBhdGgpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGVxdWl2YWxlbnQgb2YgYG12IHNvdXJjZVBhdGggZGVzdGluYXRpb25QYXRoYC5cbiAqL1xuZnVuY3Rpb24gcmVuYW1lKHNvdXJjZVBhdGg6IHN0cmluZywgZGVzdGluYXRpb25QYXRoOiBzdHJpbmcpOiBQcm9taXNlIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnNQbHVzID0gcmVxdWlyZSgnZnMtcGx1cycpO1xuICAgIGZzUGx1cy5tb3ZlKHNvdXJjZVBhdGgsIGRlc3RpbmF0aW9uUGF0aCwgZXJyb3IgPT4ge1xuICAgICAgZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGRpcmVjdG9yaWVzIGV2ZW4gaWYgdGhleSBhcmUgbm9uLWVtcHR5LiBEb2VzIG5vdCBmYWlsIGlmIHRoZSBkaXJlY3RvcnkgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gcm1kaXIocGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBmc1Byb21pc2Uucm1kaXIocGF0aCk7XG59XG5cbi8qKlxuICogVGhlIHN0YXQgZW5kcG9pbnQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHF1ZXJ5IHBhcmFtZXRlcnM6XG4gKlxuICogICBwYXRoOiBwYXRoIHRvIHRoZSBmaWxlIHRvIHJlYWQgKHRoYXQgaXMgaXQgbXVzdCBiZSBxdW90ZWQpXG4gKlxuICogSXQgcmV0dXJucyBhIEpTT04gZW5jb2RlZCBzdGF0cyBvYmplY3QgdGhhdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICpcbiAqIHsgZGV2OiAyMTE0LFxuICogIGlubzogNDgwNjQ5NjksXG4gKiAgbW9kZTogMzMxODgsXG4gKiAgbmxpbms6IDEsXG4gKiAgdWlkOiA4NSxcbiAqICBnaWQ6IDEwMCxcbiAqICByZGV2OiAwLFxuICogIHNpemU6IDUyNyxcbiAqICBibGtzaXplOiA0MDk2LFxuICogIGJsb2NrczogOCxcbiAqICBhdGltZTogJ01vbiwgMTAgT2N0IDIwMTEgMjM6MjQ6MTEgR01UJyxcbiAqICBtdGltZTogJ01vbiwgMTAgT2N0IDIwMTEgMjM6MjQ6MTEgR01UJyxcbiAqICBjdGltZTogJ01vbiwgMTAgT2N0IDIwMTEgMjM6MjQ6MTEgR01UJyxcbiAqICBiaXJ0aHRpbWU6ICdNb24sIDEwIE9jdCAyMDExIDIzOjI0OjExIEdNVCdcbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHN0YXQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxmcy5TdGF0cz4ge1xuICByZXR1cm4gZnNQcm9taXNlLnN0YXQocGF0aCk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBmaWxlcy4gRG9lcyBub3QgZmFpbCBpZiB0aGUgZmlsZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiB1bmxpbmsocGF0aDogc3RyaW5nKTogUHJvbWlzZSB7XG4gIHJldHVybiBmc1Byb21pc2UudW5saW5rKHBhdGgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gVVJMIEhhbmRsZXJzXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhlIHJlYWRGaWxlIGVuZHBvaW50IGFjY2VwdHMgdGhlIGZvbGxvd2luZyBxdWVyeSBwYXJhbWV0ZXJzOlxuICpcbiAqICAgcGF0aDogdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZCAoaXQgbXVzdCBiZSB1cmwgZW5jb2RlZClcbiAqICAgb3B0aW9uczogSlNPTiBlbmNvZGVkICsgdXJsIGVuY29kZWQgc2V0IG9mIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvXG4gKiAgICAgICAgICAgIGZzLmNyZWF0ZVJlYWRTdHJlYW0uXG4gKlxuICogSXQgcmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgYXMgYmluYXJ5IGluIHRoZSBib2R5IGFuZCBzZXRzXG4gKiBDb250ZW50LVR5cGUgdG8gYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtLlxuICpcbiAqIFRoZSByZWFkRmlsZSBmdW5jdGlvbiB0YWtlcyBhIHJlcXVlc3QgYW5kIHJlc3BvbnNlICBJdCBoYXMgbm8gcmV0dXJuIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWFkRmlsZShyZXF1ZXN0OiBJbmNvbWluZ01lc3NhZ2UsIHJlc3BvbnNlOiBTZXJ2ZXJSZXNwb25zZSwgbmV4dDogKGVycjogRXJyb3IpID0+IHZvaWQpIHtcbiAgdmFyIFtwYXRoLCBvcHRpb25zXSA9IGRlc2VyaWFsaXplQXJncyhyZXF1ZXN0LnVybCk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZmlsZVN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBmaWxlU3RyZWFtLm9uKCdvcGVuJywgKGZkKSA9PiB7XG4gICAgICByZXNwb25zZS5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgIGZpbGVTdHJlYW0ucGlwZShyZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICBmaWxlU3RyZWFtLm9uKCdlcnJvcicsIG5leHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmV4dChuZXcgRXJyb3IoYE51Y2xpZGVGcy5yZWFkRmlsZSBmb3IgcGF0aCAke3BhdGh9IGVycm9yOiAke2V9YCkpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHdyaXRlRmlsZSBlbmRwb2ludCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgcXVlcnkgcGFyYW1ldGVyczpcbiAqXG4gKiAgIHBhdGg6IHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZCAoaXQgbXVzdCBiZSB1cmwgZW5jb2RlZCkuXG4gKiAgIG9wdGlvbnM6IEpTT04gZW5jb2RlZCArIHVybCBlbmNvZGVkIHNldCBvZiBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0b1xuICogICAgICAgICAgICBmcy5jcmVhdGVXcml0ZVN0cmVhbS5cbiAqXG4gKiBJdCBleHBlY3RzIHRoZSBib2R5IG9mIHRoZSByZXF1ZXN0IHRvIGJlIHRoZSBiaW5hcnkgY29udGVudHMgeW91IHdhbnQgd3JpdHRlblxuICogdG8gdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBwYXRoIHF1ZXJ5IHBhcmFtZXRlci5cbiAqXG4gKiBUaGUgd3JpdGVGaWxlIGZ1bmN0aW9uIHRha2VzIGEgcmVxdWVzdCBhbmQgcmVzcG9uc2UuIEl0IGhhcyBubyByZXR1cm4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRmlsZShyZXF1ZXN0OiBJbmNvbWluZ01lc3NhZ2UsIHJlc3BvbnNlOiBTZXJ2ZXJSZXNwb25zZSwgbmV4dDogKGVycjogRXJyb3IpID0+IHZvaWQpIHtcbiAgdmFyIFtwYXRoLCBvcHRpb25zXSA9IGRlc2VyaWFsaXplQXJncyhyZXF1ZXN0LnVybCk7XG4gIHRlbXAub3BlbignbnVjbGlkZScsIChlcnJvciwgaW5mbykgPT4ge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgbmV4dChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuZmQgPSBpbmZvLmZkO1xuXG4gICAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuXG4gICAgLy8gV2hpbGUgd3JpdGluZyBzb21ldGhpbmcgZ29lcyB3cm9uZy5cbiAgICB2YXIgdGVtcFN0cmVhbSA9IHJlcXVlc3QucGlwZShmcy5jcmVhdGVXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKSk7XG5cbiAgICB2YXIgb25FcnJvciA9IHN0cmVhbUVycm9yID0+IHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICB0ZW1wU3RyZWFtLmVuZCgpO1xuICAgICAgbmV4dChzdHJlYW1FcnJvcik7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgdGVtcFN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgICB0ZW1wU3RyZWFtLm9uKCdjbG9zZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgLy8gVE9ETyhtaWtlbyk6IENsZWFuIHVwIHRlbXAgZmlsZSBpZiBmYWlsZWQuXG4gICAgICAgIC8vIG5leHQoc3RyZWFtRXJyb3IpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLCBzbyBub3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGZpbGUgc3RpbGwgaGFzIG9yaWdpbmFsIHBlcm1pc3Npb25zOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL251Y2xpZGUvaXNzdWVzLzE1N1xuICAgICAgLy8gV2UgdXBkYXRlIHRoZSBtb2RlIG9mIHRoZSB0ZW1wIGZpbGUgcmF0aGVyIHRoYW4gdGhlIGRlc3RpbmF0aW9uIGZpbGUgYmVjYXVzZVxuICAgICAgLy8gaWYgd2UgZGlkIHRoZSBtdigpIHRoZW4gdGhlIGNobW9kKCksIHRoZXJlIHdvdWxkIGJlIGEgYnJpZWYgcGVyaW9kIGJldHdlZW5cbiAgICAgIC8vIHRob3NlIHR3byBvcGVyYXRpb25zIHdoZXJlIHRoZSBkZXN0aW5hdGlvbiBmaWxlIG1pZ2h0IGhhdmUgdGhlIHdyb25nIHBlcm1pc3Npb25zLlxuICAgICAgdmFyIHBlcm1pc3Npb25zO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHttb2RlOiBwZXJtaXNzaW9uc30gPSBhd2FpdCBmc1Byb21pc2Uuc3RhdChwYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIHRoZW4gRU5PRU5UIHdpbGwgYmUgdGhyb3duLlxuICAgICAgICBpZiAoZS5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGVtcEZpbGVQYXRoID0gaW5mby5wYXRoO1xuICAgICAgaWYgKHBlcm1pc3Npb25zICE9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgZnNQcm9taXNlLmNobW9kKHRlbXBGaWxlUGF0aCwgcGVybWlzc2lvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPKG1pa2VvKTogcHV0IHJlbmFtZXMgaW50byBhIHF1ZXVlIHNvIHdlIGRvbid0IHdyaXRlIG9sZGVyIHNhdmUgb3ZlciBuZXcgc2F2ZS5cbiAgICAgIC8vIFVzZSBtdiBhcyBmcy5yZW5hbWUgZG9lc24ndCB3b3JrIGFjcm9zcyBwYXJ0aXRpb25zLlxuICAgICAgbXYodGVtcEZpbGVQYXRoLCBwYXRoLCB7bWtkaXJwOiBmYWxzZX0sIGFzeW5jIChyZW5hbWVFcnJvcjogP0Vycm9yKSA9PiB7XG4gICAgICAgIGlmIChyZW5hbWVFcnJvcikge1xuICAgICAgICAgIG5leHQocmVuYW1lRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXJ2aWNlczoge1xuICAgICcvZnMvZXhpc3RzJzoge2hhbmRsZXI6IGV4aXN0c30sXG4gICAgJy9mcy9maW5kTmVhcmVzdEZpbGUnOiB7aGFuZGxlcjogZmluZE5lYXJlc3RGaWxlfSxcbiAgICAnL2ZzL2xzdGF0Jzoge2hhbmRsZXI6IGxzdGF0fSxcbiAgICAnL2ZzL21rZGlyJzoge2hhbmRsZXI6IG1rZGlyLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9mcy9ta2RpcnAnOiB7aGFuZGxlcjogbWtkaXJwLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9mcy9uZXdGaWxlJzoge2hhbmRsZXI6IG5ld0ZpbGUsIG1ldGhvZDogJ3Bvc3QnfSxcbiAgICAnL2ZzL3JlYWRkaXInOiB7aGFuZGxlcjogcmVhZGRpcn0sXG4gICAgJy9mcy9yZWFscGF0aCc6IHtoYW5kbGVyOiByZWFscGF0aCwgbWV0aG9kOiAnZ2V0JywgdGV4dDogdHJ1ZX0sXG4gICAgJy9mcy9yZW5hbWUnOiB7aGFuZGxlcjogcmVuYW1lLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9mcy9ybWRpcic6IHtoYW5kbGVyOiBybWRpciwgbWV0aG9kOiAncG9zdCd9LFxuICAgICcvZnMvc3RhdCc6IHtoYW5kbGVyOiBzdGF0fSxcbiAgICAnL2ZzL3VubGluayc6IHtoYW5kbGVyOiB1bmxpbmssIG1ldGhvZDogJ3Bvc3QnfSxcbiAgfSxcbiAgdXJsSGFuZGxlcnM6IHtcbiAgICAnL2ZzL3JlYWRGaWxlJzoge2hhbmRsZXI6IHJlYWRGaWxlfSxcbiAgICAnL2ZzL3dyaXRlRmlsZSc6IHtoYW5kbGVyOiB3cml0ZUZpbGUsIG1ldGhvZDogJ3Bvc3QnfSxcbiAgfSxcbn07XG4iXX0=
