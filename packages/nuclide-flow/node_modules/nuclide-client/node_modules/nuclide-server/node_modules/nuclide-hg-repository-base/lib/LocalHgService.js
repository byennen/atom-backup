var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

'use babel';

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _require = require('nuclide-commons');

var debounce = _require.debounce;

var DelayedEventManager = require('./DelayedEventManager');
var watchman = require('fb-watchman');
var fs = require('fs');
var LocalHgServiceBase = require('./LocalHgServiceBase');
var logger = require('nuclide-logging').getLogger();

var _require2 = require('nuclide-watchman-helpers');

var getWatchmanBinaryPath = _require2.getWatchmanBinaryPath;

var path = require('path');

var WATCHMAN_SUBSCRIPTION_NAME_PRIMARY = 'hg-repository-watchman-subscription-primary';
var WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE = 'hg-repository-watchman-subscription-hgignore';
var WATCHMAN_SUBSCRIPTION_NAME_HGLOCK = 'hg-repository-watchman-subscription-hglock';
var WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE = 'hg-repository-watchman-subscription-hgdirstate';
var WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK = 'hg-repository-watchman-subscription-hgbookmark';
var WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK = 'arc-build-lock';
var EVENT_DELAY_IN_MS = 1000;

function getArcBuildLockFile() {
  var lockFile;
  try {
    lockFile = require('./fb/config').arcBuildLockFile;
  } catch (e) {
    // purposely blank
  }
  return lockFile;
}

/**
 * @return Array of additional watch expressions to apply to the primary
 *   watchman subscription.
 */
function getPrimaryWatchmanSubscriptionRefinements() {
  var refinements = [];
  try {
    refinements = require('./fb/config').primaryWatchSubscriptionRefinements;
  } catch (e) {
    // purposely blank
  }
  return refinements;
}

// To make LocalHgServiceBase more easily testable, the watchman dependency is
// broken out. We add the watchman dependency here.

var LocalHgService = (function (_LocalHgServiceBase) {
  _inherits(LocalHgService, _LocalHgServiceBase);

  function LocalHgService(options) {
    _classCallCheck(this, LocalHgService);

    _get(Object.getPrototypeOf(LocalHgService.prototype), 'constructor', this).call(this, options);
    this._delayedEventManager = new DelayedEventManager(setTimeout, clearTimeout);
    this._lockFileHeld = false;
    this._shouldUseDirstate = true;
    this._subscribeToWatchman();
  }

  _createClass(LocalHgService, [{
    key: 'destroy',
    value: function destroy() {
      this._cleanUpWatchman();
      this._delayedEventManager.dispose();
      if (this._dirstateDelayedEventManager) {
        this._dirstateDelayedEventManager.dispose();
      }
      _get(Object.getPrototypeOf(LocalHgService.prototype), 'destroy', this).call(this);
    }
  }, {
    key: '_subscribeToWatchman',
    value: _asyncToGenerator(function* () {
      var _this = this;

      this._watchmanClient = new watchman.Client({
        watchmanBinaryPath: yield getWatchmanBinaryPath()
      });
      var workingDirectory = this.getWorkingDirectory();
      this._watchmanClient.command(['watch', workingDirectory], function (watchError, watchResp) {
        if (watchError) {
          logger.error('Error initiating watchman watch: ' + watchError);
          return;
        }
        // By default, watchman will deliver a list of all current files when you
        // first subscribe. We don't want this behavior, so we issue a `clock`
        // command to give a logical time constraint on the subscription.
        // This is recommended by https://www.npmjs.com/package/fb-watchman.
        _this._watchmanClient.command(['clock', workingDirectory], function (clockError, clockResp) {
          if (clockError) {
            logger.error('Failed to query watchman clock: ', clockError);
            return;
          }

          var primarySubscriptionExpression = ['allof', ['not', ['dirname', '.hg']], ['not', ['name', '.hgignore', 'wholename']],
          // Hg appears to modify temporary files that begin with these
          // prefixes, every time a file is saved.
          // TODO (t7832809) Remove this when it is unnecessary.
          ['not', ['match', 'hg-checkexec-*', 'wholename']], ['not', ['match', 'hg-checklink-*', 'wholename']],
          // This watchman subscription is used to determine when and which
          // files to fetch new statuses for. There is no reason to include
          // directories in these updates, and in fact they may make us overfetch
          // statuses. (See diff summary of D2021498.)
          // This line restricts this subscription to only return files.
          ['type', 'f']];
          primarySubscriptionExpression = primarySubscriptionExpression.concat(getPrimaryWatchmanSubscriptionRefinements());

          // Subscribe to changes to files unrelated to source control.
          _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_PRIMARY, {
            fields: ['name', 'exists', 'new'],
            expression: primarySubscriptionExpression,
            since: clockResp.clock
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_PRIMARY + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_PRIMARY + ' established.');
          });

          // Subscribe to changes to .hgignore files.
          _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE, {
            fields: ['name'],
            expression: ['name', '.hgignore', 'wholename'],
            since: clockResp.clock
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE + ' established.');
          });

          // Subscribe to changes to the source control lock file.
          _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGLOCK, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/wlock', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGLOCK + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGLOCK + ' established.');
          });

          // Subscribe to changes to the source control directory state file.
          _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/dirstate', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE + ' established.');
          });

          // Subscribe to changes in the current Hg bookmark.
          _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK, {
            fields: ['name', 'exists'],
            expression: ['name', '.hg/bookmarks.current', 'wholename'],
            since: clockResp.clock,
            defer_vcs: false
          }], function (subscribeError, subscribeResp) {
            if (subscribeError) {
              logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK + ' with clock limit: ', subscribeError);
              return;
            }
            logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK + ' established.');
          });

          // Subscribe to changes to a file that appears to be the 'arc build' lock file.
          var arcBuildLockFile = getArcBuildLockFile();
          if (arcBuildLockFile) {
            _this._watchmanClient.command(['subscribe', workingDirectory, WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK, {
              fields: ['name', 'exists'],
              expression: ['name', arcBuildLockFile, 'wholename'],
              since: clockResp.clock
            }], function (subscribeError, subscribeResp) {
              if (subscribeError) {
                logger.error('Failed to subscribe to ' + WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK + ' with clock limit: ', subscribeError);
                return;
              }
              logger.debug('Watchman subscription ' + WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK + ' established.');
            });
          }
        });

        // Mercurial creates the .hg/wlock file before it modifies the working directory,
        // and deletes it when it's done. We want to ignore the watchman updates
        // caused by these modifications, so we do two things:
        // 1. The first level of defense is to watch for the creation and deletion of
        // the wlock and ignore events accordingly.
        // However, the watchman update for the files that have changed
        // due to the Mercurial action may arrive before the update for the wlock
        // file.
        // To work around this, we introduce an artificial delay for the watchman
        // updates for our files of interest, which allows time for a wlock watchman
        // update (if any) to arrive and cancel them.
        // This may occasionally result in a false positive: cancelling events that
        // were generated by a user action (not Mercurial) that occur shortly before
        // Mercurial modifies the working directory. But this should be fine,
        // because the client of LocalHgService should be reacting to the
        // 'onHgRepoStateDidChange' event that follows the Mercurial event.
        // 2. The wlock is surest way to detect the beginning and end of events. But
        // because it is a transient file, watchman may not pick up on it, especially
        // if the Mercurial action is quick (e.g. a commit, as opposed to a rebase).
        // In this case we fall back on watching the dirstate, which is a persistent
        // file that is written to whenever Mercurial updates the state of the working
        // directory (except reverts -- but this will also modify the state of the
        // relevant files). The dirstate gets modified in the middle of an update
        // and at the end, but not the beginning. Therefore it's a bit noisier of
        // a signal, and is prone to both false positives and negatives.
        _this._watchmanClient.on('subscription', function (update) {
          if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_PRIMARY) {
            _this._delayedEventManager.addEvent(_this._filesDidChange.bind(_this, update), EVENT_DELAY_IN_MS);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE) {
            // There are three events that may outdate the status of ignored files.
            // 1. The .hgignore file changes. In this case, we want to run a fresh 'hg status -i'.
            // 2. A file is added that meets the criteria under .hgignore. In this case, we can
            //    scope the 'hg status -i' call to just the added file.
            // 3. A file that was previously ignored, has been deleted. (A bit debatable in this
            //    case what ::isPathIgnored should return if the file doesn't exist. But let's
            //    at least keep the local cache updated.) In this case, we just want to remove
            //    the deleted file if it is in the cache.
            // Case 1 is covered by the response to WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE firing.
            // Cases 2 and 3 are covered by the response to WATCHMAN_SUBSCRIPTION_NAME_PRIMARY firing.
            _this._delayedEventManager.addEvent(_this._hgIgnoreFileDidChange.bind(_this), EVENT_DELAY_IN_MS);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGLOCK || update.subscription === WATCHMAN_SUBSCRIPTION_NAME_ARC_BUILD_LOCK) {
            var lockfile = update.files[0];
            if (lockfile.exists) {
              // TODO: Implement a timer to unset this, in case watchman update
              // fails to notify of the removal of the lock. I haven't seen this
              // in practice but it's better to be safe.
              _this._lockFileHeld = true;
              // The lock being created is a definitive start to a Mercurial action/arc build.
              // Block the effects from any dirstate change, which is a fuzzier signal.
              _this._shouldUseDirstate = false;
              _this._delayedEventManager.setCanAcceptEvents(false);
              _this._delayedEventManager.cancelAllEvents();
            } else {
              _this._lockFileHeld = false;
              _this._delayedEventManager.setCanAcceptEvents(true);
              // The lock being deleted is a definitive end to a Mercurial action/arc build.
              // Block the effects from any dirstate change, which is a fuzzier signal.
              _this._shouldUseDirstate = false;
            }
            _this._hgLockDidChange(lockfile.exists);
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE) {
            // We don't know whether the change to the dirstate is at the middle or end
            // of a Mercurial action. But we would rather have false positives (ignore
            // some user-generated events that occur near a Mercurial event) than false
            // negatives (register irrelevant Mercurial events).
            // Each time this watchman update fires, we will make the LocalHgService
            // ignore events for a certain grace period.

            // A lock file is a more reliable signal, so defer to it.
            if (_this._lockFileHeld) {
              return;
            }

            _this._shouldUseDirstate = true;
            _this._delayedEventManager.setCanAcceptEvents(false);
            _this._delayedEventManager.cancelAllEvents();
            if (!_this._allowEventsAgain) {
              _this._allowEventsAgain = debounce(function () {
                if (_this._shouldUseDirstate) {
                  _this._delayedEventManager.setCanAcceptEvents(true);
                  _this._hgDirstateDidChange();
                }
              }, EVENT_DELAY_IN_MS);
            }
            _this._allowEventsAgain();
          } else if (update.subscription === WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK) {
            _this._hgBookmarkDidChange();
          }
        });
      });
    })
  }, {
    key: '_cleanUpWatchman',
    value: function _cleanUpWatchman() {
      if (this._watchmanClient) {
        this._watchmanClient.command(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_PRIMARY]);
        this._watchmanClient.command(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGIGNORE]);
        this._watchmanClient.command(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGLOCK]);
        this._watchmanClient.command(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGDIRSTATE]);
        this._watchmanClient.command(['unsubscribe', this.getWorkingDirectory(), WATCHMAN_SUBSCRIPTION_NAME_HGBOOKMARK]);
        this._watchmanClient.end();
      }
    }

    /**
     * @param update The latest watchman update.
     */
  }, {
    key: '_filesDidChange',
    value: function _filesDidChange(update) {
      var workingDirectory = this.getWorkingDirectory();
      var changedFiles = update.files.map(function (file) {
        return path.join(workingDirectory, file.name);
      });
      this._emitter.emit('files-changed', changedFiles);
    }
  }, {
    key: '_hgIgnoreFileDidChange',
    value: function _hgIgnoreFileDidChange() {
      this._emitter.emit('hg-ignore-changed');
    }
  }, {
    key: '_hgLockDidChange',
    value: function _hgLockDidChange(lockExists) {
      if (!lockExists) {
        this._emitHgRepoStateChanged();
      }
    }
  }, {
    key: '_hgDirstateDidChange',
    value: function _hgDirstateDidChange() {
      this._emitHgRepoStateChanged();
    }
  }, {
    key: '_emitHgRepoStateChanged',
    value: function _emitHgRepoStateChanged() {
      // Currently there is no use case for alerting clients of the beginning of
      // the state change, so this event only alerts them of the end.
      this._emitter.emit('hg-repo-state-changed');
    }
  }, {
    key: '_hgBookmarkDidChange',
    value: function _hgBookmarkDidChange() {
      this._emitter.emit('hg-bookmark-changed');
    }
  }]);

  return LocalHgService;
})(LocalHgServiceBase);

module.exports = LocalHgService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWhnLXJlcG9zaXRvcnktYmFzZS9saWIvTG9jYWxIZ1NlcnZpY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7OztlQVdLLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQzs7SUFBdEMsUUFBUSxZQUFSLFFBQVE7O0FBQ2IsSUFBSSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUMzRCxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUksa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDekQsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7O2dCQUN0QixPQUFPLENBQUMsMEJBQTBCLENBQUM7O0lBQTVELHFCQUFxQixhQUFyQixxQkFBcUI7O0FBQzFCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFM0IsSUFBSSxrQ0FBa0MsR0FBRyw2Q0FBNkMsQ0FBQztBQUN2RixJQUFJLG1DQUFtQyxHQUFHLDhDQUE4QyxDQUFDO0FBQ3pGLElBQUksaUNBQWlDLEdBQUcsNENBQTRDLENBQUM7QUFDckYsSUFBSSxxQ0FBcUMsR0FBRyxnREFBZ0QsQ0FBQztBQUM3RixJQUFJLHFDQUFxQyxHQUFHLGdEQUFnRCxDQUFDO0FBQzdGLElBQUkseUNBQXlDLEdBQUcsZ0JBQWdCLENBQUM7QUFDakUsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUM7O0FBSTdCLFNBQVMsbUJBQW1CLEdBQVk7QUFDdEMsTUFBSSxR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S0FDRjs7Ozs7OztXQUtjLHlCQUFDLE1BQVcsRUFBaUI7QUFDMUMsVUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztBQUNsRCxVQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUk7ZUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxJQUFJLENBQUM7T0FBQSxDQUFDLENBQUM7QUFDcEYsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQ25EOzs7V0FFcUIsa0NBQWtCO0FBQ3RDLFVBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDekM7OztXQUVlLDBCQUFDLFVBQW1CLEVBQVE7QUFDMUMsVUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNmLFlBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO09BQ2hDO0tBQ0Y7OztXQUVtQixnQ0FBUztBQUMzQixVQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztLQUNoQzs7O1dBRXNCLG1DQUFHOzs7QUFHeEIsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQztLQUM3Qzs7O1dBRW1CLGdDQUFTO0FBQzNCLFVBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7S0FDM0M7OztTQTNVRyxjQUFjO0dBQVMsa0JBQWtCOztBQWdWL0MsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtaGctcmVwb3NpdG9yeS1iYXNlL2xpYi9Mb2NhbEhnU2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciB7ZGVib3VuY2V9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG52YXIgRGVsYXllZEV2ZW50TWFuYWdlciA9IHJlcXVpcmUoJy4vRGVsYXllZEV2ZW50TWFuYWdlcicpO1xudmFyIHdhdGNobWFuID0gcmVxdWlyZSgnZmItd2F0Y2htYW4nKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgTG9jYWxIZ1NlcnZpY2VCYXNlID0gcmVxdWlyZSgnLi9Mb2NhbEhnU2VydmljZUJhc2UnKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcbnZhciB7Z2V0V2F0Y2htYW5CaW5hcnlQYXRofSA9IHJlcXVpcmUoJ251Y2xpZGUtd2F0Y2htYW4taGVscGVycycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZID0gJ2hnLXJlcG9zaXRvcnktd2F0Y2htYW4tc3Vic2NyaXB0aW9uLXByaW1hcnknO1xudmFyIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHSUdOT1JFID0gJ2hnLXJlcG9zaXRvcnktd2F0Y2htYW4tc3Vic2NyaXB0aW9uLWhnaWdub3JlJztcbnZhciBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0xPQ0sgPSAnaGctcmVwb3NpdG9yeS13YXRjaG1hbi1zdWJzY3JpcHRpb24taGdsb2NrJztcbnZhciBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFID0gJ2hnLXJlcG9zaXRvcnktd2F0Y2htYW4tc3Vic2NyaXB0aW9uLWhnZGlyc3RhdGUnO1xudmFyIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHQk9PS01BUksgPSAnaGctcmVwb3NpdG9yeS13YXRjaG1hbi1zdWJzY3JpcHRpb24taGdib29rbWFyayc7XG52YXIgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfQVJDX0JVSUxEX0xPQ0sgPSAnYXJjLWJ1aWxkLWxvY2snO1xudmFyIEVWRU5UX0RFTEFZX0lOX01TID0gMTAwMDtcblxuaW1wb3J0IHR5cGUgTG9jYWxIZ1NlcnZpY2VPcHRpb25zIGZyb20gJy4vaGctdHlwZXMnO1xuXG5mdW5jdGlvbiBnZXRBcmNCdWlsZExvY2tGaWxlKCk6ID9zdHJpbmcge1xuICB2YXIgbG9ja0ZpbGU7XG4gIHRyeSB7XG4gICAgbG9ja0ZpbGUgPSByZXF1aXJlKCcuL2ZiL2NvbmZpZycpLmFyY0J1aWxkTG9ja0ZpbGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwdXJwb3NlbHkgYmxhbmtcbiAgfVxuICByZXR1cm4gbG9ja0ZpbGU7XG59XG5cbi8qKlxuICogQHJldHVybiBBcnJheSBvZiBhZGRpdGlvbmFsIHdhdGNoIGV4cHJlc3Npb25zIHRvIGFwcGx5IHRvIHRoZSBwcmltYXJ5XG4gKiAgIHdhdGNobWFuIHN1YnNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJpbWFyeVdhdGNobWFuU3Vic2NyaXB0aW9uUmVmaW5lbWVudHMoKTogQXJyYXk8bWl4ZWQ+IHtcbiAgdmFyIHJlZmluZW1lbnRzID0gW107XG4gIHRyeSB7XG4gICAgcmVmaW5lbWVudHMgPSByZXF1aXJlKCcuL2ZiL2NvbmZpZycpLnByaW1hcnlXYXRjaFN1YnNjcmlwdGlvblJlZmluZW1lbnRzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcHVycG9zZWx5IGJsYW5rXG4gIH1cbiAgcmV0dXJuIHJlZmluZW1lbnRzO1xufVxuXG4vLyBUbyBtYWtlIExvY2FsSGdTZXJ2aWNlQmFzZSBtb3JlIGVhc2lseSB0ZXN0YWJsZSwgdGhlIHdhdGNobWFuIGRlcGVuZGVuY3kgaXNcbi8vIGJyb2tlbiBvdXQuIFdlIGFkZCB0aGUgd2F0Y2htYW4gZGVwZW5kZW5jeSBoZXJlLlxuY2xhc3MgTG9jYWxIZ1NlcnZpY2UgZXh0ZW5kcyBMb2NhbEhnU2VydmljZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBMb2NhbEhnU2VydmljZU9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyID0gbmV3IERlbGF5ZWRFdmVudE1hbmFnZXIoc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0KTtcbiAgICB0aGlzLl9sb2NrRmlsZUhlbGQgPSBmYWxzZTtcbiAgICB0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9XYXRjaG1hbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGVhblVwV2F0Y2htYW4oKTtcbiAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5fZGlyc3RhdGVEZWxheWVkRXZlbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9kaXJzdGF0ZURlbGF5ZWRFdmVudE1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBhc3luYyBfc3Vic2NyaWJlVG9XYXRjaG1hbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLl93YXRjaG1hbkNsaWVudCA9IG5ldyB3YXRjaG1hbi5DbGllbnQoe1xuICAgICAgd2F0Y2htYW5CaW5hcnlQYXRoOiBhd2FpdCBnZXRXYXRjaG1hbkJpbmFyeVBhdGgoKSxcbiAgICB9KTtcbiAgICB2YXIgd29ya2luZ0RpcmVjdG9yeSA9IHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpO1xuICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoWyd3YXRjaCcsIHdvcmtpbmdEaXJlY3RvcnldLCAod2F0Y2hFcnJvciwgd2F0Y2hSZXNwKSA9PiB7XG4gICAgICBpZiAod2F0Y2hFcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluaXRpYXRpbmcgd2F0Y2htYW4gd2F0Y2g6ICcgKyB3YXRjaEVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQnkgZGVmYXVsdCwgd2F0Y2htYW4gd2lsbCBkZWxpdmVyIGEgbGlzdCBvZiBhbGwgY3VycmVudCBmaWxlcyB3aGVuIHlvdVxuICAgICAgLy8gZmlyc3Qgc3Vic2NyaWJlLiBXZSBkb24ndCB3YW50IHRoaXMgYmVoYXZpb3IsIHNvIHdlIGlzc3VlIGEgYGNsb2NrYFxuICAgICAgLy8gY29tbWFuZCB0byBnaXZlIGEgbG9naWNhbCB0aW1lIGNvbnN0cmFpbnQgb24gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgIC8vIFRoaXMgaXMgcmVjb21tZW5kZWQgYnkgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmItd2F0Y2htYW4uXG4gICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFsnY2xvY2snLCB3b3JraW5nRGlyZWN0b3J5XSwgKGNsb2NrRXJyb3IsIGNsb2NrUmVzcCkgPT4ge1xuICAgICAgICBpZiAoY2xvY2tFcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHF1ZXJ5IHdhdGNobWFuIGNsb2NrOiAnLCBjbG9ja0Vycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJpbWFyeVN1YnNjcmlwdGlvbkV4cHJlc3Npb24gPSBbJ2FsbG9mJyxcbiAgICAgICAgICBbJ25vdCcsIFsnZGlybmFtZScsICcuaGcnXV0sXG4gICAgICAgICAgWydub3QnLCBbJ25hbWUnLCAnLmhnaWdub3JlJywgJ3dob2xlbmFtZSddXSxcbiAgICAgICAgICAvLyBIZyBhcHBlYXJzIHRvIG1vZGlmeSB0ZW1wb3JhcnkgZmlsZXMgdGhhdCBiZWdpbiB3aXRoIHRoZXNlXG4gICAgICAgICAgLy8gcHJlZml4ZXMsIGV2ZXJ5IHRpbWUgYSBmaWxlIGlzIHNhdmVkLlxuICAgICAgICAgIC8vIFRPRE8gKHQ3ODMyODA5KSBSZW1vdmUgdGhpcyB3aGVuIGl0IGlzIHVubmVjZXNzYXJ5LlxuICAgICAgICAgIFsnbm90JywgWydtYXRjaCcsICdoZy1jaGVja2V4ZWMtKicsICd3aG9sZW5hbWUnXV0sXG4gICAgICAgICAgWydub3QnLCBbJ21hdGNoJywgJ2hnLWNoZWNrbGluay0qJywgJ3dob2xlbmFtZSddXSxcbiAgICAgICAgICAvLyBUaGlzIHdhdGNobWFuIHN1YnNjcmlwdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVuIGFuZCB3aGljaFxuICAgICAgICAgIC8vIGZpbGVzIHRvIGZldGNoIG5ldyBzdGF0dXNlcyBmb3IuIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBpbmNsdWRlXG4gICAgICAgICAgLy8gZGlyZWN0b3JpZXMgaW4gdGhlc2UgdXBkYXRlcywgYW5kIGluIGZhY3QgdGhleSBtYXkgbWFrZSB1cyBvdmVyZmV0Y2hcbiAgICAgICAgICAvLyBzdGF0dXNlcy4gKFNlZSBkaWZmIHN1bW1hcnkgb2YgRDIwMjE0OTguKVxuICAgICAgICAgIC8vIFRoaXMgbGluZSByZXN0cmljdHMgdGhpcyBzdWJzY3JpcHRpb24gdG8gb25seSByZXR1cm4gZmlsZXMuXG4gICAgICAgICAgWyd0eXBlJywgJ2YnXSxcbiAgICAgICAgXTtcbiAgICAgICAgcHJpbWFyeVN1YnNjcmlwdGlvbkV4cHJlc3Npb24gPSBwcmltYXJ5U3Vic2NyaXB0aW9uRXhwcmVzc2lvbi5jb25jYXQoZ2V0UHJpbWFyeVdhdGNobWFuU3Vic2NyaXB0aW9uUmVmaW5lbWVudHMoKSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gZmlsZXMgdW5yZWxhdGVkIHRvIHNvdXJjZSBjb250cm9sLlxuICAgICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX1BSSU1BUlksXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnLCAnZXhpc3RzJywgJ25ldyddLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcHJpbWFyeVN1YnNjcmlwdGlvbkV4cHJlc3Npb24sXG4gICAgICAgICAgICBzaW5jZTogY2xvY2tSZXNwLmNsb2NrLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sIChzdWJzY3JpYmVFcnJvciwgc3Vic2NyaWJlUmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN1YnNjcmliZSB0byAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX1BSSU1BUll9IHdpdGggY2xvY2sgbGltaXQ6IGAsXG4gICAgICAgICAgICAgIHN1YnNjcmliZUVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFdhdGNobWFuIHN1YnNjcmlwdGlvbiAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX1BSSU1BUll9IGVzdGFibGlzaGVkLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyB0byAuaGdpZ25vcmUgZmlsZXMuXG4gICAgICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoW1xuICAgICAgICAgICdzdWJzY3JpYmUnLFxuICAgICAgICAgIHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdJR05PUkUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFsnbmFtZScsICcuaGdpZ25vcmUnLCAnd2hvbGVuYW1lJ10sXG4gICAgICAgICAgICBzaW5jZTogY2xvY2tSZXNwLmNsb2NrLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sIChzdWJzY3JpYmVFcnJvciwgc3Vic2NyaWJlUmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN1YnNjcmliZSB0byAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHSUdOT1JFfSB3aXRoIGNsb2NrIGxpbWl0OiBgLFxuICAgICAgICAgICAgICBzdWJzY3JpYmVFcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBXYXRjaG1hbiBzdWJzY3JpcHRpb24gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0lHTk9SRX0gZXN0YWJsaXNoZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIHRoZSBzb3VyY2UgY29udHJvbCBsb2NrIGZpbGUuXG4gICAgICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoW1xuICAgICAgICAgICdzdWJzY3JpYmUnLFxuICAgICAgICAgIHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdMT0NLLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkczogWyduYW1lJywgJ2V4aXN0cyddLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogWyduYW1lJywgJy5oZy93bG9jaycsICd3aG9sZW5hbWUnXSxcbiAgICAgICAgICAgIHNpbmNlOiBjbG9ja1Jlc3AuY2xvY2ssXG4gICAgICAgICAgICBkZWZlcl92Y3M6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sIChzdWJzY3JpYmVFcnJvciwgc3Vic2NyaWJlUmVzcCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHN1YnNjcmliZSB0byAke1dBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHTE9DS30gd2l0aCBjbG9jayBsaW1pdDogYCxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV2F0Y2htYW4gc3Vic2NyaXB0aW9uICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdMT0NLfSBlc3RhYmxpc2hlZC5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIHNvdXJjZSBjb250cm9sIGRpcmVjdG9yeSBzdGF0ZSBmaWxlLlxuICAgICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHRElSU1RBVEUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnLCAnZXhpc3RzJ10sXG4gICAgICAgICAgICBleHByZXNzaW9uOiBbJ25hbWUnLCAnLmhnL2RpcnN0YXRlJywgJ3dob2xlbmFtZSddLFxuICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICAgIGRlZmVyX3ZjczogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSwgKHN1YnNjcmliZUVycm9yLCBzdWJzY3JpYmVSZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdESVJTVEFURX0gd2l0aCBjbG9jayBsaW1pdDogYCxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV2F0Y2htYW4gc3Vic2NyaXB0aW9uICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdESVJTVEFURX0gZXN0YWJsaXNoZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBjdXJyZW50IEhnIGJvb2ttYXJrLlxuICAgICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFtcbiAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICAgIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHQk9PS01BUkssXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnLCAnZXhpc3RzJ10sXG4gICAgICAgICAgICBleHByZXNzaW9uOiBbJ25hbWUnLCAnLmhnL2Jvb2ttYXJrcy5jdXJyZW50JywgJ3dob2xlbmFtZSddLFxuICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICAgIGRlZmVyX3ZjczogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSwgKHN1YnNjcmliZUVycm9yLCBzdWJzY3JpYmVSZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdCT09LTUFSS30gd2l0aCBjbG9jayBsaW1pdDogYCxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV2F0Y2htYW4gc3Vic2NyaXB0aW9uICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdCT09LTUFSS30gZXN0YWJsaXNoZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIHRvIGEgZmlsZSB0aGF0IGFwcGVhcnMgdG8gYmUgdGhlICdhcmMgYnVpbGQnIGxvY2sgZmlsZS5cbiAgICAgICAgdmFyIGFyY0J1aWxkTG9ja0ZpbGUgPSBnZXRBcmNCdWlsZExvY2tGaWxlKCk7XG4gICAgICAgIGlmIChhcmNCdWlsZExvY2tGaWxlKSB7XG4gICAgICAgICAgdGhpcy5fd2F0Y2htYW5DbGllbnQuY29tbWFuZChbXG4gICAgICAgICAgICAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHdvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgICBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9BUkNfQlVJTERfTE9DSyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZmllbGRzOiBbJ25hbWUnLCAnZXhpc3RzJ10sXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFsnbmFtZScsIGFyY0J1aWxkTG9ja0ZpbGUsICd3aG9sZW5hbWUnXSxcbiAgICAgICAgICAgICAgc2luY2U6IGNsb2NrUmVzcC5jbG9jayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSwgKHN1YnNjcmliZUVycm9yLCBzdWJzY3JpYmVSZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlRXJyb3IpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gc3Vic2NyaWJlIHRvICR7V0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfQVJDX0JVSUxEX0xPQ0t9IHdpdGggY2xvY2sgbGltaXQ6IGAsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3JcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBXYXRjaG1hbiBzdWJzY3JpcHRpb24gJHtXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9BUkNfQlVJTERfTE9DS30gZXN0YWJsaXNoZWQuYCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBNZXJjdXJpYWwgY3JlYXRlcyB0aGUgLmhnL3dsb2NrIGZpbGUgYmVmb3JlIGl0IG1vZGlmaWVzIHRoZSB3b3JraW5nIGRpcmVjdG9yeSxcbiAgICAgIC8vIGFuZCBkZWxldGVzIGl0IHdoZW4gaXQncyBkb25lLiBXZSB3YW50IHRvIGlnbm9yZSB0aGUgd2F0Y2htYW4gdXBkYXRlc1xuICAgICAgLy8gY2F1c2VkIGJ5IHRoZXNlIG1vZGlmaWNhdGlvbnMsIHNvIHdlIGRvIHR3byB0aGluZ3M6XG4gICAgICAvLyAxLiBUaGUgZmlyc3QgbGV2ZWwgb2YgZGVmZW5zZSBpcyB0byB3YXRjaCBmb3IgdGhlIGNyZWF0aW9uIGFuZCBkZWxldGlvbiBvZlxuICAgICAgLy8gdGhlIHdsb2NrIGFuZCBpZ25vcmUgZXZlbnRzIGFjY29yZGluZ2x5LlxuICAgICAgLy8gSG93ZXZlciwgdGhlIHdhdGNobWFuIHVwZGF0ZSBmb3IgdGhlIGZpbGVzIHRoYXQgaGF2ZSBjaGFuZ2VkXG4gICAgICAvLyBkdWUgdG8gdGhlIE1lcmN1cmlhbCBhY3Rpb24gbWF5IGFycml2ZSBiZWZvcmUgdGhlIHVwZGF0ZSBmb3IgdGhlIHdsb2NrXG4gICAgICAvLyBmaWxlLlxuICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2UgaW50cm9kdWNlIGFuIGFydGlmaWNpYWwgZGVsYXkgZm9yIHRoZSB3YXRjaG1hblxuICAgICAgLy8gdXBkYXRlcyBmb3Igb3VyIGZpbGVzIG9mIGludGVyZXN0LCB3aGljaCBhbGxvd3MgdGltZSBmb3IgYSB3bG9jayB3YXRjaG1hblxuICAgICAgLy8gdXBkYXRlIChpZiBhbnkpIHRvIGFycml2ZSBhbmQgY2FuY2VsIHRoZW0uXG4gICAgICAvLyBUaGlzIG1heSBvY2Nhc2lvbmFsbHkgcmVzdWx0IGluIGEgZmFsc2UgcG9zaXRpdmU6IGNhbmNlbGxpbmcgZXZlbnRzIHRoYXRcbiAgICAgIC8vIHdlcmUgZ2VuZXJhdGVkIGJ5IGEgdXNlciBhY3Rpb24gKG5vdCBNZXJjdXJpYWwpIHRoYXQgb2NjdXIgc2hvcnRseSBiZWZvcmVcbiAgICAgIC8vIE1lcmN1cmlhbCBtb2RpZmllcyB0aGUgd29ya2luZyBkaXJlY3RvcnkuIEJ1dCB0aGlzIHNob3VsZCBiZSBmaW5lLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgY2xpZW50IG9mIExvY2FsSGdTZXJ2aWNlIHNob3VsZCBiZSByZWFjdGluZyB0byB0aGVcbiAgICAgIC8vICdvbkhnUmVwb1N0YXRlRGlkQ2hhbmdlJyBldmVudCB0aGF0IGZvbGxvd3MgdGhlIE1lcmN1cmlhbCBldmVudC5cbiAgICAgIC8vIDIuIFRoZSB3bG9jayBpcyBzdXJlc3Qgd2F5IHRvIGRldGVjdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgZXZlbnRzLiBCdXRcbiAgICAgIC8vIGJlY2F1c2UgaXQgaXMgYSB0cmFuc2llbnQgZmlsZSwgd2F0Y2htYW4gbWF5IG5vdCBwaWNrIHVwIG9uIGl0LCBlc3BlY2lhbGx5XG4gICAgICAvLyBpZiB0aGUgTWVyY3VyaWFsIGFjdGlvbiBpcyBxdWljayAoZS5nLiBhIGNvbW1pdCwgYXMgb3Bwb3NlZCB0byBhIHJlYmFzZSkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgZmFsbCBiYWNrIG9uIHdhdGNoaW5nIHRoZSBkaXJzdGF0ZSwgd2hpY2ggaXMgYSBwZXJzaXN0ZW50XG4gICAgICAvLyBmaWxlIHRoYXQgaXMgd3JpdHRlbiB0byB3aGVuZXZlciBNZXJjdXJpYWwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIHdvcmtpbmdcbiAgICAgIC8vIGRpcmVjdG9yeSAoZXhjZXB0IHJldmVydHMgLS0gYnV0IHRoaXMgd2lsbCBhbHNvIG1vZGlmeSB0aGUgc3RhdGUgb2YgdGhlXG4gICAgICAvLyByZWxldmFudCBmaWxlcykuIFRoZSBkaXJzdGF0ZSBnZXRzIG1vZGlmaWVkIGluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlXG4gICAgICAvLyBhbmQgYXQgdGhlIGVuZCwgYnV0IG5vdCB0aGUgYmVnaW5uaW5nLiBUaGVyZWZvcmUgaXQncyBhIGJpdCBub2lzaWVyIG9mXG4gICAgICAvLyBhIHNpZ25hbCwgYW5kIGlzIHByb25lIHRvIGJvdGggZmFsc2UgcG9zaXRpdmVzIGFuZCBuZWdhdGl2ZXMuXG4gICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5vbignc3Vic2NyaXB0aW9uJywgKHVwZGF0ZSkgPT4ge1xuICAgICAgICBpZiAodXBkYXRlLnN1YnNjcmlwdGlvbiA9PT0gV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfUFJJTUFSWSkge1xuICAgICAgICAgIHRoaXMuX2RlbGF5ZWRFdmVudE1hbmFnZXIuYWRkRXZlbnQoXG4gICAgICAgICAgICB0aGlzLl9maWxlc0RpZENoYW5nZS5iaW5kKHRoaXMsIHVwZGF0ZSksXG4gICAgICAgICAgICBFVkVOVF9ERUxBWV9JTl9NU1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmlwdGlvbiA9PT0gV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdJR05PUkUpIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgdGhyZWUgZXZlbnRzIHRoYXQgbWF5IG91dGRhdGUgdGhlIHN0YXR1cyBvZiBpZ25vcmVkIGZpbGVzLlxuICAgICAgICAgIC8vIDEuIFRoZSAuaGdpZ25vcmUgZmlsZSBjaGFuZ2VzLiBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gcnVuIGEgZnJlc2ggJ2hnIHN0YXR1cyAtaScuXG4gICAgICAgICAgLy8gMi4gQSBmaWxlIGlzIGFkZGVkIHRoYXQgbWVldHMgdGhlIGNyaXRlcmlhIHVuZGVyIC5oZ2lnbm9yZS4gSW4gdGhpcyBjYXNlLCB3ZSBjYW5cbiAgICAgICAgICAvLyAgICBzY29wZSB0aGUgJ2hnIHN0YXR1cyAtaScgY2FsbCB0byBqdXN0IHRoZSBhZGRlZCBmaWxlLlxuICAgICAgICAgIC8vIDMuIEEgZmlsZSB0aGF0IHdhcyBwcmV2aW91c2x5IGlnbm9yZWQsIGhhcyBiZWVuIGRlbGV0ZWQuIChBIGJpdCBkZWJhdGFibGUgaW4gdGhpc1xuICAgICAgICAgIC8vICAgIGNhc2Ugd2hhdCA6OmlzUGF0aElnbm9yZWQgc2hvdWxkIHJldHVybiBpZiB0aGUgZmlsZSBkb2Vzbid0IGV4aXN0LiBCdXQgbGV0J3NcbiAgICAgICAgICAvLyAgICBhdCBsZWFzdCBrZWVwIHRoZSBsb2NhbCBjYWNoZSB1cGRhdGVkLikgSW4gdGhpcyBjYXNlLCB3ZSBqdXN0IHdhbnQgdG8gcmVtb3ZlXG4gICAgICAgICAgLy8gICAgdGhlIGRlbGV0ZWQgZmlsZSBpZiBpdCBpcyBpbiB0aGUgY2FjaGUuXG4gICAgICAgICAgLy8gQ2FzZSAxIGlzIGNvdmVyZWQgYnkgdGhlIHJlc3BvbnNlIHRvIFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHSUdOT1JFIGZpcmluZy5cbiAgICAgICAgICAvLyBDYXNlcyAyIGFuZCAzIGFyZSBjb3ZlcmVkIGJ5IHRoZSByZXNwb25zZSB0byBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZIGZpcmluZy5cbiAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLmFkZEV2ZW50KFxuICAgICAgICAgICAgdGhpcy5faGdJZ25vcmVGaWxlRGlkQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBFVkVOVF9ERUxBWV9JTl9NU1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmlwdGlvbiA9PT0gV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdMT0NLIHx8XG4gICAgICAgICAgICAgICAgICAgdXBkYXRlLnN1YnNjcmlwdGlvbiA9PT0gV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfQVJDX0JVSUxEX0xPQ0spIHtcbiAgICAgICAgICB2YXIgbG9ja2ZpbGUgPSB1cGRhdGUuZmlsZXNbMF07XG4gICAgICAgICAgaWYgKGxvY2tmaWxlLmV4aXN0cykge1xuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGEgdGltZXIgdG8gdW5zZXQgdGhpcywgaW4gY2FzZSB3YXRjaG1hbiB1cGRhdGVcbiAgICAgICAgICAgIC8vIGZhaWxzIHRvIG5vdGlmeSBvZiB0aGUgcmVtb3ZhbCBvZiB0aGUgbG9jay4gSSBoYXZlbid0IHNlZW4gdGhpc1xuICAgICAgICAgICAgLy8gaW4gcHJhY3RpY2UgYnV0IGl0J3MgYmV0dGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICB0aGlzLl9sb2NrRmlsZUhlbGQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVGhlIGxvY2sgYmVpbmcgY3JlYXRlZCBpcyBhIGRlZmluaXRpdmUgc3RhcnQgdG8gYSBNZXJjdXJpYWwgYWN0aW9uL2FyYyBidWlsZC5cbiAgICAgICAgICAgIC8vIEJsb2NrIHRoZSBlZmZlY3RzIGZyb20gYW55IGRpcnN0YXRlIGNoYW5nZSwgd2hpY2ggaXMgYSBmdXp6aWVyIHNpZ25hbC5cbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFVzZURpcnN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLnNldENhbkFjY2VwdEV2ZW50cyhmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9kZWxheWVkRXZlbnRNYW5hZ2VyLmNhbmNlbEFsbEV2ZW50cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrRmlsZUhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRFdmVudE1hbmFnZXIuc2V0Q2FuQWNjZXB0RXZlbnRzKHRydWUpO1xuICAgICAgICAgICAgLy8gVGhlIGxvY2sgYmVpbmcgZGVsZXRlZCBpcyBhIGRlZmluaXRpdmUgZW5kIHRvIGEgTWVyY3VyaWFsIGFjdGlvbi9hcmMgYnVpbGQuXG4gICAgICAgICAgICAvLyBCbG9jayB0aGUgZWZmZWN0cyBmcm9tIGFueSBkaXJzdGF0ZSBjaGFuZ2UsIHdoaWNoIGlzIGEgZnV6emllciBzaWduYWwuXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9oZ0xvY2tEaWRDaGFuZ2UobG9ja2ZpbGUuZXhpc3RzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUuc3Vic2NyaXB0aW9uID09PSBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZSBjaGFuZ2UgdG8gdGhlIGRpcnN0YXRlIGlzIGF0IHRoZSBtaWRkbGUgb3IgZW5kXG4gICAgICAgICAgLy8gb2YgYSBNZXJjdXJpYWwgYWN0aW9uLiBCdXQgd2Ugd291bGQgcmF0aGVyIGhhdmUgZmFsc2UgcG9zaXRpdmVzIChpZ25vcmVcbiAgICAgICAgICAvLyBzb21lIHVzZXItZ2VuZXJhdGVkIGV2ZW50cyB0aGF0IG9jY3VyIG5lYXIgYSBNZXJjdXJpYWwgZXZlbnQpIHRoYW4gZmFsc2VcbiAgICAgICAgICAvLyBuZWdhdGl2ZXMgKHJlZ2lzdGVyIGlycmVsZXZhbnQgTWVyY3VyaWFsIGV2ZW50cykuXG4gICAgICAgICAgLy8gRWFjaCB0aW1lIHRoaXMgd2F0Y2htYW4gdXBkYXRlIGZpcmVzLCB3ZSB3aWxsIG1ha2UgdGhlIExvY2FsSGdTZXJ2aWNlXG4gICAgICAgICAgLy8gaWdub3JlIGV2ZW50cyBmb3IgYSBjZXJ0YWluIGdyYWNlIHBlcmlvZC5cblxuICAgICAgICAgIC8vIEEgbG9jayBmaWxlIGlzIGEgbW9yZSByZWxpYWJsZSBzaWduYWwsIHNvIGRlZmVyIHRvIGl0LlxuICAgICAgICAgIGlmICh0aGlzLl9sb2NrRmlsZUhlbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlci5zZXRDYW5BY2NlcHRFdmVudHMoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX2RlbGF5ZWRFdmVudE1hbmFnZXIuY2FuY2VsQWxsRXZlbnRzKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbGxvd0V2ZW50c0FnYWluKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxvd0V2ZW50c0FnYWluID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRVc2VEaXJzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsYXllZEV2ZW50TWFuYWdlci5zZXRDYW5BY2NlcHRFdmVudHModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9oZ0RpcnN0YXRlRGlkQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBFVkVOVF9ERUxBWV9JTl9NU1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYWxsb3dFdmVudHNBZ2FpbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpcHRpb24gPT09IFdBVENITUFOX1NVQlNDUklQVElPTl9OQU1FX0hHQk9PS01BUkspIHtcbiAgICAgICAgICB0aGlzLl9oZ0Jvb2ttYXJrRGlkQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2NsZWFuVXBXYXRjaG1hbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fd2F0Y2htYW5DbGllbnQpIHtcbiAgICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9QUklNQVJZXSk7XG4gICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFsndW5zdWJzY3JpYmUnLCB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKSwgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdJR05PUkVdKTtcbiAgICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0xPQ0tdKTtcbiAgICAgIHRoaXMuX3dhdGNobWFuQ2xpZW50LmNvbW1hbmQoWyd1bnN1YnNjcmliZScsIHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpLCBXQVRDSE1BTl9TVUJTQ1JJUFRJT05fTkFNRV9IR0RJUlNUQVRFXSk7XG4gICAgICB0aGlzLl93YXRjaG1hbkNsaWVudC5jb21tYW5kKFsndW5zdWJzY3JpYmUnLCB0aGlzLmdldFdvcmtpbmdEaXJlY3RvcnkoKSwgV0FUQ0hNQU5fU1VCU0NSSVBUSU9OX05BTUVfSEdCT09LTUFSS10pO1xuICAgICAgdGhpcy5fd2F0Y2htYW5DbGllbnQuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB1cGRhdGUgVGhlIGxhdGVzdCB3YXRjaG1hbiB1cGRhdGUuXG4gICAqL1xuICBfZmlsZXNEaWRDaGFuZ2UodXBkYXRlOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB2YXIgd29ya2luZ0RpcmVjdG9yeSA9IHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpO1xuICAgIHZhciBjaGFuZ2VkRmlsZXMgPSB1cGRhdGUuZmlsZXMubWFwKGZpbGUgPT4gcGF0aC5qb2luKHdvcmtpbmdEaXJlY3RvcnksIGZpbGUubmFtZSkpO1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnZmlsZXMtY2hhbmdlZCcsIGNoYW5nZWRGaWxlcyk7XG4gIH1cblxuICBfaGdJZ25vcmVGaWxlRGlkQ2hhbmdlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnaGctaWdub3JlLWNoYW5nZWQnKTtcbiAgfVxuXG4gIF9oZ0xvY2tEaWRDaGFuZ2UobG9ja0V4aXN0czogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghbG9ja0V4aXN0cykge1xuICAgICAgdGhpcy5fZW1pdEhnUmVwb1N0YXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIF9oZ0RpcnN0YXRlRGlkQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMuX2VtaXRIZ1JlcG9TdGF0ZUNoYW5nZWQoKTtcbiAgfVxuXG4gIF9lbWl0SGdSZXBvU3RhdGVDaGFuZ2VkKCkge1xuICAgIC8vIEN1cnJlbnRseSB0aGVyZSBpcyBubyB1c2UgY2FzZSBmb3IgYWxlcnRpbmcgY2xpZW50cyBvZiB0aGUgYmVnaW5uaW5nIG9mXG4gICAgLy8gdGhlIHN0YXRlIGNoYW5nZSwgc28gdGhpcyBldmVudCBvbmx5IGFsZXJ0cyB0aGVtIG9mIHRoZSBlbmQuXG4gICAgdGhpcy5fZW1pdHRlci5lbWl0KCdoZy1yZXBvLXN0YXRlLWNoYW5nZWQnKTtcbiAgfVxuXG4gIF9oZ0Jvb2ttYXJrRGlkQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdCgnaGctYm9va21hcmstY2hhbmdlZCcpO1xuICB9XG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsSGdTZXJ2aWNlO1xuIl19
