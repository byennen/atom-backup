
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var babel = require('babel-core');
var createRemoteServiceTransformer = require('./remote-service-transformer');
var fs = require('fs');
var mkdirp = require('mkdirp');
var path = require('path');
var parseServiceApiSync = require('./service-parser');

var TRANSPILED_FILE_FOLDER = path.join(__dirname, '../gen/');
var BABEL_HEADER = "'use babel';";

var transpiledFilePaths = new Set();

function transpile(sourceFilePath, destFilePath) {
  var sourceCode = fs.readFileSync(sourceFilePath, 'utf8');

  // While transpiling Flow import, babel might insert some code at the top of file so that the
  // generated code won't start with `'use babel';` and failed to load into Atom accordingly.
  // To solve this problem, we remove the babel header before transpiling and add it back
  // to the generated code.
  if (!sourceCode.startsWith(BABEL_HEADER)) {
    throw new Error('Service source code should start with "\'use babel\';"');
  }

  sourceCode = sourceCode.substring(BABEL_HEADER.length);

  var code = babel.transform(sourceCode, {
    blacklist: ['es6.arrowFunctions', 'es6.classes', 'strict'],
    optional: ['es7.classProperties'],
    plugins: [createRemoteServiceTransformer(sourceFilePath)]
  }).code;

  // Append `'use 6to5';` at beginning of code so it will be transpiled by babel.
  // Also append a newline at the end of code to make eslint happy.
  code = BABEL_HEADER + '\n' + code + '\n';

  mkdirp.sync(TRANSPILED_FILE_FOLDER);
  fs.writeFileSync(destFilePath, code);
}

/**
 * Generate and load remote implementation for service defined in serviceDefinitionFilePath.
 * Caution:
 *  1. Service definition class should have unique name.
 *  2. We put this function at main.js and it will try to resolve the path from current
 *     module's parent, which should be the caller module. If anyone move this function into its
 *     own file and require it from main.js, `module.parent` should be changed to
 *     `module.parent.parent` as there is another level of requirement.
 */
function requireRemoteServiceSync(serviceDefinitionFilePath, serviceName) {
  // Resolve serviceDefinitionFilePath based on the caller's module, and fallback to
  // this file's module in case module.parent doesn't exist (we are using repl).
  // Note that `require('module')._resolveFilename(path, module)` is equivelent to
  // `require.resolve(path)` under the context of given module.
  var resolvedServiceDefinitionFilePath = require('module')._resolveFilename(serviceDefinitionFilePath, module.parent ? module.parent : module);

  var transpiledRemoteServiceFilePath = path.join(TRANSPILED_FILE_FOLDER, path.basename(resolvedServiceDefinitionFilePath));

  if (!transpiledFilePaths.has(resolvedServiceDefinitionFilePath)) {
    transpile(resolvedServiceDefinitionFilePath, transpiledRemoteServiceFilePath);
    transpiledFilePaths.add(resolvedServiceDefinitionFilePath);
  }

  var serviceModule = require(transpiledRemoteServiceFilePath);
  return serviceModule[serviceName] || serviceModule;
}

module.exports = {
  parseServiceApiSync: parseServiceApiSync,
  requireRemoteServiceSync: requireRemoteServiceSync,
  transpile: transpile
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZpY2UtdHJhbnNmb3JtZXIvbGliL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxDQUFDOzs7Ozs7Ozs7O0FBV1osSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2xDLElBQUksOEJBQThCLEdBQUcsT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFDN0UsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMvQixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDM0IsSUFBSSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7QUFFdEQsSUFBSSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM3RCxJQUFJLFlBQVksR0FBRyxjQUFjLENBQUM7O0FBRWxDLElBQUksbUJBQW1CLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7QUFFcEMsU0FBUyxTQUFTLENBQUMsY0FBc0IsRUFBRSxZQUFvQixFQUFRO0FBQ3JFLE1BQUksVUFBVSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7QUFNekQsTUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDeEMsVUFBTSxJQUFJLEtBQUssMERBQXdELENBQUM7R0FDekU7O0FBRUQsWUFBVSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV2RCxNQUFJLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtBQUNyQyxhQUFTLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDO0FBQzFELFlBQVEsRUFBRSxDQUFDLHFCQUFxQixDQUFDO0FBQ2pDLFdBQU8sRUFBRSxDQUFDLDhCQUE4QixDQUFDLGNBQWMsQ0FBQyxDQUFDO0dBQzFELENBQUMsQ0FBQyxJQUFJLENBQUM7Ozs7QUFJUixNQUFJLEdBQUcsWUFBWSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUV6QyxRQUFNLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDcEMsSUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDdEM7Ozs7Ozs7Ozs7O0FBV0QsU0FBUyx3QkFBd0IsQ0FBQyx5QkFBaUMsRUFBRSxXQUFtQixFQUFPOzs7OztBQUs3RixNQUFJLGlDQUFpQyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDdEUseUJBQXlCLEVBQ3pCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQzs7QUFFNUMsTUFBSSwrQkFBK0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUMzQyxzQkFBc0IsRUFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLENBQUM7O0FBRXRELE1BQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsaUNBQWlDLENBQUMsRUFBRTtBQUMvRCxhQUFTLENBQUMsaUNBQWlDLEVBQUUsK0JBQStCLENBQUMsQ0FBQztBQUM5RSx1QkFBbUIsQ0FBQyxHQUFHLENBQUMsaUNBQWlDLENBQUMsQ0FBQztHQUM1RDs7QUFFRCxNQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQztBQUM3RCxTQUFPLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxhQUFhLENBQUM7Q0FDcEQ7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLHFCQUFtQixFQUFuQixtQkFBbUI7QUFDbkIsMEJBQXdCLEVBQXhCLHdCQUF3QjtBQUN4QixXQUFTLEVBQVQsU0FBUztDQUNWLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtc2VydmljZS10cmFuc2Zvcm1lci9saWIvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBiYWJlbCA9IHJlcXVpcmUoJ2JhYmVsLWNvcmUnKTtcbnZhciBjcmVhdGVSZW1vdGVTZXJ2aWNlVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL3JlbW90ZS1zZXJ2aWNlLXRyYW5zZm9ybWVyJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIG1rZGlycCA9IHJlcXVpcmUoJ21rZGlycCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcGFyc2VTZXJ2aWNlQXBpU3luYyA9IHJlcXVpcmUoJy4vc2VydmljZS1wYXJzZXInKTtcblxudmFyIFRSQU5TUElMRURfRklMRV9GT0xERVIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vZ2VuLycpO1xudmFyIEJBQkVMX0hFQURFUiA9IFwiJ3VzZSBiYWJlbCc7XCI7XG5cbnZhciB0cmFuc3BpbGVkRmlsZVBhdGhzID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiB0cmFuc3BpbGUoc291cmNlRmlsZVBhdGg6IHN0cmluZywgZGVzdEZpbGVQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgdmFyIHNvdXJjZUNvZGUgPSBmcy5yZWFkRmlsZVN5bmMoc291cmNlRmlsZVBhdGgsICd1dGY4Jyk7XG5cbiAgLy8gV2hpbGUgdHJhbnNwaWxpbmcgRmxvdyBpbXBvcnQsIGJhYmVsIG1pZ2h0IGluc2VydCBzb21lIGNvZGUgYXQgdGhlIHRvcCBvZiBmaWxlIHNvIHRoYXQgdGhlXG4gIC8vIGdlbmVyYXRlZCBjb2RlIHdvbid0IHN0YXJ0IHdpdGggYCd1c2UgYmFiZWwnO2AgYW5kIGZhaWxlZCB0byBsb2FkIGludG8gQXRvbSBhY2NvcmRpbmdseS5cbiAgLy8gVG8gc29sdmUgdGhpcyBwcm9ibGVtLCB3ZSByZW1vdmUgdGhlIGJhYmVsIGhlYWRlciBiZWZvcmUgdHJhbnNwaWxpbmcgYW5kIGFkZCBpdCBiYWNrXG4gIC8vIHRvIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgaWYgKCFzb3VyY2VDb2RlLnN0YXJ0c1dpdGgoQkFCRUxfSEVBREVSKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2VydmljZSBzb3VyY2UgY29kZSBzaG91bGQgc3RhcnQgd2l0aCBcIid1c2UgYmFiZWwnO1wiYCk7XG4gIH1cblxuICBzb3VyY2VDb2RlID0gc291cmNlQ29kZS5zdWJzdHJpbmcoQkFCRUxfSEVBREVSLmxlbmd0aCk7XG5cbiAgdmFyIGNvZGUgPSBiYWJlbC50cmFuc2Zvcm0oc291cmNlQ29kZSwge1xuICAgIGJsYWNrbGlzdDogWydlczYuYXJyb3dGdW5jdGlvbnMnLCAnZXM2LmNsYXNzZXMnLCAnc3RyaWN0J10sXG4gICAgb3B0aW9uYWw6IFsnZXM3LmNsYXNzUHJvcGVydGllcyddLFxuICAgIHBsdWdpbnM6IFtjcmVhdGVSZW1vdGVTZXJ2aWNlVHJhbnNmb3JtZXIoc291cmNlRmlsZVBhdGgpXSxcbiAgfSkuY29kZTtcblxuICAvLyBBcHBlbmQgYCd1c2UgNnRvNSc7YCBhdCBiZWdpbm5pbmcgb2YgY29kZSBzbyBpdCB3aWxsIGJlIHRyYW5zcGlsZWQgYnkgYmFiZWwuXG4gIC8vIEFsc28gYXBwZW5kIGEgbmV3bGluZSBhdCB0aGUgZW5kIG9mIGNvZGUgdG8gbWFrZSBlc2xpbnQgaGFwcHkuXG4gIGNvZGUgPSBCQUJFTF9IRUFERVIgKyAnXFxuJyArIGNvZGUgKyAnXFxuJztcblxuICBta2RpcnAuc3luYyhUUkFOU1BJTEVEX0ZJTEVfRk9MREVSKTtcbiAgZnMud3JpdGVGaWxlU3luYyhkZXN0RmlsZVBhdGgsIGNvZGUpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuZCBsb2FkIHJlbW90ZSBpbXBsZW1lbnRhdGlvbiBmb3Igc2VydmljZSBkZWZpbmVkIGluIHNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGguXG4gKiBDYXV0aW9uOlxuICogIDEuIFNlcnZpY2UgZGVmaW5pdGlvbiBjbGFzcyBzaG91bGQgaGF2ZSB1bmlxdWUgbmFtZS5cbiAqICAyLiBXZSBwdXQgdGhpcyBmdW5jdGlvbiBhdCBtYWluLmpzIGFuZCBpdCB3aWxsIHRyeSB0byByZXNvbHZlIHRoZSBwYXRoIGZyb20gY3VycmVudFxuICogICAgIG1vZHVsZSdzIHBhcmVudCwgd2hpY2ggc2hvdWxkIGJlIHRoZSBjYWxsZXIgbW9kdWxlLiBJZiBhbnlvbmUgbW92ZSB0aGlzIGZ1bmN0aW9uIGludG8gaXRzXG4gKiAgICAgb3duIGZpbGUgYW5kIHJlcXVpcmUgaXQgZnJvbSBtYWluLmpzLCBgbW9kdWxlLnBhcmVudGAgc2hvdWxkIGJlIGNoYW5nZWQgdG9cbiAqICAgICBgbW9kdWxlLnBhcmVudC5wYXJlbnRgIGFzIHRoZXJlIGlzIGFub3RoZXIgbGV2ZWwgb2YgcmVxdWlyZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVSZW1vdGVTZXJ2aWNlU3luYyhzZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoOiBzdHJpbmcsIHNlcnZpY2VOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAvLyBSZXNvbHZlIHNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGggYmFzZWQgb24gdGhlIGNhbGxlcidzIG1vZHVsZSwgYW5kIGZhbGxiYWNrIHRvXG4gIC8vIHRoaXMgZmlsZSdzIG1vZHVsZSBpbiBjYXNlIG1vZHVsZS5wYXJlbnQgZG9lc24ndCBleGlzdCAod2UgYXJlIHVzaW5nIHJlcGwpLlxuICAvLyBOb3RlIHRoYXQgYHJlcXVpcmUoJ21vZHVsZScpLl9yZXNvbHZlRmlsZW5hbWUocGF0aCwgbW9kdWxlKWAgaXMgZXF1aXZlbGVudCB0b1xuICAvLyBgcmVxdWlyZS5yZXNvbHZlKHBhdGgpYCB1bmRlciB0aGUgY29udGV4dCBvZiBnaXZlbiBtb2R1bGUuXG4gIHZhciByZXNvbHZlZFNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGggPSByZXF1aXJlKCdtb2R1bGUnKS5fcmVzb2x2ZUZpbGVuYW1lKFxuICAgICAgc2VydmljZURlZmluaXRpb25GaWxlUGF0aCxcbiAgICAgIG1vZHVsZS5wYXJlbnQgPyBtb2R1bGUucGFyZW50IDogbW9kdWxlKTtcblxuICB2YXIgdHJhbnNwaWxlZFJlbW90ZVNlcnZpY2VGaWxlUGF0aCA9IHBhdGguam9pbihcbiAgICAgIFRSQU5TUElMRURfRklMRV9GT0xERVIsXG4gICAgICBwYXRoLmJhc2VuYW1lKHJlc29sdmVkU2VydmljZURlZmluaXRpb25GaWxlUGF0aCkpO1xuXG4gIGlmICghdHJhbnNwaWxlZEZpbGVQYXRocy5oYXMocmVzb2x2ZWRTZXJ2aWNlRGVmaW5pdGlvbkZpbGVQYXRoKSkge1xuICAgIHRyYW5zcGlsZShyZXNvbHZlZFNlcnZpY2VEZWZpbml0aW9uRmlsZVBhdGgsIHRyYW5zcGlsZWRSZW1vdGVTZXJ2aWNlRmlsZVBhdGgpO1xuICAgIHRyYW5zcGlsZWRGaWxlUGF0aHMuYWRkKHJlc29sdmVkU2VydmljZURlZmluaXRpb25GaWxlUGF0aCk7XG4gIH1cblxuICB2YXIgc2VydmljZU1vZHVsZSA9IHJlcXVpcmUodHJhbnNwaWxlZFJlbW90ZVNlcnZpY2VGaWxlUGF0aCk7XG4gIHJldHVybiBzZXJ2aWNlTW9kdWxlW3NlcnZpY2VOYW1lXSB8fCBzZXJ2aWNlTW9kdWxlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VTZXJ2aWNlQXBpU3luYyxcbiAgcmVxdWlyZVJlbW90ZVNlcnZpY2VTeW5jLFxuICB0cmFuc3BpbGUsXG59O1xuIl19
