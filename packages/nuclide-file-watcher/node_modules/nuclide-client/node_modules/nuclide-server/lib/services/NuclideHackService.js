

/**
 * Executes the hh_client on the remote connected dev box using the ExecClient passed
 */

var _callHHClient = _asyncToGenerator(function* (args, errorStream, outputJson, processInput, cwd) {
  // append args on the end of our commands
  var defaults = ['--retries', '0', '--retry-if-init', 'false', '--from', 'nuclide'];
  if (outputJson) {
    defaults.unshift('--json');
  }

  var allArgs = defaults.concat(args);
  allArgs.push(cwd);

  var execResult = yield checkOutput(PATH_TO_HH_CLIENT, allArgs, { stdin: processInput });

  var output = errorStream ? execResult.stderr : execResult.stdout;
  if (outputJson) {
    try {
      return JSON.parse(output);
    } catch (err) {
      logger.error('failed to parse hh_client output:', output);
      throw new Error('failed to parse hh_client output: ' + output);
    }
  } else {
    return output;
  }
}

/**
 * Gets the hh_client diagnistics for all files open
 */
);

/**
 * Gets the hh_client definition of the query with a given symbol type.
 */

var getDefinition = _asyncToGenerator(function* (query, symbolType) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var searchTypes = symbolTypeToSearchTypes(symbolType);
  var searchResults = [];
  try {
    searchResults = yield getSearchResults(query, searchTypes, undefined, options);
  } catch (e) {
    logger.warn('getSearchResults error:', e);
  }
  return searchResults.filter(function (result) {
    // If the request had a :: in it, it's a full name, so we should compare to
    // the name of the result in that format.
    var fullName = result.name;
    if (query.indexOf('::') !== -1 && result.scope) {
      fullName = result.scope + '::' + fullName;
    }
    return fullName === query;
  });
}

/**
 * Fetches the dependencies needed by the hack worker to cache for faster hack features response times.
 * Returnes a map of file paths to file contents.
 */
);

var getDependencies = _asyncToGenerator(function* (dependenciesInfo) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var dependencies = {};

  // hh_server currently is single threaded and processes one request at a time.
  // Hence, we fetch the dependencies one-by-one, without Promise.all for the hack search to unblock
  // user-requested hack language features and failry treat other usages of hh_client.
  for (var i = 0; i < dependenciesInfo.length; i++) {
    var _dependenciesInfo$i = dependenciesInfo[i];
    var dependencyName = _dependenciesInfo$i.name;
    var dependencyType = _dependenciesInfo$i.type;

    if (dependencyName.startsWith('\\')) {
      dependencyName = dependencyName.substring(1);
    }
    var filter;
    if (dependencyType === 'class') {
      filter = [SearchResultType.CLASS, SearchResultType.ABSTRACT_CLASS, SearchResultType.TRAIT, SearchResultType.TYPEDEF, SearchResultType.INTERFACE];
    } else {
      filter = [SearchResultType.FUNCTION];
    }

    var searchResults = yield getSearchResults(dependencyName, filter, undefined, options);

    yield Promise.all(searchResults.map(_asyncToGenerator(function* (location) {
      var name = location.name;
      var path = location.path;

      if (name !== dependencyName) {
        return;
      }
      var contents = yield fsPromise.readFile(path, 'utf8');
      if (!contents.startsWith('<?hh')) {
        return;
      }
      // This turns anything we're adding into decl mode, so that it uses less memory.
      // Ideally, hh_server should do this, and strip the method/function bodies.
      if (contents.startsWith(HH_NEWLINE)) {
        contents = '<?hh // decl\n' + contents.substring(HH_NEWLINE.length);
      } else if (contents.startsWith(HH_STRICT_NEWLINE)) {
        contents = '<?hh // decl\n' + contents.substring(HH_STRICT_NEWLINE.length);
      }
      dependencies[path] = contents;
    })));
  }

  return dependencies;
});

var getSearchResults = _asyncToGenerator(function* (search, filterTypes, searchPostfix) {
  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  if (!search) {
    return [];
  }
  var response = yield _callHHClient(
  /*args*/['--search' + (searchPostfix || ''), search],
  /*errorStream*/false,
  /*outputJson*/true,
  /*processInput*/null,
  /*options*/options.cwd);
  var results = response.map(function (result) {
    return {
      line: result.line - 1,
      column: result.char_start - 1,
      name: result.name,
      path: result.filename,
      length: result.char_end - result.char_start + 1,
      scope: result.scope,
      additionalInfo: result.desc,
      action: 'OPEN_PATH'
    };
  });
  if (filterTypes) {
    results = filterSearchResults(results, filterTypes);
  }
  return results;
}

// Eventually this will happen on the hack side, but for now, this will do.
);

var getReferences = _asyncToGenerator(function* (symbolName) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return yield _callHHClient(
  /*args*/['--find-refs', symbolName],
  /*errorStream*/false,
  /*outputJson*/true,
  /*processInput*/null,
  /*options*/options.cwd);
});

var isClientAvailable = _asyncToGenerator(function* () {
  var _ref = yield checkOutput('which', [PATH_TO_HH_CLIENT]);

  var stdout = _ref.stdout;

  // The `stdout` would be empty if there is no such command.
  return stdout.trim().length > 0;
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

'use babel';

var logger = require('nuclide-logging').getLogger();

var _require = require('nuclide-hack-common/lib/constants');

var SearchResultType = _require.SearchResultType;
var SymbolType = _require.SymbolType;

var _require2 = require('nuclide-commons');

var checkOutput = _require2.checkOutput;
var fsPromise = _require2.fsPromise;

var extend = require('util')._extend;

var HH_NEWLINE = '<?hh\n';
var HH_STRICT_NEWLINE = '<?hh // strict\n';
var PATH_TO_HH_CLIENT = 'hh_client';function getDiagnostics() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  return _callHHClient(
  /*args*/[],
  /*errorStream*/true,
  /*outputJson*/true,
  /*processInput*/null,
  /*options*/options.cwd);
}

/**
 * Gets the hh_client autocompletions for the passed query string (file contents with a marker).
 */
function getCompletions(query, options) {
  return _callHHClient(
  /*args*/['--auto-complete'],
  /*errorStream*/false,
  /*outputJson*/true,
  /*processInput*/query,
  /*options*/options.cwd);
}function filterSearchResults(results, filter) {

  return results.filter(function (result) {
    var info = result.additionalInfo;
    var searchType = getSearchType(info);
    return filter.indexOf(searchType) !== -1;
  });
}

function getSearchType(info) {
  switch (info) {
    case 'typedef':
      return SearchResultType.TYPEDEF;
    case 'function':
      return SearchResultType.FUNCTION;
    case 'constant':
      return SearchResultType.CONSTANT;
    case 'trait':
      return SearchResultType.TRAIT;
    case 'interface':
      return SearchResultType.INTERFACE;
    case 'abstract class':
      return SearchResultType.ABSTRACT_CLASS;
    default:
      {
        if (info.startsWith('method') || info.startsWith('static method')) {
          return SearchResultType.METHOD;
        }
        if (info.startsWith('class var') || info.startsWith('static class var')) {
          return SearchResultType.CLASS_VAR;
        }
        return SearchResultType.CLASS;
      }
  }
}

function symbolTypeToSearchTypes(symbolType) {
  switch (symbolType) {
    case SymbolType.CLASS:
      return [SearchResultType.CLASS, SearchResultType.ABSTRACT_CLASS, SearchResultType.TRAIT, SearchResultType.TYPEDEF, SearchResultType.INTERFACE];
    case SymbolType.METHOD:
      return [SearchResultType.METHOD];
    case SymbolType.FUNCTION:
      return [SearchResultType.FUNCTION];
    default:
      return null;
  }
}

module.exports = {
  services: {
    '/hack/getDiagnostics': { handler: getDiagnostics, method: 'post' },
    '/hack/getCompletions': { handler: getCompletions, method: 'post' },
    '/hack/getDefinition': { handler: getDefinition, method: 'post' },
    '/hack/getDependencies': { handler: getDependencies, method: 'post' },
    '/hack/getSearchResults': { handler: getSearchResults, method: 'post' },
    '/hack/getReferences': { handler: getReferences, method: 'post' },
    '/hack/isClientAvailable': { handler: isClientAvailable, method: 'post' }
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXNlcnZlci9saWIvc2VydmljZXMvTnVjbGlkZUhhY2tTZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztJQXlCZSxhQUFhLHFCQUE1QixXQUNFLElBQW1CLEVBQ25CLFdBQW9CLEVBQ3BCLFVBQW1CLEVBQ25CLFlBQXFCLEVBQ3JCLEdBQVcsRUFBZ0I7O0FBRTNCLE1BQUksUUFBUSxHQUFHLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ25GLE1BQUksVUFBVSxFQUFFO0FBQ2QsWUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUM1Qjs7QUFFRCxNQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BDLFNBQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRWxCLE1BQUksVUFBVSxHQUFHLE1BQU0sV0FBVyxDQUFDLGlCQUFpQixFQUFFLE9BQU8sRUFBRSxFQUFDLEtBQUssRUFBRSxZQUFZLEVBQUMsQ0FBQyxDQUFDOztBQUV0RixNQUFJLE1BQU0sR0FBRyxXQUFXLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQ2pFLE1BQUksVUFBVSxFQUFFO0FBQ2QsUUFBSTtBQUNGLGFBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMzQixDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ1osWUFBTSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMxRCxZQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0tB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L0QsMkJBQXVCLEVBQUUsRUFBQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUM7QUFDbkUsNEJBQXdCLEVBQUUsRUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBQztBQUNyRSx5QkFBcUIsRUFBRSxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBQztBQUMvRCw2QkFBeUIsRUFBRSxFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDO0dBQ3hFO0NBQ0YsQ0FBQyIsImZpbGUiOiIvdmFyL2ZvbGRlcnMveGYvcnNwaDRfYzU3MzE1cnM1N3h4c2Rza3J4bnYzNnQwL1QvdG1wZW1tMkh1cHVibGlzaF9wYWNrYWdlcy9ucG0vbnVjbGlkZS1zZXJ2ZXIvbGliL3NlcnZpY2VzL051Y2xpZGVIYWNrU2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB0eXBlIHtIYWNrUmVmZXJlbmNlfSBmcm9tICdudWNsaWRlLWhhY2stY29tbW9uJztcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xudmFyIHtTZWFyY2hSZXN1bHRUeXBlLCBTeW1ib2xUeXBlfSA9IHJlcXVpcmUoJ251Y2xpZGUtaGFjay1jb21tb24vbGliL2NvbnN0YW50cycpO1xudmFyIHtjaGVja091dHB1dCwgZnNQcm9taXNlfSA9IHJlcXVpcmUoJ251Y2xpZGUtY29tbW9ucycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3V0aWwnKS5fZXh0ZW5kO1xuXG5jb25zdCBISF9ORVdMSU5FID0gJzw/aGhcXG4nO1xuY29uc3QgSEhfU1RSSUNUX05FV0xJTkUgPSAnPD9oaCAvLyBzdHJpY3RcXG4nO1xuY29uc3QgUEFUSF9UT19ISF9DTElFTlQgPSAnaGhfY2xpZW50JztcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgaGhfY2xpZW50IG9uIHRoZSByZW1vdGUgY29ubmVjdGVkIGRldiBib3ggdXNpbmcgdGhlIEV4ZWNDbGllbnQgcGFzc2VkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9jYWxsSEhDbGllbnQoXG4gIGFyZ3M6IEFycmF5PHN0cmluZz4sXG4gIGVycm9yU3RyZWFtOiBib29sZWFuLFxuICBvdXRwdXRKc29uOiBib29sZWFuLFxuICBwcm9jZXNzSW5wdXQ6ID9zdHJpbmcsXG4gIGN3ZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gYXBwZW5kIGFyZ3Mgb24gdGhlIGVuZCBvZiBvdXIgY29tbWFuZHNcbiAgdmFyIGRlZmF1bHRzID0gWyctLXJldHJpZXMnLCAnMCcsICctLXJldHJ5LWlmLWluaXQnLCAnZmFsc2UnLCAnLS1mcm9tJywgJ251Y2xpZGUnXTtcbiAgaWYgKG91dHB1dEpzb24pIHtcbiAgICBkZWZhdWx0cy51bnNoaWZ0KCctLWpzb24nKTtcbiAgfVxuXG4gIHZhciBhbGxBcmdzID0gZGVmYXVsdHMuY29uY2F0KGFyZ3MpO1xuICBhbGxBcmdzLnB1c2goY3dkKTtcblxuICB2YXIgZXhlY1Jlc3VsdCA9IGF3YWl0IGNoZWNrT3V0cHV0KFBBVEhfVE9fSEhfQ0xJRU5ULCBhbGxBcmdzLCB7c3RkaW46IHByb2Nlc3NJbnB1dH0pO1xuXG4gIHZhciBvdXRwdXQgPSBlcnJvclN0cmVhbSA/IGV4ZWNSZXN1bHQuc3RkZXJyIDogZXhlY1Jlc3VsdC5zdGRvdXQ7XG4gIGlmIChvdXRwdXRKc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKG91dHB1dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBoaF9jbGllbnQgb3V0cHV0OicsIG91dHB1dCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBoaF9jbGllbnQgb3V0cHV0OiAnICsgb3V0cHV0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGhoX2NsaWVudCBkaWFnbmlzdGljcyBmb3IgYWxsIGZpbGVzIG9wZW5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY3Mob3B0aW9ucyA9IHt9KTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG4gIHJldHVybiBfY2FsbEhIQ2xpZW50KFxuICAgIC8qYXJncyovIFtdLFxuICAgIC8qZXJyb3JTdHJlYW0qLyB0cnVlLFxuICAgIC8qb3V0cHV0SnNvbiovIHRydWUsXG4gICAgLypwcm9jZXNzSW5wdXQqLyBudWxsLFxuICAgIC8qb3B0aW9ucyovIG9wdGlvbnMuY3dkXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGhfY2xpZW50IGF1dG9jb21wbGV0aW9ucyBmb3IgdGhlIHBhc3NlZCBxdWVyeSBzdHJpbmcgKGZpbGUgY29udGVudHMgd2l0aCBhIG1hcmtlcikuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBsZXRpb25zKHF1ZXJ5OiBzdHJpbmcsIG9wdGlvbnMpOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgcmV0dXJuIF9jYWxsSEhDbGllbnQoXG4gICAgLyphcmdzKi8gWyctLWF1dG8tY29tcGxldGUnXSxcbiAgICAvKmVycm9yU3RyZWFtKi8gZmFsc2UsXG4gICAgLypvdXRwdXRKc29uKi8gdHJ1ZSxcbiAgICAvKnByb2Nlc3NJbnB1dCovIHF1ZXJ5LFxuICAgIC8qb3B0aW9ucyovIG9wdGlvbnMuY3dkXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGhfY2xpZW50IGRlZmluaXRpb24gb2YgdGhlIHF1ZXJ5IHdpdGggYSBnaXZlbiBzeW1ib2wgdHlwZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihxdWVyeTogc3RyaW5nLCBzeW1ib2xUeXBlOiBTeW1ib2xUeXBlLCBvcHRpb25zID0ge30pOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgdmFyIHNlYXJjaFR5cGVzID0gc3ltYm9sVHlwZVRvU2VhcmNoVHlwZXMoc3ltYm9sVHlwZSk7XG4gIHZhciBzZWFyY2hSZXN1bHRzID0gW107XG4gIHRyeSB7XG4gICAgc2VhcmNoUmVzdWx0cyA9IGF3YWl0IGdldFNlYXJjaFJlc3VsdHMocXVlcnksIHNlYXJjaFR5cGVzLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLndhcm4oJ2dldFNlYXJjaFJlc3VsdHMgZXJyb3I6JywgZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFJlc3VsdHMuZmlsdGVyKChyZXN1bHQpID0+IHtcbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBoYWQgYSA6OiBpbiBpdCwgaXQncyBhIGZ1bGwgbmFtZSwgc28gd2Ugc2hvdWxkIGNvbXBhcmUgdG9cbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgcmVzdWx0IGluIHRoYXQgZm9ybWF0LlxuICAgIHZhciBmdWxsTmFtZSA9IHJlc3VsdC5uYW1lO1xuICAgIGlmIChxdWVyeS5pbmRleE9mKCc6OicpICE9PSAtMSAmJiByZXN1bHQuc2NvcGUpIHtcbiAgICAgIGZ1bGxOYW1lID0gcmVzdWx0LnNjb3BlICsgJzo6JyArIGZ1bGxOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbE5hbWUgPT09IHF1ZXJ5O1xuICB9KTtcbn1cblxuLyoqXG4gKiBGZXRjaGVzIHRoZSBkZXBlbmRlbmNpZXMgbmVlZGVkIGJ5IHRoZSBoYWNrIHdvcmtlciB0byBjYWNoZSBmb3IgZmFzdGVyIGhhY2sgZmVhdHVyZXMgcmVzcG9uc2UgdGltZXMuXG4gKiBSZXR1cm5lcyBhIG1hcCBvZiBmaWxlIHBhdGhzIHRvIGZpbGUgY29udGVudHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhcbiAgICAgIGRlcGVuZGVuY2llc0luZm86IEFycmF5PHtuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZ30+LFxuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHt9O1xuXG4gIC8vIGhoX3NlcnZlciBjdXJyZW50bHkgaXMgc2luZ2xlIHRocmVhZGVkIGFuZCBwcm9jZXNzZXMgb25lIHJlcXVlc3QgYXQgYSB0aW1lLlxuICAvLyBIZW5jZSwgd2UgZmV0Y2ggdGhlIGRlcGVuZGVuY2llcyBvbmUtYnktb25lLCB3aXRob3V0IFByb21pc2UuYWxsIGZvciB0aGUgaGFjayBzZWFyY2ggdG8gdW5ibG9ja1xuICAvLyB1c2VyLXJlcXVlc3RlZCBoYWNrIGxhbmd1YWdlIGZlYXR1cmVzIGFuZCBmYWlscnkgdHJlYXQgb3RoZXIgdXNhZ2VzIG9mIGhoX2NsaWVudC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXNJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHtuYW1lOiBkZXBlbmRlbmN5TmFtZSwgdHlwZTogZGVwZW5kZW5jeVR5cGV9ID0gZGVwZW5kZW5jaWVzSW5mb1tpXTtcbiAgICBpZiAoZGVwZW5kZW5jeU5hbWUuc3RhcnRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICAgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5TmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHZhciBmaWx0ZXI7XG4gICAgaWYgKGRlcGVuZGVuY3lUeXBlID09PSAnY2xhc3MnKSB7XG4gICAgICBmaWx0ZXIgPSBbXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQUJTVFJBQ1RfQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFJBSVQsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFlQRURFRixcbiAgICAgICAgU2VhcmNoUmVzdWx0VHlwZS5JTlRFUkZBQ0UsXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXIgPSBbU2VhcmNoUmVzdWx0VHlwZS5GVU5DVElPTl07XG4gICAgfVxuXG4gICAgdmFyIHNlYXJjaFJlc3VsdHMgPSBhd2FpdCBnZXRTZWFyY2hSZXN1bHRzKGRlcGVuZGVuY3lOYW1lLCBmaWx0ZXIsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChzZWFyY2hSZXN1bHRzLm1hcChhc3luYyAobG9jYXRpb24pID0+IHtcbiAgICAgIHZhciB7bmFtZSwgcGF0aH0gPSBsb2NhdGlvbjtcbiAgICAgIGlmIChuYW1lICE9PSBkZXBlbmRlbmN5TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29udGVudHMgPSBhd2FpdCBmc1Byb21pc2UucmVhZEZpbGUocGF0aCwgJ3V0ZjgnKTtcbiAgICAgIGlmICghY29udGVudHMuc3RhcnRzV2l0aCgnPD9oaCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgdHVybnMgYW55dGhpbmcgd2UncmUgYWRkaW5nIGludG8gZGVjbCBtb2RlLCBzbyB0aGF0IGl0IHVzZXMgbGVzcyBtZW1vcnkuXG4gICAgICAvLyBJZGVhbGx5LCBoaF9zZXJ2ZXIgc2hvdWxkIGRvIHRoaXMsIGFuZCBzdHJpcCB0aGUgbWV0aG9kL2Z1bmN0aW9uIGJvZGllcy5cbiAgICAgIGlmIChjb250ZW50cy5zdGFydHNXaXRoKEhIX05FV0xJTkUpKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJzw/aGggLy8gZGVjbFxcbicgKyBjb250ZW50cy5zdWJzdHJpbmcoSEhfTkVXTElORS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZW50cy5zdGFydHNXaXRoKEhIX1NUUklDVF9ORVdMSU5FKSkge1xuICAgICAgICBjb250ZW50cyA9ICc8P2hoIC8vIGRlY2xcXG4nICsgY29udGVudHMuc3Vic3RyaW5nKEhIX1NUUklDVF9ORVdMSU5FLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBkZXBlbmRlbmNpZXNbcGF0aF0gPSBjb250ZW50cztcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTZWFyY2hSZXN1bHRzKFxuICAgIHNlYXJjaDogc3RyaW5nLFxuICAgIGZpbHRlclR5cGVzOiA/QXJyYXk8U2VhcmNoUmVzdWx0VHlwZT4sXG4gICAgc2VhcmNoUG9zdGZpeDogP3N0cmluZyxcbiAgICBvcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxBcnJheTxhbnk+PiB7XG5cbiAgaWYgKCFzZWFyY2gpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHJlc3BvbnNlID0gYXdhaXQgX2NhbGxISENsaWVudChcbiAgICAgIC8qYXJncyovIFsnLS1zZWFyY2gnICsgKHNlYXJjaFBvc3RmaXggfHwgJycpLCBzZWFyY2hdLFxuICAgICAgLyplcnJvclN0cmVhbSovIGZhbHNlLFxuICAgICAgLypvdXRwdXRKc29uKi8gdHJ1ZSxcbiAgICAgIC8qcHJvY2Vzc0lucHV0Ki8gbnVsbCxcbiAgICAgIC8qb3B0aW9ucyovIG9wdGlvbnMuY3dkXG4gICk7XG4gIHZhciByZXN1bHRzID0gcmVzcG9uc2UubWFwKChyZXN1bHQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogcmVzdWx0LmxpbmUgLSAxLFxuICAgICAgY29sdW1uOiByZXN1bHQuY2hhcl9zdGFydCAtIDEsXG4gICAgICBuYW1lOiByZXN1bHQubmFtZSxcbiAgICAgIHBhdGg6IHJlc3VsdC5maWxlbmFtZSxcbiAgICAgIGxlbmd0aDogcmVzdWx0LmNoYXJfZW5kIC0gcmVzdWx0LmNoYXJfc3RhcnQgKyAxLFxuICAgICAgc2NvcGU6IHJlc3VsdC5zY29wZSxcbiAgICAgIGFkZGl0aW9uYWxJbmZvOiByZXN1bHQuZGVzYyxcbiAgICAgIGFjdGlvbjogJ09QRU5fUEFUSCcsXG4gICAgfTtcbiAgfSk7XG4gIGlmIChmaWx0ZXJUeXBlcykge1xuICAgIHJlc3VsdHMgPSBmaWx0ZXJTZWFyY2hSZXN1bHRzKHJlc3VsdHMsIGZpbHRlclR5cGVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gRXZlbnR1YWxseSB0aGlzIHdpbGwgaGFwcGVuIG9uIHRoZSBoYWNrIHNpZGUsIGJ1dCBmb3Igbm93LCB0aGlzIHdpbGwgZG8uXG5mdW5jdGlvbiBmaWx0ZXJTZWFyY2hSZXN1bHRzKFxuICByZXN1bHRzOiBBcnJheTxhbnk+LFxuICBmaWx0ZXI6IEFycmF5PFNlYXJjaFJlc3VsdFR5cGU+KVxuICA6IEFycmF5PGFueT4ge1xuXG4gIHJldHVybiByZXN1bHRzLmZpbHRlcigocmVzdWx0KSA9PiB7XG4gICAgdmFyIGluZm8gPSByZXN1bHQuYWRkaXRpb25hbEluZm87XG4gICAgdmFyIHNlYXJjaFR5cGUgPSBnZXRTZWFyY2hUeXBlKGluZm8pO1xuICAgIHJldHVybiBmaWx0ZXIuaW5kZXhPZihzZWFyY2hUeXBlKSAhPT0gLTE7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTZWFyY2hUeXBlKGluZm86IHN0cmluZyk6IFNlYXJjaFJlc3VsdFR5cGUge1xuICBzd2l0Y2ggKGluZm8pIHtcbiAgICBjYXNlICd0eXBlZGVmJzpcbiAgICAgIHJldHVybiBTZWFyY2hSZXN1bHRUeXBlLlRZUEVERUY7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIFNlYXJjaFJlc3VsdFR5cGUuRlVOQ1RJT047XG4gICAgY2FzZSAnY29uc3RhbnQnOlxuICAgICAgcmV0dXJuIFNlYXJjaFJlc3VsdFR5cGUuQ09OU1RBTlQ7XG4gICAgY2FzZSAndHJhaXQnOlxuICAgICAgcmV0dXJuIFNlYXJjaFJlc3VsdFR5cGUuVFJBSVQ7XG4gICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgIHJldHVybiBTZWFyY2hSZXN1bHRUeXBlLklOVEVSRkFDRTtcbiAgICBjYXNlICdhYnN0cmFjdCBjbGFzcyc6XG4gICAgICByZXR1cm4gU2VhcmNoUmVzdWx0VHlwZS5BQlNUUkFDVF9DTEFTUztcbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAoaW5mby5zdGFydHNXaXRoKCdtZXRob2QnKSB8fCBpbmZvLnN0YXJ0c1dpdGgoJ3N0YXRpYyBtZXRob2QnKSkge1xuICAgICAgICByZXR1cm4gU2VhcmNoUmVzdWx0VHlwZS5NRVRIT0Q7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5zdGFydHNXaXRoKCdjbGFzcyB2YXInKSB8fCBpbmZvLnN0YXJ0c1dpdGgoJ3N0YXRpYyBjbGFzcyB2YXInKSkge1xuICAgICAgICByZXR1cm4gU2VhcmNoUmVzdWx0VHlwZS5DTEFTU19WQVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gU2VhcmNoUmVzdWx0VHlwZS5DTEFTUztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltYm9sVHlwZVRvU2VhcmNoVHlwZXMoc3ltYm9sVHlwZTogU3ltYm9sVHlwZSk6ID9BcnJheTxTZWFyY2hSZXN1bHRUeXBlPiB7XG4gIHN3aXRjaCAoc3ltYm9sVHlwZSkge1xuICAgIGNhc2UgU3ltYm9sVHlwZS5DTEFTUzpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuQUJTVFJBQ1RfQ0xBU1MsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFJBSVQsXG4gICAgICAgIFNlYXJjaFJlc3VsdFR5cGUuVFlQRURFRixcbiAgICAgICAgU2VhcmNoUmVzdWx0VHlwZS5JTlRFUkZBQ0UsXG4gICAgICBdO1xuICAgICBjYXNlIFN5bWJvbFR5cGUuTUVUSE9EOlxuICAgICAgIHJldHVybiBbIFNlYXJjaFJlc3VsdFR5cGUuTUVUSE9EIF07XG4gICAgIGNhc2UgU3ltYm9sVHlwZS5GVU5DVElPTjpcbiAgICAgICByZXR1cm4gWyBTZWFyY2hSZXN1bHRUeXBlLkZVTkNUSU9OIF07XG4gICAgIGRlZmF1bHQ6XG4gICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlcyhcbiAgc3ltYm9sTmFtZTogc3RyaW5nLFxuICBvcHRpb25zOiBPYmplY3QgPSB7fVxuKTogUHJvbWlzZTxBcnJheTxIYWNrUmVmZXJlbmNlPj4ge1xuICByZXR1cm4gYXdhaXQgX2NhbGxISENsaWVudChcbiAgICAvKmFyZ3MqLyBbJy0tZmluZC1yZWZzJywgc3ltYm9sTmFtZV0sXG4gICAgLyplcnJvclN0cmVhbSovIGZhbHNlLFxuICAgIC8qb3V0cHV0SnNvbiovIHRydWUsXG4gICAgLypwcm9jZXNzSW5wdXQqLyBudWxsLFxuICAgIC8qb3B0aW9ucyovIG9wdGlvbnMuY3dkXG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzQ2xpZW50QXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB2YXIge3N0ZG91dH0gPSBhd2FpdCBjaGVja091dHB1dCgnd2hpY2gnLCBbUEFUSF9UT19ISF9DTElFTlRdKTtcbiAgLy8gVGhlIGBzdGRvdXRgIHdvdWxkIGJlIGVtcHR5IGlmIHRoZXJlIGlzIG5vIHN1Y2ggY29tbWFuZC5cbiAgcmV0dXJuIHN0ZG91dC50cmltKCkubGVuZ3RoID4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNlcnZpY2VzOiB7XG4gICAgJy9oYWNrL2dldERpYWdub3N0aWNzJzoge2hhbmRsZXI6IGdldERpYWdub3N0aWNzLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9oYWNrL2dldENvbXBsZXRpb25zJzoge2hhbmRsZXI6IGdldENvbXBsZXRpb25zLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9oYWNrL2dldERlZmluaXRpb24nOiB7aGFuZGxlcjogZ2V0RGVmaW5pdGlvbiwgbWV0aG9kOiAncG9zdCd9LFxuICAgICcvaGFjay9nZXREZXBlbmRlbmNpZXMnOiB7aGFuZGxlcjogZ2V0RGVwZW5kZW5jaWVzLCBtZXRob2Q6ICdwb3N0J30sXG4gICAgJy9oYWNrL2dldFNlYXJjaFJlc3VsdHMnOiB7aGFuZGxlcjogZ2V0U2VhcmNoUmVzdWx0cywgbWV0aG9kOiAncG9zdCd9LFxuICAgICcvaGFjay9nZXRSZWZlcmVuY2VzJzoge2hhbmRsZXI6IGdldFJlZmVyZW5jZXMsIG1ldGhvZDogJ3Bvc3QnfSxcbiAgICAnL2hhY2svaXNDbGllbnRBdmFpbGFibGUnOiB7aGFuZGxlcjogaXNDbGllbnRBdmFpbGFibGUsIG1ldGhvZDogJ3Bvc3QnfSxcbiAgfVxufTtcbiJdfQ==
