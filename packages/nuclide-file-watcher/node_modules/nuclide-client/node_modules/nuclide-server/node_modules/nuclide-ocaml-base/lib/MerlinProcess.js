var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

'use babel';

var _require = require('nuclide-commons');

var PromiseQueue = _require.PromiseQueue;

var ERROR_RESPONSES = new Set(['failure', 'error', 'exception']);

/**
 * Wraps an ocamlmerlin process; provides api access to
 * ocamlmerlin's json-over-stdin/stdout protocol.
 *
 * This is based on the protocol description at:
 *   https://github.com/the-lambda-church/merlin/blob/master/PROTOCOL.md
 *   https://github.com/the-lambda-church/merlin/tree/master/src/frontend
 */

var MerlinProcess = (function () {
  function MerlinProcess(proc) {
    var _this = this;

    _classCallCheck(this, MerlinProcess);

    this._proc = proc;
    this._promiseQueue = new PromiseQueue();
    this._running = true;
    this._proc.on('exit', function (code, signal) {
      _this._running = false;
    });
  }

  _createClass(MerlinProcess, [{
    key: 'isRunning',
    value: function isRunning() {
      return this._running;
    }

    /**
     * Tell merlin where to find its per-repo .merlin config file.
     *
     * Configuration file format description:
     *   https://github.com/the-lambda-church/merlin/wiki/project-configuration
     *
     * @return a dummy cursor position on success
     */
  }, {
    key: 'pushDotMerlinPath',
    value: _asyncToGenerator(function* (path) {
      var _this2 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var result = yield _this2.runSingleCommand(['reset', 'dot_merlin', [path], 'auto']);
        resolve(result);
      }));
    })

    /**
     * Set the buffer content to query against. Merlin uses an internal
     * buffer (name + content) that is independent from file content on
     * disk.
     *
     * @return on success: a cursor position pointed at the end of the buffer
     */
  }, {
    key: 'pushNewBuffer',
    value: _asyncToGenerator(function* (name, content) {
      var _this3 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        yield _this3.runSingleCommand(['reset', 'auto', // one of {ml, mli, auto}
        name]);

        var result = yield _this3.runSingleCommand(['tell', 'source', content]);
        resolve(result);
      }));
    })

    /**
     * Find definition
     *
     * `kind` is one of 'ml' or 'mli'
     *
     * Note: ocamlmerlin line numbers are 1-based.
     * @return null if nothing was found; a position of the form
     *   {"file": "somepath", "pos": {"line": 41, "col": 5}}.
     */
  }, {
    key: 'locate',
    value: _asyncToGenerator(function* (path, line, col, kind) {
      var _this4 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var location = yield _this4.runSingleCommand(['locate',
        /* identifier name */'', kind, 'at', { line: line + 1, col: col }]);

        if (typeof location === 'string') {
          return reject(Error(location));
        }

        // Ocamlmerlin doesn't include a `file` field at all if the destination is
        // in the same file.
        if (!location.file) {
          location.file = path;
        }

        resolve(location);
      }));
    })
  }, {
    key: 'complete',
    value: _asyncToGenerator(function* (path, line, col, prefix) {
      var _this5 = this;

      return yield this._promiseQueue.submit(_asyncToGenerator(function* (resolve, reject) {
        var result = yield _this5.runSingleCommand(['complete', 'prefix', prefix, 'at', { line: line + 1, col: col + 1 }]);

        resolve(result);
      }));
    })

    /**
     * Run a command; parse the json output, return an object. This assumes
     * that merlin's protocol is line-based (results are json objects rendered
     * on a single line).
     */
  }, {
    key: 'runSingleCommand',
    value: function runSingleCommand(command) {
      var logger = require('nuclide-logging').getLogger();

      var command = JSON.stringify(command);
      var stdin = this._proc.stdin;
      var stdout = this._proc.stdout;

      return new Promise(function (resolve, reject) {
        var readline = require('readline');
        var reader = readline.createInterface({
          input: stdout,
          terminal: false
        });

        reader.on('line', function (line) {
          reader.close();
          var response;
          try {
            response = JSON.parse(line);
          } catch (err) {
            response = null;
          }
          if (!response || !Array.isArray(response) || response.length !== 2) {
            logger.error('Unexpected response from ocamlmerlin: ${line}');
            reject(Error('Unexpected ocamlmerlin output format'));
            return;
          }

          var status = response[0];
          var content = response[1];

          if (ERROR_RESPONSES.has(status)) {
            logger.error('Ocamlmerlin raised an error: ' + line);
            reject(Error('Ocamlmerlin returned an error'));
            return;
          }

          resolve(content);
        });

        stdin.write(command);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._proc.kill();
    }
  }]);

  return MerlinProcess;
})();

module.exports = MerlinProcess;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLW9jYW1sLWJhc2UvbGliL01lcmxpblByb2Nlc3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLENBQUM7O2VBYVMsT0FBTyxDQUFDLGlCQUFpQixDQUFDOztJQUExQyxZQUFZLFlBQVosWUFBWTs7QUFFakIsSUFBSSxlQUFlLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FDNUIsU0FBUyxFQUNULE9BQU8sRUFDUCxXQUFXLENBQ1osQ0FBQyxDQUFDOzs7Ozs7Ozs7OztJQVVHLGFBQWE7QUFLTixXQUxQLGFBQWEsQ0FLTCxJQUFnQyxFQUFFOzs7MEJBTDFDLGFBQWE7O0FBTWYsUUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsUUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ3hDLFFBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLFFBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxVQUFDLElBQUksRUFBRSxNQUFNLEVBQUs7QUFBRSxZQUFLLFFBQVEsR0FBRyxLQUFLLENBQUM7S0FBRSxDQUFDLENBQUM7R0FDckU7O2VBVkcsYUFBYTs7V0FZUixxQkFBUztBQUNoQixhQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7S0FDdEI7Ozs7Ozs7Ozs7Ozs2QkFVc0IsV0FBQyxJQUFnQixFQUFrQjs7O0FBQ3hELGFBQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sbUJBQUMsV0FBTyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQ2hFLFlBQUksTUFBTSxHQUFHLE1BQU0sT0FBSyxnQkFBZ0IsQ0FBQyxDQUN2QyxPQUFPLEVBQ1AsWUFBWSxFQUNaLENBQUMsSUFBSSxDQUFDLEVBQ04sTUFBTSxDQUNQLENBQUMsQ0FBQztBQUNILGVBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUNqQixFQUFDLENBQUM7S0FDSjs7Ozs7Ozs7Ozs7NkJBU2tCLFdBQUMsSUFBZ0IsRUFBRSxPQUFPLEVBQWtCOzs7QUFDN0QsYUFBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxtQkFBQyxXQUFPLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDaEUsY0FBTSxPQUFLLGdCQUFnQixDQUFDLENBQzFCLE9BQU8sRUFDUCxNQUFNO0FBQ04sWUFBSSxDQUNMLENBQUMsQ0FBQzs7QUFFSCxZQUFJLE1BQU0sR0FBRyxNQUFNLE9BQUssZ0JBQWdCLENBQUMsQ0FDdkMsTUFBTSxFQUNOLFFBQVEsRUFDUixPQUFPLENBQ1IsQ0FBQyxDQUFDO0FBQ0gsZUFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQ2pCLEVBQUMsQ0FBQztLQUNKOzs7Ozs7Ozs7Ozs7OzZCQVdXLFdBQUMsSUFBZ0IsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBa0I7OztBQUM5RCxhQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLG1CQUFDLFdBQU8sT0FBTyxFQUFFLE1BQU0sRUFBSztBQUNoRSxZQUFJLFFBQVEsR0FBRyxNQUFNLE9BQUssZ0JBQWdCLENBQUMsQ0FDekMsUUFBUTs2QkFDYyxFQUFFLEVBQ3hCLElBQUksRUFDSixJQUFJLEVBQ0osRUFBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUgsR0FBRyxFQUFDLENBQ3RCLENBQUMsQ0FBQzs7QUFHSCxZQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtBQUNoQyxpQkFBTyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDaEM7Ozs7QUFJRCxZQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtBQUNsQixrQkFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7U0FDdEI7O0FBRUQsZUFBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ25CLEVBQUMsQ0FBQztLQUNKOzs7NkJBRWEsV0FBQyxJQUFnQixFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFrQjs7O0FBQ2xFLGFBQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sbUJBQUMsV0FBTyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQy9ELFlBQUksTUFBTSxHQUFHLE1BQU0sT0FBSyxnQkFBZ0IsQ0FBQyxDQUN0QyxVQUFVLEVBQ1YsUUFBUSxFQUNSLE1BQU0sRUFDTixJQUFJLEVBQ0osRUFBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBQyxDQUNoQyxDQUFDLENBQUM7O0FBRUgsZUFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQ2xCLEVBQUMsQ0FBQztLQUNKOzs7Ozs7Ozs7V0FRZSwwQkFBQyxPQUFjLEVBQWtCO0FBQy9DLFVBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDOztBQUVwRCxVQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3RDLFVBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQzdCLFVBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDOztBQUUvQixhQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUN0QyxZQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsWUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQztBQUNwQyxlQUFLLEVBQUUsTUFBTTtBQUNiLGtCQUFRLEVBQUUsS0FBSztTQUNoQixDQUFDLENBQUM7O0FBRUgsY0FBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBQyxJQUFJLEVBQUs7QUFDMUIsZ0JBQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUNmLGNBQUksUUFBUSxDQUFDO0FBQ2IsY0FBSTtBQUNGLG9CQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztXQUM3QixDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ1osb0JBQVEsR0FBRyxJQUFJLENBQUM7V0FDakI7QUFDRCxjQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNsRSxrQkFBTSxDQUFDLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0FBQzlELGtCQUFNLENBQUMsS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUMsQ0FBQztBQUN0RCxtQkFBTztXQUNSOztBQUVELGNBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QixjQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRTFCLGNBQUksZUFBZSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUMvQixrQkFBTSxDQUFDLEtBQUssQ0FBQywrQkFBK0IsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNyRCxrQkFBTSxDQUFDLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLENBQUM7QUFDL0MsbUJBQU87V0FDUjs7QUFFRCxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2xCLENBQUMsQ0FBQzs7QUFFSCxhQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ3RCLENBQUMsQ0FBQztLQUNKOzs7V0FFTSxtQkFBRztBQUNSLFVBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDbkI7OztTQWhLRyxhQUFhOzs7QUFtS25CLE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLW9jYW1sLWJhc2UvbGliL01lcmxpblByb2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7TnVjbGlkZVVyaX0gZnJvbSAnbnVjbGlkZS1yZW1vdGUtdXJpJztcblxudmFyIHtQcm9taXNlUXVldWV9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG5cbnZhciBFUlJPUl9SRVNQT05TRVMgPSBuZXcgU2V0KFtcbiAgJ2ZhaWx1cmUnLFxuICAnZXJyb3InLFxuICAnZXhjZXB0aW9uJyxcbl0pO1xuXG4vKipcbiAqIFdyYXBzIGFuIG9jYW1sbWVybGluIHByb2Nlc3M7IHByb3ZpZGVzIGFwaSBhY2Nlc3MgdG9cbiAqIG9jYW1sbWVybGluJ3MganNvbi1vdmVyLXN0ZGluL3N0ZG91dCBwcm90b2NvbC5cbiAqXG4gKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBwcm90b2NvbCBkZXNjcmlwdGlvbiBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RoZS1sYW1iZGEtY2h1cmNoL21lcmxpbi9ibG9iL21hc3Rlci9QUk9UT0NPTC5tZFxuICogICBodHRwczovL2dpdGh1Yi5jb20vdGhlLWxhbWJkYS1jaHVyY2gvbWVybGluL3RyZWUvbWFzdGVyL3NyYy9mcm9udGVuZFxuICovXG5jbGFzcyBNZXJsaW5Qcm9jZXNzIHtcbiAgX3Byb2M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzO1xuICBfcHJvbWlzZVF1ZXVlOiBQcm9taXNlUXVldWU7XG4gIF9ydW5uaW5nOiBib29sO1xuXG4gIGNvbnN0cnVjdG9yKHByb2M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzKSB7XG4gICAgdGhpcy5fcHJvYyA9IHByb2M7XG4gICAgdGhpcy5fcHJvbWlzZVF1ZXVlID0gbmV3IFByb21pc2VRdWV1ZSgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7IHRoaXMuX3J1bm5pbmcgPSBmYWxzZTsgfSk7XG4gIH1cblxuICBpc1J1bm5pbmcoKTogYm9vbCB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG4gIH1cblxuICAvKipcbiAgICogVGVsbCBtZXJsaW4gd2hlcmUgdG8gZmluZCBpdHMgcGVyLXJlcG8gLm1lcmxpbiBjb25maWcgZmlsZS5cbiAgICpcbiAgICogQ29uZmlndXJhdGlvbiBmaWxlIGZvcm1hdCBkZXNjcmlwdGlvbjpcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vdGhlLWxhbWJkYS1jaHVyY2gvbWVybGluL3dpa2kvcHJvamVjdC1jb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4gYSBkdW1teSBjdXJzb3IgcG9zaXRpb24gb24gc3VjY2Vzc1xuICAgKi9cbiAgYXN5bmMgcHVzaERvdE1lcmxpblBhdGgocGF0aDogTnVjbGlkZVVyaSk6IFByb21pc2U8bWl4ZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcHJvbWlzZVF1ZXVlLnN1Ym1pdChhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ3Jlc2V0JyxcbiAgICAgICAgJ2RvdF9tZXJsaW4nLFxuICAgICAgICBbcGF0aF0sXG4gICAgICAgICdhdXRvJyxcbiAgICAgIF0pO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYnVmZmVyIGNvbnRlbnQgdG8gcXVlcnkgYWdhaW5zdC4gTWVybGluIHVzZXMgYW4gaW50ZXJuYWxcbiAgICogYnVmZmVyIChuYW1lICsgY29udGVudCkgdGhhdCBpcyBpbmRlcGVuZGVudCBmcm9tIGZpbGUgY29udGVudCBvblxuICAgKiBkaXNrLlxuICAgKlxuICAgKiBAcmV0dXJuIG9uIHN1Y2Nlc3M6IGEgY3Vyc29yIHBvc2l0aW9uIHBvaW50ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAqL1xuICBhc3luYyBwdXNoTmV3QnVmZmVyKG5hbWU6IE51Y2xpZGVVcmksIGNvbnRlbnQpOiBQcm9taXNlPG1peGVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb21pc2VRdWV1ZS5zdWJtaXQoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ3Jlc2V0JyxcbiAgICAgICAgJ2F1dG8nLCAvLyBvbmUgb2Yge21sLCBtbGksIGF1dG99XG4gICAgICAgIG5hbWUsXG4gICAgICBdKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuU2luZ2xlQ29tbWFuZChbXG4gICAgICAgICd0ZWxsJyxcbiAgICAgICAgJ3NvdXJjZScsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICBdKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGRlZmluaXRpb25cbiAgICpcbiAgICogYGtpbmRgIGlzIG9uZSBvZiAnbWwnIG9yICdtbGknXG4gICAqXG4gICAqIE5vdGU6IG9jYW1sbWVybGluIGxpbmUgbnVtYmVycyBhcmUgMS1iYXNlZC5cbiAgICogQHJldHVybiBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kOyBhIHBvc2l0aW9uIG9mIHRoZSBmb3JtXG4gICAqICAge1wiZmlsZVwiOiBcInNvbWVwYXRoXCIsIFwicG9zXCI6IHtcImxpbmVcIjogNDEsIFwiY29sXCI6IDV9fS5cbiAgICovXG4gIGFzeW5jIGxvY2F0ZShwYXRoOiBOdWNsaWRlVXJpLCBsaW5lLCBjb2wsIGtpbmQpOiBQcm9taXNlPG1peGVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Byb21pc2VRdWV1ZS5zdWJtaXQoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIGxvY2F0aW9uID0gYXdhaXQgdGhpcy5ydW5TaW5nbGVDb21tYW5kKFtcbiAgICAgICAgJ2xvY2F0ZScsXG4gICAgICAgIC8qIGlkZW50aWZpZXIgbmFtZSAqLyAnJyxcbiAgICAgICAga2luZCxcbiAgICAgICAgJ2F0JyxcbiAgICAgICAge2xpbmU6IGxpbmUgKyAxLCBjb2x9LFxuICAgICAgXSk7XG5cblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChFcnJvcihsb2NhdGlvbikpO1xuICAgICAgfVxuXG4gICAgICAvLyBPY2FtbG1lcmxpbiBkb2Vzbid0IGluY2x1ZGUgYSBgZmlsZWAgZmllbGQgYXQgYWxsIGlmIHRoZSBkZXN0aW5hdGlvbiBpc1xuICAgICAgLy8gaW4gdGhlIHNhbWUgZmlsZS5cbiAgICAgIGlmICghbG9jYXRpb24uZmlsZSkge1xuICAgICAgICBsb2NhdGlvbi5maWxlID0gcGF0aDtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjb21wbGV0ZShwYXRoOiBOdWNsaWRlVXJpLCBsaW5lLCBjb2wsIHByZWZpeCk6IFByb21pc2U8bWl4ZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcHJvbWlzZVF1ZXVlLnN1Ym1pdChhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuU2luZ2xlQ29tbWFuZChbXG4gICAgICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICAgICAncHJlZml4JyxcbiAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgJ2F0JyxcbiAgICAgICAgICB7bGluZTogbGluZSArIDEsIGNvbDogY29sICsgMX0sXG4gICAgICAgXSk7XG5cbiAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSdW4gYSBjb21tYW5kOyBwYXJzZSB0aGUganNvbiBvdXRwdXQsIHJldHVybiBhbiBvYmplY3QuIFRoaXMgYXNzdW1lc1xuICAgKiB0aGF0IG1lcmxpbidzIHByb3RvY29sIGlzIGxpbmUtYmFzZWQgKHJlc3VsdHMgYXJlIGpzb24gb2JqZWN0cyByZW5kZXJlZFxuICAgKiBvbiBhIHNpbmdsZSBsaW5lKS5cbiAgICovXG4gIHJ1blNpbmdsZUNvbW1hbmQoY29tbWFuZDogbWl4ZWQpOiBQcm9taXNlPG1peGVkPiB7XG4gICAgdmFyIGxvZ2dlciA9IHJlcXVpcmUoJ251Y2xpZGUtbG9nZ2luZycpLmdldExvZ2dlcigpO1xuXG4gICAgdmFyIGNvbW1hbmQgPSBKU09OLnN0cmluZ2lmeShjb21tYW5kKTtcbiAgICB2YXIgc3RkaW4gPSB0aGlzLl9wcm9jLnN0ZGluO1xuICAgIHZhciBzdGRvdXQgPSB0aGlzLl9wcm9jLnN0ZG91dDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgcmVhZGxpbmUgPSByZXF1aXJlKCdyZWFkbGluZScpO1xuICAgICAgdmFyIHJlYWRlciA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZSh7XG4gICAgICAgIGlucHV0OiBzdGRvdXQsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICByZWFkZXIub24oJ2xpbmUnLCAobGluZSkgPT4ge1xuICAgICAgICByZWFkZXIuY2xvc2UoKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgIUFycmF5LmlzQXJyYXkocmVzcG9uc2UpIHx8IHJlc3BvbnNlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIG9jYW1sbWVybGluOiAke2xpbmV9Jyk7XG4gICAgICAgICAgcmVqZWN0KEVycm9yKCdVbmV4cGVjdGVkIG9jYW1sbWVybGluIG91dHB1dCBmb3JtYXQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB2YXIgY29udGVudCA9IHJlc3BvbnNlWzFdO1xuXG4gICAgICAgIGlmIChFUlJPUl9SRVNQT05TRVMuaGFzKHN0YXR1cykpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ09jYW1sbWVybGluIHJhaXNlZCBhbiBlcnJvcjogJyArIGxpbmUpO1xuICAgICAgICAgIHJlamVjdChFcnJvcignT2NhbWxtZXJsaW4gcmV0dXJuZWQgYW4gZXJyb3InKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShjb250ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICBzdGRpbi53cml0ZShjb21tYW5kKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcHJvYy5raWxsKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXJsaW5Qcm9jZXNzO1xuIl19
