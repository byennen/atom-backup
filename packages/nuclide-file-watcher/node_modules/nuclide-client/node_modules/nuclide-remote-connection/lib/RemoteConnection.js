
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { var callNext = step.bind(null, 'next'); var callThrow = step.bind(null, 'throw'); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(callNext, callThrow); } } callNext(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = require('atom');

var CompositeDisposable = _require.CompositeDisposable;
var Disposable = _require.Disposable;

var remoteUri = require('nuclide-remote-uri');
var logger = require('nuclide-logging').getLogger();

var _require2 = require('events');

var EventEmitter = _require2.EventEmitter;

var RemoteFile = require('./RemoteFile');
var RemoteDirectory = require('./RemoteDirectory');
var NuclideClient = require('nuclide-server/lib/NuclideClient');
var NuclideRemoteEventbus = require('nuclide-server/lib/NuclideRemoteEventbus');

var _require3 = require('nuclide-commons');

var fsPromise = _require3.fsPromise;

var _require4 = require('nuclide-version');

var getVersion = _require4.getVersion;

var HEARTBEAT_AWAY_REPORT_COUNT = 3;
var HEARTBEAT_NOTIFICATION_ERROR = 1;
var HEARTBEAT_NOTIFICATION_WARNING = 2;

// key for https connection.

var _connections = [];
var _emitter = new EventEmitter();

var RemoteConnection = (function () {
  function RemoteConnection(config) {
    _classCallCheck(this, RemoteConnection);

    this._subscriptions = new CompositeDisposable();
    this._entries = {};
    this._config = config;
    this._heartbeatNetworkAwayCount = 0;
    this._closed = false;
  }

  // Expose local variables for testability.

  _createClass(RemoteConnection, [{
    key: 'dispose',
    value: function dispose() {
      this._subscriptions.dispose();
    }

    // A workaround before Atom 2.0: Atom's Project::setPaths currently uses
    // ::repositoryForDirectorySync, so we need the repo information to already be
    // available when the new path is added. t6913624 tracks cleanup of this.
  }, {
    key: '_setHgRepoInfo',
    value: _asyncToGenerator(function* () {
      var eventBus = this.getClient().eventbus;
      var remotePath = this.getPathForInitialWorkingDirectory();
      var hgRepoDescription = yield eventBus.callMethod(
      /*serviceName*/'sourceControl',
      /*methodName*/'getHgRepository',
      /*methodArgs*/[remotePath],
      /*extraOptions*/{ method: 'POST', json: true });
      this._setHgRepositoryDescription(hgRepoDescription);
    })
  }, {
    key: '_monitorConnectionHeartbeat',
    value: function _monitorConnectionHeartbeat() {
      var _this = this;

      var socket = this.getClient().eventbus.socket;
      var serverUri = socket.getServerUri();

      /**
       * Adds an Atom notification for the detected heartbeat network status
       * The function makes sure not to add many notifications for the same event and prioritize new events.
       */
      var addHeartbeatNotification = function addHeartbeatNotification(type, errorCode, message, dismissable) {
        var _ref = _this._lastHeartbeatNotification || {};

        var code = _ref.code;
        var existingNotification = _ref.notification;

        if (code && code === errorCode && dismissable) {
          // A dismissible heartbeat notification with this code is already active.
          return;
        }
        var notification = null;
        switch (type) {
          case HEARTBEAT_NOTIFICATION_ERROR:
            notification = atom.notifications.addError(message, { dismissable: dismissable });
            break;
          case HEARTBEAT_NOTIFICATION_WARNING:
            notification = atom.notifications.addWarning(message, { dismissable: dismissable });
            break;
          default:
            throw new Error('Unrecongnized heartbeat notification type');
        }
        if (existingNotification) {
          existingNotification.dismiss();
        }
        _this._lastHeartbeatNotification = {
          notification: notification,
          code: errorCode
        };
      };

      var onHeartbeat = function onHeartbeat() {
        if (_this._lastHeartbeatNotification) {
          // If there has been existing heartbeat error/warning,
          // that means connection has been lost and we shall show a message about connection
          // being restored without a reconnect prompt.
          var notification = _this._lastHeartbeatNotification.notification;

          notification.dismiss();
          atom.notifications.addSuccess('Connection restored to Nuclide Server at: ' + serverUri);
          _this._heartbeatNetworkAwayCount = 0;
          _this._lastHeartbeatNotification = null;
        }
      };

      var notifyNetworkAway = function notifyNetworkAway(code) {
        _this._heartbeatNetworkAwayCount++;
        if (_this._heartbeatNetworkAwayCount >= HEARTBEAT_AWAY_REPORT_COUNT) {
          addHeartbeatNotification(HEARTBEAT_NOTIFICATION_WARNING, code, 'Nuclide server can not be reached at: ' + serverUri + '<br/>Check your network connection!',
          /*dismissable*/true);
        }
      };

      var onHeartbeatError = function onHeartbeatError(error) {
        var code = error.code;
        var message = error.message;
        var originalCode = error.originalCode;

        logger.info('Heartbeat network error:', code, originalCode, message);
        switch (code) {
          case 'NETWORK_AWAY':
            // Notify switching networks, disconnected, timeout, unreachable server or fragile connection.
            notifyNetworkAway(code);
            break;
          case 'SERVER_CRASHED':
            // Server shut down or port no longer accessible.
            // Notify the server was there, but now gone.
            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Nuclide server crashed!<br/>' + 'Please reload Nuclide to restore your remote project connection! : (⌃-⌥-⌘-L)',
            /*dismissable*/true);
            // TODO(most) reconnect RemoteConnection, restore the current project state,
            // and finally change dismissable to false and type to 'WARNING'.
            break;
          case 'PORT_NOT_ACCESSIBLE':
            // Notify never heard a heartbeat from the server.

            var _remoteUri$parse = remoteUri.parse(serverUri),
                port = _remoteUri$parse.port;

            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Nuclide server is not reachable.<br/>It could be running on a port that is not accessible: ' + port,
            /*dismissable*/true);
            break;
          case 'INVALID_CERTIFICATE':
            // Notify the client certificate is not accepted by nuclide server (certificate mismatch).
            addHeartbeatNotification(HEARTBEAT_NOTIFICATION_ERROR, code, 'Connection Reset Error!!<br/>This could be caused by the client certificate mismatching the server certificate.<br/>' + 'Please reload Nuclide to restore your remote project connection! : (⌃-⌥-⌘-L)',
            /*dismissable*/true);
            // TODO(most): reconnect RemoteConnection, restore the current project state.
            // and finally change dismissable to false and type to 'WARNING'.
            break;
          default:
            notifyNetworkAway(code);
            logger.error('Unrecongnized heartbeat error code: ' + code, message);
            break;
        }
      };
      socket.on('heartbeat', onHeartbeat);
      socket.on('heartbeat.error', onHeartbeatError);

      this._subscriptions.add(new Disposable(function () {
        socket.removeListener('heartbeat', onHeartbeat);
        socket.removeListener('heartbeat.error', onHeartbeatError);
      }));
    }
  }, {
    key: 'getUriOfRemotePath',
    value: function getUriOfRemotePath(remotePath) {
      return 'nuclide://' + this.getRemoteHost() + remotePath;
    }
  }, {
    key: 'getPathOfUri',
    value: function getPathOfUri(uri) {
      return remoteUri.parse(uri).path;
    }
  }, {
    key: 'createDirectory',
    value: function createDirectory(uri) {
      var _remoteUri$parse2 = remoteUri.parse(uri);

      var path = _remoteUri$parse2.path;

      path = require('path').normalize(path);

      var entry = this._entries[path];
      if (!entry || entry.getLocalPath() !== path) {
        this._entries[path] = entry = new RemoteDirectory(this, this.getUriOfRemotePath(path), { hgRepositoryDescription: this._hgRepositoryDescription });
        // TODO: We should add the following line to keep the cache up-to-date.
        // We need to implement onDidRename and onDidDelete in RemoteDirectory
        // first. It's ok that we don't add the handlers for now since we have
        // the check `entry.getLocalPath() !== path` above.
        //
        // this._addHandlersForEntry(entry);
      }

      if (!entry.isDirectory()) {
        throw new Error('Path is not a directory:' + uri);
      }

      return entry;
    }

    // A workaround before Atom 2.0: see ::getHgRepoInfo of main.js.
  }, {
    key: '_setHgRepositoryDescription',
    value: function _setHgRepositoryDescription(hgRepositoryDescription) {
      this._hgRepositoryDescription = hgRepositoryDescription;
    }
  }, {
    key: 'createFile',
    value: function createFile(uri) {
      var _remoteUri$parse3 = remoteUri.parse(uri);

      var path = _remoteUri$parse3.path;

      path = require('path').normalize(path);

      var entry = this._entries[path];
      if (!entry || entry.getLocalPath() !== path) {
        this._entries[path] = entry = new RemoteFile(this, this.getUriOfRemotePath(path));
        this._addHandlersForEntry(entry);
      }

      if (entry.isDirectory()) {
        throw new Error('Path is not a file');
      }

      return entry;
    }
  }, {
    key: '_addHandlersForEntry',
    value: function _addHandlersForEntry(entry) {
      var _this2 = this;

      var oldPath = entry.getLocalPath();
      var renameSubscription = entry.onDidRename(function () {
        delete _this2._entries[oldPath];
        _this2._entries[entry.getLocalPath()] = entry;
      });
      var deleteSubscription = entry.onDidDelete(function () {
        delete _this2._entries[entry.getLocalPath()];
        renameSubscription.dispose();
        deleteSubscription.dispose();
      });
    }
  }, {
    key: 'initialize',
    value: _asyncToGenerator(function* () {
      // Right now we don't re-handshake.
      if (this._initialized === undefined) {
        this._initialized = false;
        // Do version check.
        var client = this._getClient();
        var serverVersion;
        try {
          serverVersion = yield client.version();
        } catch (e) {
          client.close();
          throw e;
        }
        var clientVersion = getVersion();
        if (clientVersion != serverVersion) {
          client.close();
          throw new Error('Version mismatch. Client at ' + clientVersion + ' while server at ' + serverVersion + '.');
        }
        this._initialized = true;
        this._monitorConnectionHeartbeat();

        // Start watching the project for changes.
        client.watchDirectoryRecursive(this._config.cwd, /* do nothing on change */function () {})['catch'](function (err) {
          var warningMessage = 'Watcher failed to start - watcher features disabled!<br/>' + (err.message ? 'DETAILS: ' + err.message : '');
          // Add a persistent warning message to make sure the user sees it and intentionally dismissing it.
          atom.notifications.addWarning(warningMessage, { dismissable: true });
        });

        // A workaround before Atom 2.0: see ::getHgRepoInfo.
        yield this._setHgRepoInfo();

        // Save to cache.
        this._addConnection();
      }
    })
  }, {
    key: '_addConnection',
    value: function _addConnection() {
      _connections.push(this);
      _emitter.emit('did-add', this);
    }
  }, {
    key: 'close',
    value: function close() {
      // Close the eventbus that will stop the heartbeat interval, websocket reconnect trials, ..etc.
      if (this._client) {
        this._client.close();
        this._client = null;
      }
      if (!this._closed) {
        // Future getClient calls should fail, if it has a cached RemoteConnection instance.
        this._closed = true;
        // Remove from _connections to not be considered in future connection queries.
        _connections.splice(_connections.indexOf(this), 1);
        _emitter.emit('did-close', this);
      }
    }
  }, {
    key: 'getClient',
    value: function getClient() {
      if (!this._initialized) {
        throw new Error('Remote connection has not been initialized.');
      } else if (this._closed) {
        throw new Error('Remote connection has been closed.');
      } else {
        return this._getClient();
      }
    }
  }, {
    key: '_getClient',
    value: function _getClient() {
      if (!this._client) {
        var uri;
        var options = {};

        // Use https if we have key, cert, and ca
        if (this._isSecure()) {
          options.certificateAuthorityCertificate = this._config.certificateAuthorityCertificate;
          options.clientCertificate = this._config.clientCertificate;
          options.clientKey = this._config.clientKey;
          uri = 'https://' + this.getRemoteHost();
        } else {
          uri = 'http://' + this.getRemoteHost();
        }

        // The remote connection and client are identified by both the remote host and the inital working directory.
        var clientId = this.getRemoteHost() + this.getPathForInitialWorkingDirectory();
        this._client = new NuclideClient(clientId, new NuclideRemoteEventbus(uri, options), { cwd: this._config.cwd });
      }
      return this._client;
    }

    /**
     * Make rpc call through this connection given serviceUri in form of `$serviceName/$methodName`
     * and args as arguments list.
     */
  }, {
    key: 'makeRpc',
    value: function makeRpc(serviceUri, args, serviceOptions) {
      return this.getClient().makeRpc(serviceUri, args, serviceOptions);
    }
  }, {
    key: 'registerEventListener',
    value: function registerEventListener(eventName, callback, serviceOptions) {
      return this.getClient().registerEventListener(eventName, callback, serviceOptions);
    }
  }, {
    key: '_isSecure',
    value: function _isSecure() {
      return !!(this._config.certificateAuthorityCertificate && this._config.clientCertificate && this._config.clientKey);
    }
  }, {
    key: 'getRemoteHost',
    value: function getRemoteHost() {
      return this._config.host + ':' + this._config.port;
    }
  }, {
    key: 'getRemoteHostname',
    value: function getRemoteHostname() {
      return this._config.host;
    }
  }, {
    key: 'getUriForInitialWorkingDirectory',
    value: function getUriForInitialWorkingDirectory() {
      return this.getUriOfRemotePath(this.getPathForInitialWorkingDirectory());
    }
  }, {
    key: 'getPathForInitialWorkingDirectory',
    value: function getPathForInitialWorkingDirectory() {
      return this._config.cwd;
    }
  }, {
    key: 'getConfig',
    value: function getConfig() {
      return this._config;
    }
  }], [{
    key: 'onDidAddRemoteConnection',
    value: function onDidAddRemoteConnection(handler) {
      _emitter.on('did-add', handler);
      return new Disposable(function () {
        _emitter.removeListener('did-add', handler);
      });
    }
  }, {
    key: 'onDidCloseRemoteConnection',
    value: function onDidCloseRemoteConnection(handler) {
      _emitter.on('did-close', handler);
      return new Disposable(function () {
        _emitter.removeListener('did-close', handler);
      });
    }
  }, {
    key: 'getForUri',
    value: function getForUri(uri) {
      var _remoteUri$parse4 = remoteUri.parse(uri);

      var hostname = _remoteUri$parse4.hostname;
      var path = _remoteUri$parse4.path;

      return RemoteConnection.getByHostnameAndPath(hostname, path);
    }

    /**
     * Get cached connection match the hostname and the path has the prefix of connection.cwd.
     * @param hostname The connected server host name.
     * @param path The absolute path that's has the prefix of cwd of the connection.
     *   If path is null, empty or undefined, then return the connection which matches
     *   the hostname and ignore the initial working directory.
     */
  }, {
    key: 'getByHostnameAndPath',
    value: function getByHostnameAndPath(hostname, path) {
      return _connections.filter(function (connection) {
        return connection.getRemoteHostname() === hostname && (!path || path.startsWith(connection.getPathForInitialWorkingDirectory()));
      })[0];
    }
  }, {
    key: 'getByHostname',
    value: function getByHostname(hostname) {
      return _connections.filter(function (connection) {
        return connection.getRemoteHostname() === hostname;
      });
    }
  }]);

  return RemoteConnection;
})();

RemoteConnection.test = {
  connections: _connections
};

module.exports = RemoteConnection;
// host nuclide server is running on.
// port to connect to.
// Path to remote directory user should start in upon connection.
// certificate of certificate authority.
// client certificate for https connection.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9SZW1vdGVDb25uZWN0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztlQVc0QixPQUFPLENBQUMsTUFBTSxDQUFDOztJQUFsRCxtQkFBbUIsWUFBbkIsbUJBQW1CO0lBQUUsVUFBVSxZQUFWLFVBQVU7O0FBQ3BDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzlDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDOztnQkFDL0IsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7SUFBakMsWUFBWSxhQUFaLFlBQVk7O0FBRWpCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6QyxJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUNuRCxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUNoRSxJQUFJLHFCQUFxQixHQUFHLE9BQU8sQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDOztnQkFDOUQsT0FBTyxDQUFDLGlCQUFpQixDQUFDOztJQUF2QyxTQUFTLGFBQVQsU0FBUzs7Z0JBQ0ssT0FBTyxDQUFDLGlCQUFpQixDQUFDOztJQUF4QyxVQUFVLGFBQVYsVUFBVTs7QUFFZixJQUFNLDJCQUEyQixHQUFHLENBQUMsQ0FBQztBQUN0QyxJQUFNLDRCQUE0QixHQUFHLENBQUMsQ0FBQztBQUN2QyxJQUFNLDhCQUE4QixHQUFHLENBQUMsQ0FBQzs7OztBQWdCekMsSUFBSSxZQUFxQyxHQUFHLEVBQUUsQ0FBQztBQUMvQyxJQUFJLFFBQXNCLEdBQUcsSUFB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QVk7Q0FDMUIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDIiwiZmlsZSI6Ii92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLXJlbW90ZS1jb25uZWN0aW9uL2xpYi9SZW1vdGVDb25uZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHtDb21wb3NpdGVEaXNwb3NhYmxlLCBEaXNwb3NhYmxlfSA9IHJlcXVpcmUoJ2F0b20nKTtcbnZhciByZW1vdGVVcmkgPSByZXF1aXJlKCdudWNsaWRlLXJlbW90ZS11cmknKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCdudWNsaWRlLWxvZ2dpbmcnKS5nZXRMb2dnZXIoKTtcbnZhciB7RXZlbnRFbWl0dGVyfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgUmVtb3RlRmlsZSA9IHJlcXVpcmUoJy4vUmVtb3RlRmlsZScpO1xudmFyIFJlbW90ZURpcmVjdG9yeSA9IHJlcXVpcmUoJy4vUmVtb3RlRGlyZWN0b3J5Jyk7XG52YXIgTnVjbGlkZUNsaWVudCA9IHJlcXVpcmUoJ251Y2xpZGUtc2VydmVyL2xpYi9OdWNsaWRlQ2xpZW50Jyk7XG52YXIgTnVjbGlkZVJlbW90ZUV2ZW50YnVzID0gcmVxdWlyZSgnbnVjbGlkZS1zZXJ2ZXIvbGliL051Y2xpZGVSZW1vdGVFdmVudGJ1cycpO1xudmFyIHtmc1Byb21pc2V9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJyk7XG52YXIge2dldFZlcnNpb259ID0gcmVxdWlyZSgnbnVjbGlkZS12ZXJzaW9uJyk7XG5cbmNvbnN0IEhFQVJUQkVBVF9BV0FZX1JFUE9SVF9DT1VOVCA9IDM7XG5jb25zdCBIRUFSVEJFQVRfTk9USUZJQ0FUSU9OX0VSUk9SID0gMTtcbmNvbnN0IEhFQVJUQkVBVF9OT1RJRklDQVRJT05fV0FSTklORyA9IDI7XG5cbnR5cGUgSGVhcnRiZWF0Tm90aWZpY2F0aW9uID0ge1xuICBub3RpZmljYXRpb246IGF0b20kTm90aWZpY2F0aW9uO1xuICBjb2RlOiBzdHJpbmc7XG59XG5cbnR5cGUgUmVtb3RlQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIGhvc3Q6IHN0cmluZzsgLy8gaG9zdCBudWNsaWRlIHNlcnZlciBpcyBydW5uaW5nIG9uLlxuICBwb3J0OiBudW1iZXI7IC8vIHBvcnQgdG8gY29ubmVjdCB0by5cbiAgY3dkOiBzdHJpbmc7IC8vIFBhdGggdG8gcmVtb3RlIGRpcmVjdG9yeSB1c2VyIHNob3VsZCBzdGFydCBpbiB1cG9uIGNvbm5lY3Rpb24uXG4gIGNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGU/OiBCdWZmZXI7IC8vIGNlcnRpZmljYXRlIG9mIGNlcnRpZmljYXRlIGF1dGhvcml0eS5cbiAgY2xpZW50Q2VydGlmaWNhdGU/OiBCdWZmZXI7IC8vIGNsaWVudCBjZXJ0aWZpY2F0ZSBmb3IgaHR0cHMgY29ubmVjdGlvbi5cbiAgY2xpZW50S2V5PzogQnVmZmVyOyAvLyBrZXkgZm9yIGh0dHBzIGNvbm5lY3Rpb24uXG59XG5cbnZhciBfY29ubmVjdGlvbnM6IEFycmF5PFJlbW90ZUNvbm5lY3Rpb24+ID0gW107XG52YXIgX2VtaXR0ZXI6IEV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuY2xhc3MgUmVtb3RlQ29ubmVjdGlvbiB7XG4gIF9lbnRyaWVzOiB7W3BhdGg6IHN0cmluZ106IFJlbW90ZUZpbGV8UmVtb3RlRGlyZWN0b3J5fTtcbiAgX2NvbmZpZzogUmVtb3RlQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gIF9pbml0aWFsaXplZDogP2Jvb2w7XG4gIF9jbG9zZWQ6ID9ib29sO1xuICBfc3Vic2NyaXB0aW9uczogQ29tcG9zaXRlRGlzcG9zYWJsZTtcbiAgX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9uOiA/SGdSZXBvc2l0b3J5RGVzY3JpcHRpb247XG4gIF9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50OiBudW1iZXI7XG4gIF9sYXN0SGVhcnRiZWF0Tm90aWZpY2F0aW9uOiA/SGVhcnRiZWF0Tm90aWZpY2F0aW9uO1xuICBfY2xpZW50OiA/TnVjbGlkZUNsaWVudDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFJlbW90ZUNvbm5lY3Rpb25Db25maWd1cmF0aW9uKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgdGhpcy5fZW50cmllcyA9IHt9O1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50ID0gMDtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBBIHdvcmthcm91bmQgYmVmb3JlIEF0b20gMi4wOiBBdG9tJ3MgUHJvamVjdDo6c2V0UGF0aHMgY3VycmVudGx5IHVzZXNcbiAgLy8gOjpyZXBvc2l0b3J5Rm9yRGlyZWN0b3J5U3luYywgc28gd2UgbmVlZCB0aGUgcmVwbyBpbmZvcm1hdGlvbiB0byBhbHJlYWR5IGJlXG4gIC8vIGF2YWlsYWJsZSB3aGVuIHRoZSBuZXcgcGF0aCBpcyBhZGRlZC4gdDY5MTM2MjQgdHJhY2tzIGNsZWFudXAgb2YgdGhpcy5cbiAgYXN5bmMgX3NldEhnUmVwb0luZm8oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdmFyIGV2ZW50QnVzID0gdGhpcy5nZXRDbGllbnQoKS5ldmVudGJ1cztcbiAgICB2YXIgcmVtb3RlUGF0aCA9IHRoaXMuZ2V0UGF0aEZvckluaXRpYWxXb3JraW5nRGlyZWN0b3J5KCk7XG4gICAgdmFyIGhnUmVwb0Rlc2NyaXB0aW9uID0gYXdhaXQgZXZlbnRCdXMuY2FsbE1ldGhvZChcbiAgICAgIC8qc2VydmljZU5hbWUqLyAnc291cmNlQ29udHJvbCcsXG4gICAgICAvKm1ldGhvZE5hbWUqLyAnZ2V0SGdSZXBvc2l0b3J5JyxcbiAgICAgIC8qbWV0aG9kQXJncyovIFtyZW1vdGVQYXRoXSxcbiAgICAgIC8qZXh0cmFPcHRpb25zKi8ge21ldGhvZDogJ1BPU1QnLCBqc29uOiB0cnVlfVxuICAgICk7XG4gICAgdGhpcy5fc2V0SGdSZXBvc2l0b3J5RGVzY3JpcHRpb24oaGdSZXBvRGVzY3JpcHRpb24pO1xuICB9XG5cbiAgX21vbml0b3JDb25uZWN0aW9uSGVhcnRiZWF0KCkge1xuICAgIHZhciBzb2NrZXQgPSB0aGlzLmdldENsaWVudCgpLmV2ZW50YnVzLnNvY2tldDtcbiAgICB2YXIgc2VydmVyVXJpID0gc29ja2V0LmdldFNlcnZlclVyaSgpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBBdG9tIG5vdGlmaWNhdGlvbiBmb3IgdGhlIGRldGVjdGVkIGhlYXJ0YmVhdCBuZXR3b3JrIHN0YXR1c1xuICAgICAqIFRoZSBmdW5jdGlvbiBtYWtlcyBzdXJlIG5vdCB0byBhZGQgbWFueSBub3RpZmljYXRpb25zIGZvciB0aGUgc2FtZSBldmVudCBhbmQgcHJpb3JpdGl6ZSBuZXcgZXZlbnRzLlxuICAgICAqL1xuICAgIHZhciBhZGRIZWFydGJlYXROb3RpZmljYXRpb24gPSAodHlwZTogbnVtYmVyLCBlcnJvckNvZGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBkaXNtaXNzYWJsZTogYm9vbGVhbikgPT4ge1xuICAgICAgdmFyIHtjb2RlLCBub3RpZmljYXRpb246IGV4aXN0aW5nTm90aWZpY2F0aW9ufSA9IHRoaXMuX2xhc3RIZWFydGJlYXROb3RpZmljYXRpb24gfHwge307XG4gICAgICBpZiAoY29kZSAmJiBjb2RlID09PSBlcnJvckNvZGUgJiYgZGlzbWlzc2FibGUpIHtcbiAgICAgICAgLy8gQSBkaXNtaXNzaWJsZSBoZWFydGJlYXQgbm90aWZpY2F0aW9uIHdpdGggdGhpcyBjb2RlIGlzIGFscmVhZHkgYWN0aXZlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbm90aWZpY2F0aW9uID0gbnVsbDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEhFQVJUQkVBVF9OT1RJRklDQVRJT05fRVJST1I6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yKG1lc3NhZ2UsIHtkaXNtaXNzYWJsZX0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhFQVJUQkVBVF9OT1RJRklDQVRJT05fV0FSTklORzpcbiAgICAgICAgICBub3RpZmljYXRpb24gPSBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZyhtZXNzYWdlLCB7ZGlzbWlzc2FibGV9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb25nbml6ZWQgaGVhcnRiZWF0IG5vdGlmaWNhdGlvbiB0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24uZGlzbWlzcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdEhlYXJ0YmVhdE5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgbm90aWZpY2F0aW9uLFxuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgb25IZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fbGFzdEhlYXJ0YmVhdE5vdGlmaWNhdGlvbikge1xuICAgICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBleGlzdGluZyBoZWFydGJlYXQgZXJyb3Ivd2FybmluZyxcbiAgICAgICAgLy8gdGhhdCBtZWFucyBjb25uZWN0aW9uIGhhcyBiZWVuIGxvc3QgYW5kIHdlIHNoYWxsIHNob3cgYSBtZXNzYWdlIGFib3V0IGNvbm5lY3Rpb25cbiAgICAgICAgLy8gYmVpbmcgcmVzdG9yZWQgd2l0aG91dCBhIHJlY29ubmVjdCBwcm9tcHQuXG4gICAgICAgIHZhciB7bm90aWZpY2F0aW9ufSA9IHRoaXMuX2xhc3RIZWFydGJlYXROb3RpZmljYXRpb247XG4gICAgICAgIG5vdGlmaWNhdGlvbi5kaXNtaXNzKCk7XG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRTdWNjZXNzKCdDb25uZWN0aW9uIHJlc3RvcmVkIHRvIE51Y2xpZGUgU2VydmVyIGF0OiAnICsgc2VydmVyVXJpKTtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0TmV0d29ya0F3YXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RIZWFydGJlYXROb3RpZmljYXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbm90aWZ5TmV0d29ya0F3YXkgPSAoY29kZTogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXROZXR3b3JrQXdheUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5faGVhcnRiZWF0TmV0d29ya0F3YXlDb3VudCA+PSBIRUFSVEJFQVRfQVdBWV9SRVBPUlRfQ09VTlQpIHtcbiAgICAgICAgYWRkSGVhcnRiZWF0Tm90aWZpY2F0aW9uKEhFQVJUQkVBVF9OT1RJRklDQVRJT05fV0FSTklORywgY29kZSxcbiAgICAgICAgICAnTnVjbGlkZSBzZXJ2ZXIgY2FuIG5vdCBiZSByZWFjaGVkIGF0OiAnICsgc2VydmVyVXJpICtcbiAgICAgICAgICAnPGJyLz5DaGVjayB5b3VyIG5ldHdvcmsgY29ubmVjdGlvbiEnLFxuICAgICAgICAgIC8qZGlzbWlzc2FibGUqLyB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uSGVhcnRiZWF0RXJyb3IgPSAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgdmFyIHtjb2RlLCBtZXNzYWdlLCBvcmlnaW5hbENvZGV9ID0gZXJyb3I7XG4gICAgICBsb2dnZXIuaW5mbygnSGVhcnRiZWF0IG5ldHdvcmsgZXJyb3I6JywgY29kZSwgb3JpZ2luYWxDb2RlLCBtZXNzYWdlKTtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgJ05FVFdPUktfQVdBWSc6XG4gICAgICAgICAgICAvLyBOb3RpZnkgc3dpdGNoaW5nIG5ldHdvcmtzLCBkaXNjb25uZWN0ZWQsIHRpbWVvdXQsIHVucmVhY2hhYmxlIHNlcnZlciBvciBmcmFnaWxlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBub3RpZnlOZXR3b3JrQXdheShjb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1NFUlZFUl9DUkFTSEVEJzpcbiAgICAgICAgICAgIC8vIFNlcnZlciBzaHV0IGRvd24gb3IgcG9ydCBubyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgc2VydmVyIHdhcyB0aGVyZSwgYnV0IG5vdyBnb25lLlxuICAgICAgICAgICAgYWRkSGVhcnRiZWF0Tm90aWZpY2F0aW9uKEhFQVJUQkVBVF9OT1RJRklDQVRJT05fRVJST1IsIGNvZGUsXG4gICAgICAgICAgICAgICAgJ051Y2xpZGUgc2VydmVyIGNyYXNoZWQhPGJyLz4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHJlbG9hZCBOdWNsaWRlIHRvIHJlc3RvcmUgeW91ciByZW1vdGUgcHJvamVjdCBjb25uZWN0aW9uISA6ICjijIMt4oylLeKMmC1MKScsXG4gICAgICAgICAgICAgICAgLypkaXNtaXNzYWJsZSovIHRydWUpO1xuICAgICAgICAgICAgLy8gVE9ETyhtb3N0KSByZWNvbm5lY3QgUmVtb3RlQ29ubmVjdGlvbiwgcmVzdG9yZSB0aGUgY3VycmVudCBwcm9qZWN0IHN0YXRlLFxuICAgICAgICAgICAgLy8gYW5kIGZpbmFsbHkgY2hhbmdlIGRpc21pc3NhYmxlIHRvIGZhbHNlIGFuZCB0eXBlIHRvICdXQVJOSU5HJy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1BPUlRfTk9UX0FDQ0VTU0lCTEUnOlxuICAgICAgICAgICAgLy8gTm90aWZ5IG5ldmVyIGhlYXJkIGEgaGVhcnRiZWF0IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICAgIHZhciB7cG9ydH0gPSByZW1vdGVVcmkucGFyc2Uoc2VydmVyVXJpKTtcbiAgICAgICAgICAgIGFkZEhlYXJ0YmVhdE5vdGlmaWNhdGlvbihIRUFSVEJFQVRfTk9USUZJQ0FUSU9OX0VSUk9SLCBjb2RlLFxuICAgICAgICAgICAgICAgIGBOdWNsaWRlIHNlcnZlciBpcyBub3QgcmVhY2hhYmxlLjxici8+SXQgY291bGQgYmUgcnVubmluZyBvbiBhIHBvcnQgdGhhdCBpcyBub3QgYWNjZXNzaWJsZTogJHtwb3J0fWAsXG4gICAgICAgICAgICAgICAgLypkaXNtaXNzYWJsZSovIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSU5WQUxJRF9DRVJUSUZJQ0FURSc6XG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBpcyBub3QgYWNjZXB0ZWQgYnkgbnVjbGlkZSBzZXJ2ZXIgKGNlcnRpZmljYXRlIG1pc21hdGNoKS5cbiAgICAgICAgICAgIGFkZEhlYXJ0YmVhdE5vdGlmaWNhdGlvbihIRUFSVEJFQVRfTk9USUZJQ0FUSU9OX0VSUk9SLCBjb2RlLFxuICAgICAgICAgICAgICAgICdDb25uZWN0aW9uIFJlc2V0IEVycm9yISE8YnIvPlRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IHRoZSBjbGllbnQgY2VydGlmaWNhdGUgbWlzbWF0Y2hpbmcgdGhlIHNlcnZlciBjZXJ0aWZpY2F0ZS48YnIvPicgK1xuICAgICAgICAgICAgICAgICdQbGVhc2UgcmVsb2FkIE51Y2xpZGUgdG8gcmVzdG9yZSB5b3VyIHJlbW90ZSBwcm9qZWN0IGNvbm5lY3Rpb24hIDogKOKMgy3ijKUt4oyYLUwpJyxcbiAgICAgICAgICAgICAgICAvKmRpc21pc3NhYmxlKi8gdHJ1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPKG1vc3QpOiByZWNvbm5lY3QgUmVtb3RlQ29ubmVjdGlvbiwgcmVzdG9yZSB0aGUgY3VycmVudCBwcm9qZWN0IHN0YXRlLlxuICAgICAgICAgICAgLy8gYW5kIGZpbmFsbHkgY2hhbmdlIGRpc21pc3NhYmxlIHRvIGZhbHNlIGFuZCB0eXBlIHRvICdXQVJOSU5HJy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBub3RpZnlOZXR3b3JrQXdheShjb2RlKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5yZWNvbmduaXplZCBoZWFydGJlYXQgZXJyb3IgY29kZTogJyArIGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldC5vbignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuICAgIHNvY2tldC5vbignaGVhcnRiZWF0LmVycm9yJywgb25IZWFydGJlYXRFcnJvcik7XG5cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0LmVycm9yJywgb25IZWFydGJlYXRFcnJvcik7XG4gICAgfSkpO1xuICB9XG5cbiAgZ2V0VXJpT2ZSZW1vdGVQYXRoKHJlbW90ZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBudWNsaWRlOi8vJHt0aGlzLmdldFJlbW90ZUhvc3QoKX0ke3JlbW90ZVBhdGh9YDtcbiAgfVxuXG4gIGdldFBhdGhPZlVyaSh1cmk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlbW90ZVVyaS5wYXJzZSh1cmkpLnBhdGg7XG4gIH1cblxuICBjcmVhdGVEaXJlY3RvcnkodXJpOiBzdHJpbmcpOiA/UmVtb3RlRGlyZWN0b3J5IHtcbiAgICB2YXIge3BhdGh9ID0gcmVtb3RlVXJpLnBhcnNlKHVyaSk7XG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKS5ub3JtYWxpemUocGF0aCk7XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLl9lbnRyaWVzW3BhdGhdO1xuICAgIGlmICghZW50cnkgfHwgZW50cnkuZ2V0TG9jYWxQYXRoKCkgIT09IHBhdGgpIHtcbiAgICAgIHRoaXMuX2VudHJpZXNbcGF0aF0gPSBlbnRyeSA9IG5ldyBSZW1vdGVEaXJlY3RvcnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuZ2V0VXJpT2ZSZW1vdGVQYXRoKHBhdGgpLFxuICAgICAgICB7aGdSZXBvc2l0b3J5RGVzY3JpcHRpb246IHRoaXMuX2hnUmVwb3NpdG9yeURlc2NyaXB0aW9ufVxuICAgICAgKTtcbiAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBhZGQgdGhlIGZvbGxvd2luZyBsaW5lIHRvIGtlZXAgdGhlIGNhY2hlIHVwLXRvLWRhdGUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGltcGxlbWVudCBvbkRpZFJlbmFtZSBhbmQgb25EaWREZWxldGUgaW4gUmVtb3RlRGlyZWN0b3J5XG4gICAgICAvLyBmaXJzdC4gSXQncyBvayB0aGF0IHdlIGRvbid0IGFkZCB0aGUgaGFuZGxlcnMgZm9yIG5vdyBzaW5jZSB3ZSBoYXZlXG4gICAgICAvLyB0aGUgY2hlY2sgYGVudHJ5LmdldExvY2FsUGF0aCgpICE9PSBwYXRoYCBhYm92ZS5cbiAgICAgIC8vXG4gICAgICAvLyB0aGlzLl9hZGRIYW5kbGVyc0ZvckVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoIWVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBpcyBub3QgYSBkaXJlY3Rvcnk6JyArIHVyaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogc2VlIDo6Z2V0SGdSZXBvSW5mbyBvZiBtYWluLmpzLlxuICBfc2V0SGdSZXBvc2l0b3J5RGVzY3JpcHRpb24oaGdSZXBvc2l0b3J5RGVzY3JpcHRpb246IEhnUmVwb3NpdG9yeURlc2NyaXB0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5faGdSZXBvc2l0b3J5RGVzY3JpcHRpb24gPSBoZ1JlcG9zaXRvcnlEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGNyZWF0ZUZpbGUodXJpOiBzdHJpbmcpOiA/UmVtb3RlRmlsZSB7XG4gICAgdmFyIHtwYXRofSA9IHJlbW90ZVVyaS5wYXJzZSh1cmkpO1xuICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fZW50cmllc1twYXRoXTtcbiAgICBpZiAoIWVudHJ5IHx8IGVudHJ5LmdldExvY2FsUGF0aCgpICE9PSBwYXRoKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzW3BhdGhdID0gZW50cnkgPSBuZXcgUmVtb3RlRmlsZSh0aGlzLCB0aGlzLmdldFVyaU9mUmVtb3RlUGF0aChwYXRoKSk7XG4gICAgICB0aGlzLl9hZGRIYW5kbGVyc0ZvckVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGlzIG5vdCBhIGZpbGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICBfYWRkSGFuZGxlcnNGb3JFbnRyeShlbnRyeTogYXRvbSRGaWxlIHwgYXRvbSREaXJlY3RvcnkpOiB2b2lkIHtcbiAgICB2YXIgb2xkUGF0aCA9IGVudHJ5LmdldExvY2FsUGF0aCgpO1xuICAgIHZhciByZW5hbWVTdWJzY3JpcHRpb24gPSBlbnRyeS5vbkRpZFJlbmFtZSgoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fZW50cmllc1tvbGRQYXRoXTtcbiAgICAgIHRoaXMuX2VudHJpZXNbZW50cnkuZ2V0TG9jYWxQYXRoKCldID0gZW50cnk7XG4gICAgfSk7XG4gICAgdmFyIGRlbGV0ZVN1YnNjcmlwdGlvbiA9IGVudHJ5Lm9uRGlkRGVsZXRlKCgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9lbnRyaWVzW2VudHJ5LmdldExvY2FsUGF0aCgpXTtcbiAgICAgIHJlbmFtZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICBkZWxldGVTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBSaWdodCBub3cgd2UgZG9uJ3QgcmUtaGFuZHNoYWtlLlxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgLy8gRG8gdmVyc2lvbiBjaGVjay5cbiAgICAgIHZhciBjbGllbnQgPSB0aGlzLl9nZXRDbGllbnQoKTtcbiAgICAgIHZhciBzZXJ2ZXJWZXJzaW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VydmVyVmVyc2lvbiA9IGF3YWl0IGNsaWVudC52ZXJzaW9uKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNsaWVudC5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdmFyIGNsaWVudFZlcnNpb24gPSBnZXRWZXJzaW9uKCk7XG4gICAgICBpZiAoY2xpZW50VmVyc2lvbiAhPSBzZXJ2ZXJWZXJzaW9uKSB7XG4gICAgICAgIGNsaWVudC5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gbWlzbWF0Y2guIENsaWVudCBhdCAke2NsaWVudFZlcnNpb259IHdoaWxlIHNlcnZlciBhdCAke3NlcnZlclZlcnNpb259LmApO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fbW9uaXRvckNvbm5lY3Rpb25IZWFydGJlYXQoKTtcblxuICAgICAgLy8gU3RhcnQgd2F0Y2hpbmcgdGhlIHByb2plY3QgZm9yIGNoYW5nZXMuXG4gICAgICBjbGllbnQud2F0Y2hEaXJlY3RvcnlSZWN1cnNpdmUodGhpcy5fY29uZmlnLmN3ZCwgLyogZG8gbm90aGluZyBvbiBjaGFuZ2UgKi8oKSA9PiB7fSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gJ1dhdGNoZXIgZmFpbGVkIHRvIHN0YXJ0IC0gd2F0Y2hlciBmZWF0dXJlcyBkaXNhYmxlZCE8YnIvPicgK1xuICAgICAgICAgICAgKGVyci5tZXNzYWdlID8gKCdERVRBSUxTOiAnICsgZXJyLm1lc3NhZ2UpIDogJycpO1xuICAgICAgICAvLyBBZGQgYSBwZXJzaXN0ZW50IHdhcm5pbmcgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhlIHVzZXIgc2VlcyBpdCBhbmQgaW50ZW50aW9uYWxseSBkaXNtaXNzaW5nIGl0LlxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZyh3YXJuaW5nTWVzc2FnZSwge2Rpc21pc3NhYmxlOiB0cnVlfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQSB3b3JrYXJvdW5kIGJlZm9yZSBBdG9tIDIuMDogc2VlIDo6Z2V0SGdSZXBvSW5mby5cbiAgICAgIGF3YWl0IHRoaXMuX3NldEhnUmVwb0luZm8oKTtcblxuICAgICAgLy8gU2F2ZSB0byBjYWNoZS5cbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBfYWRkQ29ubmVjdGlvbigpIHtcbiAgICBfY29ubmVjdGlvbnMucHVzaCh0aGlzKTtcbiAgICBfZW1pdHRlci5lbWl0KCdkaWQtYWRkJywgdGhpcyk7XG4gIH1cblxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbG9zZSB0aGUgZXZlbnRidXMgdGhhdCB3aWxsIHN0b3AgdGhlIGhlYXJ0YmVhdCBpbnRlcnZhbCwgd2Vic29ja2V0IHJlY29ubmVjdCB0cmlhbHMsIC4uZXRjLlxuICAgIGlmICh0aGlzLl9jbGllbnQpIHtcbiAgICAgIHRoaXMuX2NsaWVudC5jbG9zZSgpO1xuICAgICAgdGhpcy5fY2xpZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIC8vIEZ1dHVyZSBnZXRDbGllbnQgY2FsbHMgc2hvdWxkIGZhaWwsIGlmIGl0IGhhcyBhIGNhY2hlZCBSZW1vdGVDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIF9jb25uZWN0aW9ucyB0byBub3QgYmUgY29uc2lkZXJlZCBpbiBmdXR1cmUgY29ubmVjdGlvbiBxdWVyaWVzLlxuICAgICAgX2Nvbm5lY3Rpb25zLnNwbGljZShfY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICBfZW1pdHRlci5lbWl0KCdkaWQtY2xvc2UnLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXRDbGllbnQoKTogTnVjbGlkZUNsaWVudCB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3RlIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2xpZW50KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldENsaWVudCgpOiBOdWNsaWRlQ2xpZW50IHtcbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgdmFyIHVyaTtcbiAgICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICAgIC8vIFVzZSBodHRwcyBpZiB3ZSBoYXZlIGtleSwgY2VydCwgYW5kIGNhXG4gICAgICBpZiAodGhpcy5faXNTZWN1cmUoKSkge1xuICAgICAgICBvcHRpb25zLmNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGUgPSB0aGlzLl9jb25maWcuY2VydGlmaWNhdGVBdXRob3JpdHlDZXJ0aWZpY2F0ZTtcbiAgICAgICAgb3B0aW9ucy5jbGllbnRDZXJ0aWZpY2F0ZSA9IHRoaXMuX2NvbmZpZy5jbGllbnRDZXJ0aWZpY2F0ZTtcbiAgICAgICAgb3B0aW9ucy5jbGllbnRLZXkgPSB0aGlzLl9jb25maWcuY2xpZW50S2V5O1xuICAgICAgICB1cmkgPSBgaHR0cHM6Ly8ke3RoaXMuZ2V0UmVtb3RlSG9zdCgpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBgaHR0cDovLyR7dGhpcy5nZXRSZW1vdGVIb3N0KCl9YDtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlbW90ZSBjb25uZWN0aW9uIGFuZCBjbGllbnQgYXJlIGlkZW50aWZpZWQgYnkgYm90aCB0aGUgcmVtb3RlIGhvc3QgYW5kIHRoZSBpbml0YWwgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICB2YXIgY2xpZW50SWQgPSB0aGlzLmdldFJlbW90ZUhvc3QoKSArIHRoaXMuZ2V0UGF0aEZvckluaXRpYWxXb3JraW5nRGlyZWN0b3J5KCk7XG4gICAgICB0aGlzLl9jbGllbnQgPSBuZXcgTnVjbGlkZUNsaWVudChjbGllbnRJZCwgbmV3IE51Y2xpZGVSZW1vdGVFdmVudGJ1cyh1cmksIG9wdGlvbnMpLCB7Y3dkOiB0aGlzLl9jb25maWcuY3dkfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBycGMgY2FsbCB0aHJvdWdoIHRoaXMgY29ubmVjdGlvbiBnaXZlbiBzZXJ2aWNlVXJpIGluIGZvcm0gb2YgYCRzZXJ2aWNlTmFtZS8kbWV0aG9kTmFtZWBcbiAgICogYW5kIGFyZ3MgYXMgYXJndW1lbnRzIGxpc3QuXG4gICAqL1xuICBtYWtlUnBjKHNlcnZpY2VVcmk6IHN0cmluZywgYXJnczogQXJyYXk8YW55Piwgc2VydmljZU9wdGlvbnM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50KCkubWFrZVJwYyhzZXJ2aWNlVXJpLCBhcmdzLCBzZXJ2aWNlT3B0aW9ucyk7XG4gIH1cblxuICByZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkLCBzZXJ2aWNlT3B0aW9uczogYW55KTogRGlzcG9zYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50KCkucmVnaXN0ZXJFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHNlcnZpY2VPcHRpb25zKTtcbiAgfVxuXG5cbiAgX2lzU2VjdXJlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgdGhpcy5fY29uZmlnLmNlcnRpZmljYXRlQXV0aG9yaXR5Q2VydGlmaWNhdGVcbiAgICAgICAgJiYgdGhpcy5fY29uZmlnLmNsaWVudENlcnRpZmljYXRlXG4gICAgICAgICYmIHRoaXMuX2NvbmZpZy5jbGllbnRLZXlcbiAgICApO1xuICB9XG5cbiAgZ2V0UmVtb3RlSG9zdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLl9jb25maWcuaG9zdH06JHt0aGlzLl9jb25maWcucG9ydH1gO1xuICB9XG5cbiAgZ2V0UmVtb3RlSG9zdG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmhvc3Q7XG4gIH1cblxuICBnZXRVcmlGb3JJbml0aWFsV29ya2luZ0RpcmVjdG9yeSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldFVyaU9mUmVtb3RlUGF0aCh0aGlzLmdldFBhdGhGb3JJbml0aWFsV29ya2luZ0RpcmVjdG9yeSgpKTtcbiAgfVxuXG4gIGdldFBhdGhGb3JJbml0aWFsV29ya2luZ0RpcmVjdG9yeSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuY3dkO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IFJlbW90ZUNvbm5lY3Rpb25Db25maWd1cmF0aW9ue1xuICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gIH1cblxuICBzdGF0aWMgb25EaWRBZGRSZW1vdGVDb25uZWN0aW9uKGhhbmRsZXI6IChjb25uZWN0aW9uOiBSZW1vdGVDb25uZWN0aW9uKSA9PiB2b2lkKTogRGlzcG9zYWJsZSB7XG4gICAgX2VtaXR0ZXIub24oJ2RpZC1hZGQnLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgX2VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2RpZC1hZGQnLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBvbkRpZENsb3NlUmVtb3RlQ29ubmVjdGlvbihoYW5kbGVyOiAoY29ubmVjdGlvbjogUmVtb3RlQ29ubmVjdGlvbikgPT4gdm9pZCk6IERpc3Bvc2FibGUge1xuICAgIF9lbWl0dGVyLm9uKCdkaWQtY2xvc2UnLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgX2VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2RpZC1jbG9zZScsIGhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldEZvclVyaSh1cmk6IHN0cmluZyk6ID9SZW1vdGVDb25uZWN0aW9uIHtcbiAgICB2YXIge2hvc3RuYW1lLCBwYXRofSA9IHJlbW90ZVVyaS5wYXJzZSh1cmkpO1xuICAgIHJldHVybiBSZW1vdGVDb25uZWN0aW9uLmdldEJ5SG9zdG5hbWVBbmRQYXRoKGhvc3RuYW1lLCBwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY2FjaGVkIGNvbm5lY3Rpb24gbWF0Y2ggdGhlIGhvc3RuYW1lIGFuZCB0aGUgcGF0aCBoYXMgdGhlIHByZWZpeCBvZiBjb25uZWN0aW9uLmN3ZC5cbiAgICogQHBhcmFtIGhvc3RuYW1lIFRoZSBjb25uZWN0ZWQgc2VydmVyIGhvc3QgbmFtZS5cbiAgICogQHBhcmFtIHBhdGggVGhlIGFic29sdXRlIHBhdGggdGhhdCdzIGhhcyB0aGUgcHJlZml4IG9mIGN3ZCBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICogICBJZiBwYXRoIGlzIG51bGwsIGVtcHR5IG9yIHVuZGVmaW5lZCwgdGhlbiByZXR1cm4gdGhlIGNvbm5lY3Rpb24gd2hpY2ggbWF0Y2hlc1xuICAgKiAgIHRoZSBob3N0bmFtZSBhbmQgaWdub3JlIHRoZSBpbml0aWFsIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgKi9cbiAgc3RhdGljIGdldEJ5SG9zdG5hbWVBbmRQYXRoKGhvc3RuYW1lOiBzdHJpbmcsIHBhdGg6ID9zdHJpbmcpOiA/UmVtb3RlQ29ubmVjdGlvbiB7XG4gICAgcmV0dXJuIF9jb25uZWN0aW9ucy5maWx0ZXIoY29ubmVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbi5nZXRSZW1vdGVIb3N0bmFtZSgpID09PSBob3N0bmFtZSAmJlxuICAgICAgICAgICghcGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoY29ubmVjdGlvbi5nZXRQYXRoRm9ySW5pdGlhbFdvcmtpbmdEaXJlY3RvcnkoKSkpO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgc3RhdGljIGdldEJ5SG9zdG5hbWUoaG9zdG5hbWU6IHN0cmluZyk6IEFycmF5PFJlbW90ZUNvbm5lY3Rpb24+IHtcbiAgICByZXR1cm4gX2Nvbm5lY3Rpb25zLmZpbHRlcihjb25uZWN0aW9uID0+IGNvbm5lY3Rpb24uZ2V0UmVtb3RlSG9zdG5hbWUoKSA9PT0gaG9zdG5hbWUpO1xuICB9XG59XG5cbi8vIEV4cG9zZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRlc3RhYmlsaXR5LlxuUmVtb3RlQ29ubmVjdGlvbi50ZXN0ID0ge1xuICBjb25uZWN0aW9uczogX2Nvbm5lY3Rpb25zLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVDb25uZWN0aW9uO1xuIl19
