
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * Static method as defined by
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from.
 * @param arrayLike An array-like or iterable object to convert to an array.
 * @param mapFn Map function to call on every element of the array.
 * @param thisArg Value to use as `this` when executing `mapFn`.
 */
function from(_x3) {
  var _arguments = arguments;
  var _again = true;

  _function: while (_again) {
    var arrayLike = _x3;
    mapFn = thisArg = array = value = array = _arrayLike$next = done = value = undefined;
    var mapFn = _arguments.length <= 1 || _arguments[1] === undefined ? undefined : _arguments[1];
    _again = false;
    var thisArg = _arguments.length <= 2 || _arguments[2] === undefined ? undefined : _arguments[2];

    if (mapFn === undefined) {
      mapFn = function (arg) {
        return arg;
      };
    }

    // Note that Symbol is not defined when running on Node 0.10.x.
    if (typeof Symbol !== 'undefined' && typeof arrayLike === 'object' && typeof arrayLike[Symbol.iterator] === 'function') {
      var array = [];
      for (var value of arrayLike) {
        array.push(mapFn.call(thisArg, value));
      }
      return array;
    } else if (typeof arrayLike.next === 'function') {
      // See if arrayLike conforms to the iterator protocol. Note that on
      // Node 0.10.x, where we use es6-collections, things like Map.entries() and
      // Set.values() will fall into this case rather than the previous case.
      var array = [];
      while (true) {
        var _arrayLike$next = arrayLike.next();

        var done = _arrayLike$next.done;
        var value = _arrayLike$next.value;

        if (done) {
          break;
        } else {
          array.push(mapFn.call(thisArg, value));
        }
      }
      return array;
    } else if ('length' in arrayLike) {
      return Array.prototype.map.call(arrayLike, mapFn, thisArg);
    } else if (arrayLike instanceof Set) {
      // Backup logic to handle the es6-collections case.
      _arguments = [_x3 = arrayLike.values(), mapFn, thisArg];
      _again = true;
      continue _function;
    } else if (arrayLike instanceof Map) {
      // Backup logic to handle the es6-collections case.
      _arguments = [_x3 = arrayLike.entries(), mapFn, thisArg];
      _again = true;
      continue _function;
    } else {
      throw Error(arrayLike + ' must be an array-like or iterable object to convert to an array.');
    }
  }
}

/**
 * Instance method of Array as defined by
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find.
 * Because we do not want to add elements to Array.prototype, we make this a
 * static method that takes the Array (which would be the receiver if it were an
 * instance method) as the first argument.
 * @param array The array to search.
 * @param Function to execute on each value in the array.
 * @param Object to use as `this` when executing `callback`.
 */
function find(array, callback, thisArg) {
  var resultIndex = findIndex(array, callback, thisArg);
  return resultIndex >= 0 ? array[resultIndex] : undefined;
}

/**
 * Instance method of Array as defined by
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex.
 * Because we do not want to add elements to Array.prototype, we make this a
 * static method that takes the Array (which would be the receiver if it were an
 * instance method) as the first argument.
 * @param array The array to search.
 * @param Function to execute on each value in the array.
 * @param Object to use as `this` when executing `callback`.
 */
function findIndex(array, callback, thisArg) {
  var result = -1;
  array.some(function (element, index, array) {
    if (callback.call(thisArg, element, index, array)) {
      result = index;
      return true;
    } else {
      return false;
    }
  });
  return result;
}

function remove(array, element) {
  var index = array.indexOf(element);
  if (index >= 0) {
    array.splice(index, 1);
  }
}

module.exports = {
  find: find,
  findIndex: findIndex,
  from: from,
  remove: remove
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi92YXIvZm9sZGVycy94Zi9yc3BoNF9jNTczMTVyczU3eHhzZHNrcnhudjM2dDAvVC90bXBlbW0ySHVwdWJsaXNoX3BhY2thZ2VzL25wbS9udWNsaWRlLWNvbW1vbnMvbGliL2FycmF5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQlosU0FBUyxJQUFJOzs7OzRCQUEyRDtRQUExRCxTQUFTO0FBQUUsU0FBSyxHQUFjLE9BQU8sR0FTM0MsS0FBSyxHQUNBLEtBQUssR0FRVixLQUFLLHFCQUVGLElBQUksR0FBRSxLQUFLO1FBcEJHLEtBQUssMkRBQUcsU0FBUzs7UUFBRSxPQUFPLDJEQUFHLFNBQVM7O0FBQzdELFFBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtBQUN2QixXQUFLLEdBQUcsVUFBUyxHQUFHLEVBQUU7QUFBRSxlQUFPLEdBQUcsQ0FBQztPQUFFLENBQUM7S0FDdkM7OztBQUdELFFBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUM3QixPQUFPLFNBQVMsS0FBSyxRQUFRLElBQzdCLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDcEQsVUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsV0FBSyxJQUFJLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDM0IsYUFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO09BQ3hDO0FBQ0QsYUFBTyxLQUFLLENBQUM7S0FDZCxNQUFNLElBQUksT0FBTyxTQUFTLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTs7OztBQUkvQyxVQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixhQUFPLElBQUksRUFBRTs4QkFDUyxTQUFTLENBQUMsSUFBSSxFQUFFOztZQUEvQixJQUFJLG1CQUFKLElBQUk7WUFBRSxLQUFLLG1CQUFMLEtBQUs7O0FBQ2hCLFlBQUksSUFBSSxFQUFFO0FBQ1IsZ0JBQU07U0FDUCxNQUFNO0FBQ0wsZUFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO09BQ0Y7QUFDRCxhQUFPLEtBQUssQ0FBQztLQUNkLE1BQU0sSUFBSSxRQUFRLElBQUksU0FBUyxFQUFFO0FBQ2hDLGFBQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDNUQsTUFBTSxJQUFJLFNBQVMsWUFBWSxHQUFHLEVBQUU7OzBCQUV2QixTQUFTLENBQUMsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU87OztLQUMvQyxNQUFNLElBQUksU0FBUyxZQUFZLEdBQUcsRUFBRTs7MEJBRXZCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTzs7O0tBQ2hELE1BQU07QUFDTCxZQUFNLEtBQUssQ0FBQyxTQUFTLEdBQ2pCLG1FQUFtRSxDQUFDLENBQUM7S0FDMUU7R0FDRjtDQUFBOzs7Ozs7Ozs7Ozs7QUFZRCxTQUFTLElBQUksQ0FDVCxLQUFZLEVBQ1osUUFBNEQsRUFDNUQsT0FBYSxFQUFPO0FBQ3RCLE1BQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3RELFNBQU8sV0FBVyxJQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsU0FBUyxDQUFDO0NBQ3pEOzs7Ozs7Ozs7Ozs7QUFZRCxTQUFTLFNBQVMsQ0FDZCxLQUFZLEVBQ1osUUFBNEQsRUFDNUQsT0FBYSxFQUFPO0FBQ3RCLE1BQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hCLE9BQUssQ0FBQyxJQUFJLENBQUMsVUFBUyxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN6QyxRQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7QUFDakQsWUFBTSxHQUFHLEtBQUssQ0FBQztBQUNmLGFBQU8sSUFBSSxDQUFDO0tBQ2IsTUFBTTtBQUNMLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7R0FDRixDQUFDLENBQUM7QUFDSCxTQUFPLE1BQU0sQ0FBQztDQUNmOztBQUVELFNBQVMsTUFBTSxDQUFJLEtBQWUsRUFBRSxPQUFVLEVBQVE7QUFDcEQsTUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuQyxNQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7QUFDZCxTQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztHQUN4QjtDQUNGOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixNQUFJLEVBQUosSUFBSTtBQUNKLFdBQVMsRUFBVCxTQUFTO0FBQ1QsTUFBSSxFQUFKLElBQUk7QUFDSixRQUFNLEVBQU4sTUFBTTtDQUNQLENBQUMiLCJmaWxlIjoiL3Zhci9mb2xkZXJzL3hmL3JzcGg0X2M1NzMxNXJzNTd4eHNkc2tyeG52MzZ0MC9UL3RtcGVtbTJIdXB1Ymxpc2hfcGFja2FnZXMvbnBtL251Y2xpZGUtY29tbW9ucy9saWIvYXJyYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgYXMgZGVmaW5lZCBieVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZnJvbS5cbiAqIEBwYXJhbSBhcnJheUxpa2UgQW4gYXJyYXktbGlrZSBvciBpdGVyYWJsZSBvYmplY3QgdG8gY29udmVydCB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSBtYXBGbiBNYXAgZnVuY3Rpb24gdG8gY2FsbCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYG1hcEZuYC5cbiAqL1xuZnVuY3Rpb24gZnJvbShhcnJheUxpa2UsIG1hcEZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKTogQXJyYXkge1xuICBpZiAobWFwRm4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcEZuID0gZnVuY3Rpb24oYXJnKSB7IHJldHVybiBhcmc7IH07XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgU3ltYm9sIGlzIG5vdCBkZWZpbmVkIHdoZW4gcnVubmluZyBvbiBOb2RlIDAuMTAueC5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgYXJyYXlMaWtlID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIGFycmF5TGlrZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgdmFsdWUgb2YgYXJyYXlMaWtlKSB7XG4gICAgICBhcnJheS5wdXNoKG1hcEZuLmNhbGwodGhpc0FyZywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJheUxpa2UubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFNlZSBpZiBhcnJheUxpa2UgY29uZm9ybXMgdG8gdGhlIGl0ZXJhdG9yIHByb3RvY29sLiBOb3RlIHRoYXQgb25cbiAgICAvLyBOb2RlIDAuMTAueCwgd2hlcmUgd2UgdXNlIGVzNi1jb2xsZWN0aW9ucywgdGhpbmdzIGxpa2UgTWFwLmVudHJpZXMoKSBhbmRcbiAgICAvLyBTZXQudmFsdWVzKCkgd2lsbCBmYWxsIGludG8gdGhpcyBjYXNlIHJhdGhlciB0aGFuIHRoZSBwcmV2aW91cyBjYXNlLlxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIge2RvbmUsIHZhbHVlfSA9IGFycmF5TGlrZS5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5LnB1c2gobWFwRm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0gZWxzZSBpZiAoJ2xlbmd0aCcgaW4gYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcnJheUxpa2UsIG1hcEZuLCB0aGlzQXJnKTtcbiAgfSBlbHNlIGlmIChhcnJheUxpa2UgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAvLyBCYWNrdXAgbG9naWMgdG8gaGFuZGxlIHRoZSBlczYtY29sbGVjdGlvbnMgY2FzZS5cbiAgICByZXR1cm4gZnJvbShhcnJheUxpa2UudmFsdWVzKCksIG1hcEZuLCB0aGlzQXJnKTtcbiAgfSBlbHNlIGlmIChhcnJheUxpa2UgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAvLyBCYWNrdXAgbG9naWMgdG8gaGFuZGxlIHRoZSBlczYtY29sbGVjdGlvbnMgY2FzZS5cbiAgICByZXR1cm4gZnJvbShhcnJheUxpa2UuZW50cmllcygpLCBtYXBGbiwgdGhpc0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYXJyYXlMaWtlICtcbiAgICAgICAgJyBtdXN0IGJlIGFuIGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYW4gYXJyYXkuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnN0YW5jZSBtZXRob2Qgb2YgQXJyYXkgYXMgZGVmaW5lZCBieVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZC5cbiAqIEJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gYWRkIGVsZW1lbnRzIHRvIEFycmF5LnByb3RvdHlwZSwgd2UgbWFrZSB0aGlzIGFcbiAqIHN0YXRpYyBtZXRob2QgdGhhdCB0YWtlcyB0aGUgQXJyYXkgKHdoaWNoIHdvdWxkIGJlIHRoZSByZWNlaXZlciBpZiBpdCB3ZXJlIGFuXG4gKiBpbnN0YW5jZSBtZXRob2QpIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqL1xuZnVuY3Rpb24gZmluZChcbiAgICBhcnJheTogQXJyYXksXG4gICAgY2FsbGJhY2s6IChlbGVtZW50OiBhbnksIGluZGV4OiBudW1iZXIsIGFycmF5OiBBcnJheSkgPT4gYW55LFxuICAgIHRoaXNBcmc6ID9hbnkpOiBhbnkge1xuICB2YXIgcmVzdWx0SW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgcmV0dXJuIHJlc3VsdEluZGV4ID49MCA/IGFycmF5W3Jlc3VsdEluZGV4XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbnN0YW5jZSBtZXRob2Qgb2YgQXJyYXkgYXMgZGVmaW5lZCBieVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZEluZGV4LlxuICogQmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBhZGQgZWxlbWVudHMgdG8gQXJyYXkucHJvdG90eXBlLCB3ZSBtYWtlIHRoaXMgYVxuICogc3RhdGljIG1ldGhvZCB0aGF0IHRha2VzIHRoZSBBcnJheSAod2hpY2ggd291bGQgYmUgdGhlIHJlY2VpdmVyIGlmIGl0IHdlcmUgYW5cbiAqIGluc3RhbmNlIG1ldGhvZCkgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoXG4gICAgYXJyYXk6IEFycmF5LFxuICAgIGNhbGxiYWNrOiAoZWxlbWVudDogYW55LCBpbmRleDogbnVtYmVyLCBhcnJheTogQXJyYXkpID0+IGFueSxcbiAgICB0aGlzQXJnOiA/YW55KTogYW55IHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBhcnJheS5zb21lKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGVsZW1lbnQsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW1vdmU8VD4oYXJyYXk6IEFycmF5PFQ+LCBlbGVtZW50OiBUKTogdm9pZCB7XG4gIHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoZWxlbWVudCk7XG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluZCxcbiAgZmluZEluZGV4LFxuICBmcm9tLFxuICByZW1vdmUsXG59O1xuIl19
